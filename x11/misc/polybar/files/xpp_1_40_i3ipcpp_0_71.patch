diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/include/auss.hpp polybar-3.2.1/lib/i3ipcpp/3rd/auss/include/auss.hpp
--- polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/include/auss.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/3rd/auss/include/auss.hpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,47 @@
+#pragma once
+
+#define AUSS_HPP
+
+#include <sstream>
+
+#ifdef AUSS_USE_OWN_NAMESPACE
+	#ifndef AUSS_OWN_NAMESPACE_NAME
+	#define AUSS_OWN_NAMESPACE_NAME auss
+	#endif
+namespace AUSS_OWN_NAMESPACE_NAME {
+#endif
+
+class AutoStringStream {
+public:
+	AutoStringStream() : m_stream() {}
+	virtual ~AutoStringStream() {}
+
+	template<typename T>
+	AutoStringStream&  operator<<(const T&  arg) {
+		m_stream << arg;
+		return *this;
+	}
+
+	AutoStringStream&  operator<<(const bool arg) {
+		m_stream << (arg ? "true" : "false");
+		return *this;
+	}
+
+	operator std::string() const {
+		return m_stream.str();
+	}
+
+	const std::string  to_string() const {
+		return m_stream.str();
+	}
+private:
+	std::stringstream  m_stream;
+};
+
+#ifndef AUSS_CUSTOM_TYPEDEF
+typedef AutoStringStream auss_t;
+#endif
+
+#ifdef AUSS_USE_OWN_NAMESPACE
+}
+#endif
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/LICENSE polybar-3.2.1/lib/i3ipcpp/3rd/auss/LICENSE
--- polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/LICENSE	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/3rd/auss/LICENSE	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,24 @@
+This is free and unencumbered software released into the public domain.
+
+Anyone is free to copy, modify, publish, use, compile, sell, or
+distribute this software, either in source code form or as a compiled
+binary, for any purpose, commercial or non-commercial, and by any
+means.
+
+In jurisdictions that recognize copyright laws, the author or authors
+of this software dedicate any and all copyright interest in the
+software to the public domain. We make this dedication for the benefit
+of the public at large and to the detriment of our heirs and
+successors. We intend this dedication to be an overt act of
+relinquishment in perpetuity of all present and future rights to this
+software under copyright law.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+For more information, please refer to <http://unlicense.org/>
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/README.md polybar-3.2.1/lib/i3ipcpp/3rd/auss/README.md
--- polybar-3.2.1.orig/lib/i3ipcpp/3rd/auss/README.md	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/3rd/auss/README.md	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,27 @@
+# AutoStringStream ![license](https://img.shields.io/npm/l/chas-storage.svg)
+
+Simple header-only wrapper on `std::stringstream` with automatic casting to `std::string`
+
+## Usage
+
+```c++
+#include <auss.hpp>
+```
+```c++
+auss_t() << "Hello, " << user_name
+```
+```c++
+throw std::runtime_error(auss_t() << "Something gone wrong, See " << log_path)
+```
+
+### Own namespace
+If you wouldn't pollute global namespace just define `AUSS_USE_OWN_NAMESPACE`. Either before `#include` or in compiler flags (`-DAUSS_USE_OWN_NAMESPACE` for GCC).
+
+Also you can specifiy the name of namespace with `AUSS_OWN_NAMESPACE_NAME`:
+```
+-DAUSS_OWN_NAMESPACE_NAME="theauss"
+```
+
+## License
+
+Licensed under Unlicense. See `LICENSE` file for more info.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/CHANGELOG polybar-3.2.1/lib/i3ipcpp/CHANGELOG
--- polybar-3.2.1.orig/lib/i3ipcpp/CHANGELOG	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/CHANGELOG	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,33 @@
+0.4
+	+ Added support of GET_BARCONFIG and barconfig_update event and examples for them
+	+ Added getters form main and event sockets
+	+ Added i3ipc::get_version()
+
+	~ Calling i3ipc::connection::prepare_to_event_handling() is no more necessary
+	~ Using i3ipc::errno_error when calling c-functions instead of std::runtime_error
+	~ Logging-subsystem became public
+	~ Refactoring of CMakeLists.txt
+
+	- i3ipc::connection::get_file_descriptor() removed
+
+0.3
+	+ Added support of BINDING event
+
+	~ Removed submodules
+
+	* Bug fixies
+
+0.2.1
+	+ Added example of event handling
+	* Fixed SIGSEGV in parse_*_from_json functions
+
+0.2.0
+	+ Implemented GET_TREE (i3ipc::connection::get_tree())
+
+	~ Shipping all available payload with workspace and window events (issue #2)
+	~ i3ipc::I3Connection renamed to i3ipc::connection
+
+	~ Internal refreactoring
+
+	* Fixing failed build: Parts of a struct were initialised in wrong order, C99-style designated initialisers did not prevent this from causing an error [mox]
+	* Minor documentation and code fixies
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,74 @@
+# Project setup
+
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+project(i3ipc++ CXX)
+
+option(WITH_LOGGING "Build with log support" OFF)
+option(WITH_TESTS "Build unit tests executables" OFF)
+option(BUILD_EXAMPLES "Build example executables" OFF)
+
+add_library(${PROJECT_NAME} STATIC
+  ${PROJECT_SOURCE_DIR}/3rd/auss/include/auss.hpp
+  ${PROJECT_SOURCE_DIR}/include/i3ipc++/ipc.hpp
+  ${PROJECT_SOURCE_DIR}/include/i3ipc++/ipc-util.hpp
+  ${PROJECT_SOURCE_DIR}/src/ipc.cpp
+  ${PROJECT_SOURCE_DIR}/src/ipc-util.cpp)
+
+target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/3rd/auss/include)
+target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/include)
+
+target_compile_options(${PROJECT_NAME} PRIVATE -std=c++11 -Wall -Wextra -Wno-unused-parameter -Wno-deprecated-declarations)
+target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Debug>:-g3 -DDEBUG>)
+target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Release>:-O2>)
+
+# External library: jsoncpp-1.7.7 {{{
+
+find_package(PkgConfig)
+pkg_check_modules(JSONCPP jsoncpp>=1.7.7)
+
+if(NOT JSONCPP_FOUND)
+  message(STATUS "Could not find jsoncpp>=1.7.7 -- building static lib...")
+  add_subdirectory(${PROJECT_SOURCE_DIR}/libs/jsoncpp-1.7.7 EXCLUDE_FROM_ALL)
+  set(JSONCPP_LIBRARIES jsoncpp_lib_static)
+  set(JSONCPP_INCLUDEDIR ${PROJECT_SOURCE_DIR}/libs/jsoncpp-1.7.7/include)
+elseif(NOT JSONCPP_LIBRARIES AND JSONCPP_LIBS)
+  set(JSONCPP_LIBRARIES "${JSONCPP_LIBS}")
+endif()
+
+target_link_libraries(${PROJECT_NAME} PUBLIC ${JSONCPP_LIBRARIES})
+target_include_directories(${PROJECT_NAME} PUBLIC ${JSONCPP_INCLUDEDIR})
+
+# }}}
+# Export lists to the parent scope if there are any {{{
+
+get_directory_property(HAS_PARENT PARENT_DIRECTORY)
+if(HAS_PARENT)
+  set(I3IPCPP_LIBRARIES ${PROJECT_NAME} PARENT_SCOPE)
+  set(I3IPCPP_INCLUDE_DIRS ${PROJECT_SOURCE_DIR}/include ${JSONCPP_INCLUDEDIR})
+endif()
+
+# }}}
+# Build examples if the option was given {{{
+
+if(BUILD_EXAMPLES)
+  add_subdirectory("${PROJECT_SOURCE_DIR}/examples")
+endif()
+
+# }}}
+# Build cpp tests if the option was given {{{
+
+if(WITH_TESTS)
+  find_package(CxxTest)
+  if(CXXTEST_FOUND)
+    include_directories(${CXXTEST_INCLUDE_DIR} "${PROJECT_SOURCE_DIR}/src")
+    add_definitions("-DTEST_SRC_ROOT=${PROJECT_SOURCE_DIR}/test")
+    enable_testing()
+    file(GLOB SRC_TEST "${PROJECT_SOURCE_DIR}/test/*.hpp")
+    CXXTEST_ADD_TEST(i3ipcpp_check test.cpp ${SRC_TEST})
+    target_link_libraries(i3ipcpp_check ${I3IPCPP_LIBRARIES})
+  else()
+    message(WARNING "CxxTest not found. Unable to run unit-tests")
+  endif()
+endif()
+
+# }}}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/Doxyfile polybar-3.2.1/lib/i3ipcpp/Doxyfile
--- polybar-3.2.1.orig/lib/i3ipcpp/Doxyfile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/Doxyfile	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2353 @@
+# Doxyfile 1.8.8
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+# for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = i3ipc++
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         = 
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = "An C++ implementaiton of the i3 IPC"
+
+# With the PROJECT_LOGO tag one can specify an logo or icon that is included in
+# the documentation. The maximum height of the logo should not exceed 55 pixels
+# and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
+# to the output directory.
+
+PROJECT_LOGO           = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = doc
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = YES
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
+# new page for each member. If set to NO, the documentation of a member will be
+# part of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                = 
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
+# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
+# Fortran. In the later case the parser tries to guess whether the code is fixed
+# or free formatted code, this is the default for Fortran type files), VHDL. For
+# instance to make doxygen treat .inc files as Fortran files (default is PHP),
+# and .f files as C (default is Fortran), use: inc=Fortran f=C.
+#
+# Note For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by by putting a % sign in front of the word
+# or globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = YES
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO these classes will be included in the various overviews. This option has
+# no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO 
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
+# todo list. This list is created by putting \todo commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
+# test list. This list is created by putting \test commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES the list
+# will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            = 
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO doxygen will only warn about wrong or incomplete parameter
+# documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           = doxygen-warning.log
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces.
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = include
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: http://www.gnu.org/software/libiconv) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank the
+# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
+# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
+# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
+# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
+# *.qsf, *.as and *.js.
+
+FILE_PATTERNS          = *.hpp \
+                         *.h
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = *.cpp
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER ) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS = 
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES, then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see http://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES, then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# compiled with the --with-libclang option.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        = 
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefor more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra stylesheet files is of importance (e.g. the last
+# stylesheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  = 
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       = 
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the stylesheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: http://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               = 
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler ( hhc.exe). If non-empty
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           = 
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated (
+# YES) or that it should be included in the master .chm file ( NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     = 
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated (
+# YES) or a normal table of contents ( NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = YES
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# http://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using prerendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from http://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     = 
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       = 
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       = 
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     = 
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. To get the times font for
+# instance you can specify
+# EXTRA_PACKAGES=times
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empy string,
+# for the replacement values of the other commands the user is refered to
+# HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           = 
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           = 
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             = 
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
+# Definitions (see http://autogen.sf.net) file that captures the structure of
+# the code including all documentation. Note that this feature is still
+# experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
+# in the source code. If set to NO only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES the includes files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external class will be listed in the
+# class index. If set to NO only the inherited external classes will be listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
+# the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            = 
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               = 
+
+# If set to YES, the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: YES.
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot.
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,
+# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,
+# gif:cairo:gd, gif:gd, gif:gd:gd and svg.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           = 
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           = 
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           = 
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+PLANTUML_JAR_PATH      = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/examples/bar-configs.cpp polybar-3.2.1/lib/i3ipcpp/examples/bar-configs.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/examples/bar-configs.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/examples/bar-configs.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,43 @@
+/**
+ * This program dumps all available barconfigs
+ */
+
+#include <iostream>
+
+#include <i3ipc++/ipc.hpp>
+
+
+static void  dump_bar_config(const i3ipc::bar_config_t&  bc) {
+	std::cout << '"' << bc.id << '"' << std::endl
+		<< "\tmode = " << static_cast<char>(bc.mode) << std::endl
+		<< "\tposition = " << static_cast<char>(bc.position) << std::endl
+		<< "\tstatus_command = \"" << bc.status_command << '"' << std::endl
+		<< "\tfont = \"" << bc.font << '"' << std::endl
+		<< "\tworkspace_buttons = " << (bc.workspace_buttons ? "true" : "false") << std::endl
+		<< "\tbinding_mode_indicator = " << (bc.binding_mode_indicator ? "true" : "false") << std::endl
+		<< "\tverbose = " << (bc.verbose ? "true" : "false") << std::endl
+		<< "\tcolors:" << std::endl;
+
+	std::cout << std::hex;
+	for (auto  iter = bc.colors.begin(); iter != bc.colors.end(); iter++) {
+		std::cout << "\t\t\"" << iter->first << "\" = #" << iter->second << std::endl;
+	}
+	std::cout << std::dec;
+}
+
+
+int  main() {
+	// First of all needs to create a connection
+	i3ipc::connection  conn;
+
+	// Then request a list of barconfigs
+	std::vector<std::string>  bar_configs = conn.get_bar_configs_list();
+
+	// And dump 'em all!!!!!
+	for (auto&  name : bar_configs) {
+		std::shared_ptr<i3ipc::bar_config_t>  bc = conn.get_bar_config(name);
+		dump_bar_config(*bc);
+	}
+
+	return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/examples/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/examples/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/examples/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/examples/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,23 @@
+cmake_minimum_required(VERSION 3.0)
+project(i3ipc++-examples)
+
+include_directories(
+	${I3IPCpp_INCLUDE_DIRS}
+)
+
+link_directories(
+	${I3IPCpp_LIBRARY_DIRS}
+)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wextra -Wno-unused-parameter")
+set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g3 -DDEBUG")
+set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")
+
+add_executable(workspaces workspaces.cpp)
+target_link_libraries(workspaces ${I3IPCpp_LIBRARIES})
+
+add_executable(events events.cpp)
+target_link_libraries(events ${I3IPCpp_LIBRARIES})
+
+add_executable(bar-configs bar-configs.cpp)
+target_link_libraries(bar-configs ${I3IPCpp_LIBRARIES})
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/examples/events.cpp polybar-3.2.1/lib/i3ipcpp/examples/events.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/examples/events.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/examples/events.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,46 @@
+/**
+ * This programs handle events and dump them to console
+ */
+
+#include <iostream>
+
+#include <i3ipc++/ipc.hpp>
+
+
+int  main() {
+	// First of all we need to connect to an i3 process
+	i3ipc::connection  conn;
+
+	// Then we subscribing on events (see i3ipc::EVENT_TYPE)
+	conn.subscribe(i3ipc::ET_WORKSPACE | i3ipc::ET_WINDOW | i3ipc::ET_BINDING);
+
+	// Handler of workspace_event
+	conn.signal_workspace_event.connect([](const i3ipc::workspace_event_t&  ev) {
+		std::cout << "workspace_event: " << (char)ev.type << std::endl;
+	});
+
+	// Handler of window_event
+	conn.signal_window_event.connect([](const i3ipc::window_event_t&  ev) {
+		std::cout << "window_event: " << (char)ev.type << std::endl;
+	});
+
+	// Handler of binding event
+	conn.signal_binding_event.connect([](const i3ipc::binding_t&  b) {
+		std::cout << "binding_event:" << std::endl
+			<< "\tcommand = \"" << b.command << '"' << std::endl
+			<< "\tinput_code = " << b.input_code << std::endl
+			<< "\tsymbol = " << b.symbol << std::endl
+			<< "\tinput_type = " << static_cast<char>(b.input_type) << std::endl
+			<< "\tevent_state_mask =" << std::endl;
+		for (const std::string& s : b.event_state_mask) {
+			std::cout << "\t\t\"" << s << '"' << std::endl;
+		}
+	});
+
+	// And starting an event-handling loop
+	while (true) {
+		conn.handle_event();
+	}
+
+	return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/examples/workspaces.cpp polybar-3.2.1/lib/i3ipcpp/examples/workspaces.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/examples/workspaces.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/examples/workspaces.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,64 @@
+/**
+ * This program dumps a tree of windows and workspaces to console
+ */
+
+#include <iostream>
+
+#include <i3ipc++/ipc.hpp>
+
+
+/**
+ * Reqursively dump containers of a tree
+ * @param  c      a root container
+ * @param  prefix an alignment
+ */
+void  dump_tree_container(const i3ipc::container_t&  c, std::string&  prefix) {
+	std::cout << prefix << "ID: " << c.id << " (i3's; X11's - " << c.xwindow_id << ")" << std::endl;
+	prefix.push_back('\t');
+	std::cout << prefix << "name = \"" << c.name << "\"" << std::endl;
+	std::cout << prefix << "type = \"" << c.type << "\"" << std::endl;
+	std::cout << prefix << "border = \"" << c.border_raw << "\"" << std::endl;
+	std::cout << prefix << "current_border_width = " << c.current_border_width << std::endl;
+	std::cout << prefix << "layout = \"" << c.layout_raw << "\"" << std::endl;
+	std::cout << prefix << "percent = " << c.percent << std::endl;
+	if (c.urgent) {
+		std::cout << prefix << "urgent" << std::endl;
+	}
+	if (c.focused) {
+		std::cout << prefix << "focused" << std::endl;
+	}
+	prefix.push_back('\t');
+	for (auto&  n : c.nodes) {
+		dump_tree_container(*n, prefix);
+	}
+	prefix.pop_back();
+	prefix.pop_back();
+}
+
+
+int  main() {
+	// First of all needs to create a connection
+	i3ipc::connection  conn;
+
+	// Then we dump workspaces
+	for (auto&  w : conn.get_workspaces()) {
+		std::cout << '#' << std::hex << w->num << std::dec
+			<< "\n\tName: " << w->name
+			<< "\n\tVisible: " << w->visible
+			<< "\n\tFocused: " << w->focused
+			<< "\n\tUrgent: " << w->urgent
+			<< "\n\tRect: "
+			<< "\n\t\tX: " << w->rect.x
+			<< "\n\t\tY: " << w->rect.y
+			<< "\n\t\tWidth: " << w->rect.width
+			<< "\n\t\tHeight: " << w->rect.height
+			<< "\n\tOutput: " << w->output
+			<< std::endl;
+	}
+
+	// Then we dump the tree
+	std::string  prefix_buf;
+	dump_tree_container(*conn.get_tree(), prefix_buf);
+
+	return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/.gitignore polybar-3.2.1/lib/i3ipcpp/.gitignore
--- polybar-3.2.1.orig/lib/i3ipcpp/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/.gitignore	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+build
+doc
+*.sublime-workspace
+*.log
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/ipc.hpp polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/ipc.hpp
--- polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/ipc.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/ipc.hpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,377 @@
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <memory>
+#include <vector>
+#include <map>
+#include <list>
+#include <functional>
+
+extern "C" {
+#include <i3/ipc.h>
+}
+
+/**
+ * @addtogroup i3ipc i3 IPC C++ binding
+ * @{
+ */
+namespace i3ipc {
+
+/**
+ * Get path to the i3 IPC socket
+ * @return Path to a socket
+ */
+std::string  get_socketpath();
+
+/**
+ * Primitive of rectangle
+ */
+struct rect_t {
+	uint32_t  x; ///< Position on X axis
+	uint32_t  y; ///< Position on Y axis
+	uint32_t  width; ///< Width of rectangle
+	uint32_t  height; ///< Height of rectangle
+};
+
+/**
+ * i3's workspace
+ */
+struct workspace_t {
+	int  num; ///< Index of the worksapce
+	std::string  name; ///< Name of the workspace
+	bool  visible; ///< Is the workspace visible
+	bool  focused; ///< Is the workspace is currently focused
+	bool  urgent; ///< Is the workspace is urgent
+	rect_t  rect; ///< A size of the workspace
+	std::string  output; ///< An output of the workspace
+};
+
+/**
+ * i3's output
+ */
+struct output_t {
+	std::string  name; ///< Name of the output
+	bool  active; ///< Is the output currently active
+	std::string  current_workspace; ///< Name of current workspace
+	rect_t  rect; ///< Size of the output
+};
+
+/**
+ * Version of i3
+ */
+struct version_t {
+	std::string  human_readable; ///< Human redable version string
+	std::string  loaded_config_file_name; ///< Path to current config of i3
+	uint32_t  major; ///< Major version of i3
+	uint32_t  minor; ///< Minor version of i3
+	uint32_t  patch; ///< Patch number of i3
+};
+
+
+/**
+ * Types of the events of i3
+ */
+enum EventType {
+	ET_WORKSPACE = (1 << 0), ///< Workspace event
+	ET_OUTPUT = (1 << 1), ///< Output event
+	ET_MODE = (1 << 2), ///< Output mode event
+	ET_WINDOW = (1 << 3), ///< Window event
+	ET_BARCONFIG_UPDATE = (1 << 4), ///< Bar config update event @attention Yet is not implemented as signal in connection
+	ET_BINDING = (1 << 5), ///< Binding event
+};
+
+/**
+ * Types of workspace events
+ */
+enum class WorkspaceEventType : char {
+	FOCUS = 'f', ///< Focused
+	INIT = 'i', ///< Initialized
+	EMPTY = 'e', ///< Became empty
+	URGENT = 'u', ///< Became urgent
+	RENAME = 'r', ///< Renamed
+	RELOAD = 'l', ///< Reloaded
+	RESTORED = 's', ///< Restored
+};
+
+/**
+ * Types of window events
+ */
+enum class WindowEventType : char {
+	NEW = 'n', ///< Window created
+	CLOSE = 'c', ///< Window closed
+	FOCUS = 'f', ///< Window got focus
+	TITLE = 't', ///< Title of window has been changed
+	FULLSCREEN_MODE = 'F', ///< Window toggled to fullscreen mode
+	MOVE = 'M', ///< Window moved
+	FLOATING = '_', ///< Window toggled floating mode
+	URGENT = 'u', ///< Window became urgent
+};
+
+
+/**
+ * A style of a container's border
+ */
+enum class BorderStyle : char {
+	UNKNOWN = '?', //< If got an unknown border style in reply
+	NONE = 'N',
+	NORMAL = 'n',
+	PIXEL = 'P',
+	ONE_PIXEL = '1',
+};
+
+
+/**
+ * A type of a container's layout
+ */
+enum class ContainerLayout : char {
+	UNKNOWN = '?', //< If got an unknown border style in reply
+	SPLIT_H = 'h',
+	SPLIT_V = 'v',
+	STACKED = 's',
+	TABBED = 't',
+	DOCKAREA = 'd',
+	OUTPUT = 'o',
+};
+
+
+/**
+ * A type of the input of bindings
+ */
+enum class InputType : char {
+	UNKNOWN = '?', //< If got an unknown input_type in binding_event
+	KEYBOARD = 'k',
+	MOUSE = 'm',
+};
+
+
+/**
+ * A mode of a bar
+ */
+enum class BarMode : char {
+	UNKNOWN = '?',
+	DOCK = 'd', ///< The bar sets the dock window type
+	HIDE = 'h', ///< The bar does not show unless a specific key is pressed
+};
+
+
+/**
+ * A position (of a bar?)
+ */
+enum class Position : char {
+	UNKNOWN = '?',
+	TOP = 't',
+	BOTTOM = 'b',
+};
+
+
+/**
+ * A node of tree of windows
+ */
+struct container_t {
+	uint64_t  id; ///< The internal ID (actually a C pointer value) of this container. Do not make any assumptions about it. You can use it to (re-)identify and address containers when talking to i3
+	uint64_t  xwindow_id; ///< The X11 window ID of the actual client window inside this container. This field is set to null for split containers or otherwise empty containers. This ID corresponds to what xwininfo(1) and other X11-related tools display (usually in hex)
+	std::string  name; ///< The internal name of this container. For all containers which are part of the tree structure down to the workspace contents, this is set to a nice human-readable name of the container. For containers that have an X11 window, the content is the title (_NET_WM_NAME property) of that window. For all other containers, the content is not defined (yet)
+	std::string  type; ///< Type of this container
+	BorderStyle  border; ///< A style of the container's border
+	std::string  border_raw; ///< A "border" field of TREE reply. NOT empty only if border equals BorderStyle::UNKNOWN
+	uint32_t  current_border_width; ///< Number of pixels of the border width
+	ContainerLayout  layout; ///< A type of the container's layout
+	std::string  layout_raw; ///< A "layout" field of TREE reply. NOT empty only if layout equals ContainerLayout::UNKNOWN
+	float  percent; ///< The percentage which this container takes in its parent. A value of < 0 means that the percent property does not make sense for this container, for example for the root container.
+	rect_t  rect; ///< The absolute display coordinates for this container
+	rect_t  window_rect; ///< The coordinates of the actual client window inside its container. These coordinates are relative to the container and do not include the window decoration (which is actually rendered on the parent container)
+	rect_t  deco_rect; ///< The coordinates of the window decoration inside its container. These coordinates are relative to the container and do not include the actual client window
+	rect_t  geometry; ///< The original geometry the window specified when i3 mapped it. Used when switching a window to floating mode, for example
+	bool  urgent;
+	bool  focused;
+
+	std::list< std::shared_ptr<container_t> >  nodes;
+};
+
+
+/**
+ * A workspace event
+ */
+struct workspace_event_t {
+	WorkspaceEventType  type;
+	std::shared_ptr<workspace_t>  current; ///< Current focused workspace
+	std::shared_ptr<workspace_t>  old; ///< Old (previous) workspace @note With some WindowEventType could be null
+};
+
+
+/**
+ * A window event
+ */
+struct window_event_t {
+	WindowEventType  type;
+	std::shared_ptr<container_t>  container; ///< A container event associated with @note With some WindowEventType could be null
+};
+
+
+/**
+ * A binding
+ */
+struct binding_t {
+	std::string  command; ///< The i3 command that is configured to run for this binding
+	std::vector<std::string>  event_state_mask; ///< The group and modifier keys that were configured with this binding
+	int32_t  input_code; ///< If the binding was configured with bindcode, this will be the key code that was given for the binding. If the binding is a mouse binding, it will be the number of the mouse button that was pressed. Otherwise it will be 0
+	std::string  symbol; ///< If this is a keyboard binding that was configured with bindsym, this field will contain the given symbol. Otherwise it will be null
+	InputType  input_type;
+};
+
+
+/**
+ * A mode
+ */
+struct mode_t {
+	std::string  change; ///< The current mode in use
+	bool pango_markup; ///< Should pango markup be used for displaying this mode
+};
+
+
+/**
+ * A bar configuration
+ */
+struct bar_config_t {
+	std::string  id; ///< The ID for this bar. Included in case you request multiple configurations and want to differentiate the different replies.
+	BarMode  mode;
+	Position  position;
+	std::string  status_command; ///< Command which will be run to generate a statusline. Each line on stdout of this command will be displayed in the bar. At the moment, no formatting is supported
+	std::string  font; ///< The font to use for text on the bar
+	bool  workspace_buttons; ///< Display workspace buttons or not? Defaults to true.
+	bool  binding_mode_indicator; ///< Display the mode indicator or not? Defaults to true.
+	bool  verbose; ///< Should the bar enable verbose output for debugging? Defaults to false.
+	std::map<std::string, uint32_t>  colors; ///< Contains key/value pairs of colors. Each value is a color code in format 0xRRGGBB
+};
+
+
+struct buf_t;
+/**
+ * Connection to the i3
+ */
+class connection {
+public:
+	/**
+	 * Connect to the i3
+	 * @param  socket_path path to a i3 IPC socket
+	 */
+	connection(const std::string&  socket_path = get_socketpath());
+	~connection();
+
+	/**
+	 * Send a command to i3
+	 * @param  command command
+	 * @return         Is command successfully executed
+	 */
+	bool  send_command(const std::string&  command) const;
+
+	/**
+	 * Request a list of workspaces
+	 * @return List of workspaces
+	 */
+	std::vector< std::shared_ptr<workspace_t> >  get_workspaces() const;
+
+	/**
+	 * Request a list of outputs
+	 * @return List of outputs
+	 */
+	std::vector< std::shared_ptr<output_t> >  get_outputs() const;
+
+	/**
+	 * Request a version of i3
+	 * @return Version of i3
+	 */
+	version_t  get_version() const;
+
+	/**
+	 * Request a tree of windows
+	 * @return A root container
+	 */
+	std::shared_ptr<container_t>  get_tree() const;
+
+	/**
+	 * Request a list of names of available barconfigs
+	 * @return A list of names of barconfigs
+	 */
+	std::vector<std::string>  get_bar_configs_list() const;
+
+	/**
+	 * Request a barconfig
+	 * @param  name  name of barconfig
+	 * @return The barconfig
+	 */
+	std::shared_ptr<bar_config_t>  get_bar_config(const std::string&  name) const;
+
+	/**
+	 * Subscribe on an events of i3
+	 *
+	 * If connection isn't handling events at the moment, event numer will be added to subscription list.
+	 * Else will also send subscripe request to i3
+	 *
+	 * Example:
+	 * @code{.cpp}
+	 * connection  conn;
+	 * conn.subscribe(i3ipc::ipc::ET_WORKSPACE | i3ipc::ipc::ET_WINDOW);
+	 * @endcode
+	 *
+	 * @param  events event type (EventType enum)
+	 * @return        Is successfully subscribed. If connection isn't handling events at the moment, then always true.
+	 */
+	bool  subscribe(const int32_t  events);
+
+	/**
+	 * Handle an event from i3
+	 * @note Used only in main()
+	 */
+	bool handle_event();
+
+	/**
+	 * Get the fd of the main socket
+	 * @return the file descriptor of the main socket.
+	 */
+	int32_t get_main_socket_fd();
+
+	/**
+	 * Get the fd of the event socket
+	 * @return the file descriptor of the event socket.
+	 */
+	int32_t get_event_socket_fd();
+
+	/**
+	 * Connect the event socket to IPC
+	 * @param  reconnect if true the event socket will be disconnected and connected again
+	 * @note Automaticly called, when calling handle_event();
+	 */
+	void  connect_event_socket(const bool  reconnect = false);
+
+	/**
+	 * Disconnect the event socket
+	 */
+	void  disconnect_event_socket();
+
+	std::function<void(const workspace_event_t&)> on_workspace_event; ///< Workspace event signal
+	std::function<void()> on_output_event; ///< Output event signal
+	std::function<void(const mode_t&)> on_mode_event; ///< Output mode event signal
+	std::function<void(const window_event_t&)> on_window_event; ///< Window event signal
+	std::function<void(const bar_config_t&)> on_barconfig_update_event; ///< Barconfig update event signal
+	std::function<void(const binding_t&)> on_binding_event; ///< Binding event signal
+	std::function<void(EventType, const std::shared_ptr<const buf_t>&)> on_event; ///< i3 event signal @note Default handler routes event to signal according to type
+private:
+	const int32_t  m_main_socket;
+	int32_t  m_event_socket;
+	int32_t  m_subscriptions;
+	const std::string  m_socket_path;
+};
+
+/**
+ * Get version of i3ipc++
+ * @return the version of i3ipc++
+ */
+const version_t&  get_version();
+
+}
+
+/**
+ * @}
+ */
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/ipc-util.hpp polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/ipc-util.hpp
--- polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/ipc-util.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/ipc-util.hpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,169 @@
+#pragma once
+
+#include <cstdint>
+#include <string>
+#include <memory>
+#include <stdexcept>
+
+// extern "C" {
+// #include <i3/ipc.h>
+// }
+
+namespace i3ipc {
+
+/** @defgroup i3ipc_util i3 IPC internal utilities
+ * Stuff for internal usage in I3Connection 
+ * @{
+ */
+
+// extern "C" {
+
+/**
+ * i3 IPC header
+ */
+struct header_t {
+	/* 6 = strlen(I3_IPC_MAGIC) */
+	char magic[6]; ///< Magic string @see I3_IPC_MAGIC
+	uint32_t size; ///< Size of payload
+	uint32_t type; ///< Message type
+}  __attribute__ ((packed));
+
+
+/**
+ * @brief Base class of i3 IPC errors
+ */
+class ipc_error : public std::runtime_error { using std::runtime_error::runtime_error; };
+
+/**
+ * @brief Something wrong in message header (wrong magic number, message type etc.)
+ */
+class invalid_header_error : public ipc_error { using ipc_error::ipc_error; };
+
+/**
+ * @brief Socket return EOF, but expected a data
+ */
+class eof_error : public ipc_error { using ipc_error::ipc_error; };
+
+/**
+ * @brief If something wrong in a payload of i3's reply
+ */
+class invalid_reply_payload_error : public ipc_error { using ipc_error::ipc_error; };
+
+/**
+ * @brief If any error occured, while using C-functions
+ */
+class errno_error : public ipc_error {
+public:
+	errno_error();
+	errno_error(const std::string&  msg);
+};
+
+
+/**
+ * @brief Messages (requests), that can be sended from the client
+ */
+enum class ClientMessageType : uint32_t {
+	COMMAND = 0,
+	GET_WORKSPACES = 1,
+	SUBSCRIBE = 2,
+	GET_OUTPUTS = 3,
+	GET_TREE = 4,
+	GET_MARKS = 5,
+	GET_BAR_CONFIG = 6,
+	GET_VERSION = 7,
+};
+
+
+/**
+ * @brief Replies, that can be sended from the i3 to the client
+ */
+enum class ReplyType : uint32_t {
+	COMMAND = 0,
+	WORKSPACES = 1,
+	SUBSCRIBE = 2,
+	OUTPUTS = 3,
+	TREE = 4,
+	MARKS = 5,
+	BAR_CONFIG = 6,
+	VERSION = 7,
+};
+
+
+/**
+ * @brief i3 IPC message buffer
+ */
+struct buf_t {
+	uint32_t  size; ///< @brief Size of whole buffer
+	uint8_t*  data; ///< @brief Pointer to the message
+
+	/**
+	 * @brief i3 IPC message header
+	 *
+	 * Pointing on the begining
+	 */
+	header_t*  header;
+
+	/**
+	 * @brief Message payload
+	 *
+	 * Pointing on the byte after the header
+	 */
+	char*  payload;
+
+	buf_t(uint32_t  payload_size);
+	~buf_t();
+
+	/**
+	 * @brief Resize payload to the payload_size in the header
+	 */
+	void  realloc_payload_to_header();
+};
+
+/**
+ * Connect to the i3 socket
+ * @param  socket_path a socket path
+ * @return             socket id
+ */
+int32_t  i3_connect(const std::string&  socket_path);
+
+/**
+ * @brief Close the connection
+ * @param  sockfd socket
+ */
+void  i3_disconnect(const int32_t  sockfd);
+
+/**
+ * @brief Send message to the socket
+ * @param  sockfd a socket
+ * @param  buff   a message
+ */
+void   i3_send(const int32_t  sockfd, const buf_t&  buff);
+
+/**
+ * @brief Recive a message from i3
+ * @param  sockfd  a socket
+ * @return  a buffer of the message
+ */
+std::shared_ptr<buf_t>   i3_recv(const int32_t  sockfd);
+
+/**
+ * @brief Pack a buffer of message
+ */
+std::shared_ptr<buf_t>  i3_pack(const ClientMessageType  type, const std::string&  payload);
+
+/**
+ * @brief Pack, send a message and receiv a reply
+ *
+ * Almost same to:
+ * @code{.cpp}
+ * i3_send(sockfd, i3_pack(type, payload));
+ * auto  reply = i3_recv(sockfd);
+ * @endcode
+ */
+std::shared_ptr<buf_t>  i3_msg(const int32_t  sockfd, const ClientMessageType  type, const std::string&  payload = std::string());
+
+/**
+ * @}
+ */
+
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/log.hpp polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/log.hpp
--- polybar-3.2.1.orig/lib/i3ipcpp/include/i3ipc++/log.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/include/i3ipc++/log.hpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,97 @@
+#pragma once
+
+#include <ostream>
+#include <vector>
+#include <auss.hpp>
+
+/**
+ * @addtogroup logging Logging
+ * @{
+ */
+
+namespace i3ipc {
+
+/**
+ * @brief Common logging outputs
+ */
+extern std::vector<std::ostream*>  g_logging_outs;
+
+/**
+ * @brief Logging outputs for error messages
+ */
+extern std::vector<std::ostream*>  g_logging_err_outs;
+
+/**
+ * @brief Put to a logging outputs some dtat
+ * @param  data  data, that you want to put to the logging outputs
+ * @param  err  is your information is error report or something that must be putted to the error logging outputs
+ */
+template<typename T>
+inline void  log(const T&  data, const bool  err=false) {
+	for (auto  out : (err ? g_logging_err_outs : g_logging_outs)) {
+		*out << data << std::endl;
+	}
+}
+
+template<>
+inline void  log(const auss_t&  data, const bool  err) {
+	log(data.to_string());
+}
+
+}
+
+#ifdef WITH_LOGGING
+
+/**
+ * Internal macro used in I3IPC_*-logging macros
+ */
+#define I3IPC_LOG(T, ERR) \
+	::i3ipc::log((T), (ERR));
+
+/**
+ * Put information message to log
+ * @param T message
+ */
+#define I3IPC_INFO(T) I3IPC_LOG(auss_t() << "i: " << T, false)
+
+/**
+ * Put error message to log
+ * @param T message
+ */
+#define I3IPC_ERR(T) I3IPC_LOG(auss_t() << "E: " << T, true)
+
+/**
+ * Put warning message to log
+ * @param T message
+ */
+#define I3IPC_WARN(T) I3IPC_LOG(auss_t() << "W: " << T, true)
+
+#ifdef DEBUG
+
+/**
+ * Put debug message to log
+ * @param T message
+ */
+#define I3IPC_DEBUG(T) I3IPC_LOG(auss_t() << "D: " << T, true)
+
+#else
+
+/**
+ * Put debug message to log
+ * @param T message
+ */
+#define I3IPC_DEBUG(T)
+#endif
+
+#else
+#define I3IPC_LOG(T, ERR)
+#define I3IPC_INFO(T)
+#define I3IPC_ERR(T)
+#define I3IPC_WARN(T)
+#define I3IPC_DEBUG(T)
+#define I3IPC_DEBUG(T)
+#endif
+
+/**
+ * @}
+ */
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/LICENSE polybar-3.2.1/lib/i3ipcpp/LICENSE
--- polybar-3.2.1.orig/lib/i3ipcpp/LICENSE	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/LICENSE	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015 Sergey Naumov
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/amalgamate.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/amalgamate.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/amalgamate.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/amalgamate.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,155 @@
+"""Amalgate json-cpp library sources into a single source and header file.
+
+Works with python2.6+ and python3.4+.
+
+Example of invocation (must be invoked from json-cpp top directory):
+python amalgate.py
+"""
+import os
+import os.path
+import sys
+
+class AmalgamationFile:
+    def __init__(self, top_dir):
+        self.top_dir = top_dir
+        self.blocks = []
+
+    def add_text(self, text):
+        if not text.endswith("\n"):
+            text += "\n"
+        self.blocks.append(text)
+
+    def add_file(self, relative_input_path, wrap_in_comment=False):
+        def add_marker(prefix):
+            self.add_text("")
+            self.add_text("// " + "/"*70)
+            self.add_text("// %s of content of file: %s" % (prefix, relative_input_path.replace("\\","/")))
+            self.add_text("// " + "/"*70)
+            self.add_text("")
+        add_marker("Beginning")
+        f = open(os.path.join(self.top_dir, relative_input_path), "rt")
+        content = f.read()
+        if wrap_in_comment:
+            content = "/*\n" + content + "\n*/"
+        self.add_text(content)
+        f.close()
+        add_marker("End")
+        self.add_text("\n\n\n\n")
+
+    def get_value(self):
+        return "".join(self.blocks).replace("\r\n","\n")
+
+    def write_to(self, output_path):
+        output_dir = os.path.dirname(output_path)
+        if output_dir and not os.path.isdir(output_dir):
+            os.makedirs(output_dir)
+        f = open(output_path, "wb")
+        f.write(str.encode(self.get_value(), 'UTF-8'))
+        f.close()
+
+def amalgamate_source(source_top_dir=None,
+                       target_source_path=None,
+                       header_include_path=None):
+    """Produces amalgated source.
+       Parameters:
+           source_top_dir: top-directory
+           target_source_path: output .cpp path
+           header_include_path: generated header path relative to target_source_path.
+    """
+    print("Amalgating header...")
+    header = AmalgamationFile(source_top_dir)
+    header.add_text("/// Json-cpp amalgated header (http://jsoncpp.sourceforge.net/).")
+    header.add_text('/// It is intended to be used with #include "%s"' % header_include_path)
+    header.add_file("LICENSE", wrap_in_comment=True)
+    header.add_text("#ifndef JSON_AMALGATED_H_INCLUDED")
+    header.add_text("# define JSON_AMALGATED_H_INCLUDED")
+    header.add_text("/// If defined, indicates that the source file is amalgated")
+    header.add_text("/// to prevent private header inclusion.")
+    header.add_text("#define JSON_IS_AMALGAMATION")
+    header.add_file("include/json/version.h")
+    #header.add_file("include/json/allocator.h") # Not available here.
+    header.add_file("include/json/config.h")
+    header.add_file("include/json/forwards.h")
+    header.add_file("include/json/features.h")
+    header.add_file("include/json/value.h")
+    header.add_file("include/json/reader.h")
+    header.add_file("include/json/writer.h")
+    header.add_file("include/json/assertions.h")
+    header.add_text("#endif //ifndef JSON_AMALGATED_H_INCLUDED")
+
+    target_header_path = os.path.join(os.path.dirname(target_source_path), header_include_path)
+    print("Writing amalgated header to %r" % target_header_path)
+    header.write_to(target_header_path)
+
+    base, ext = os.path.splitext(header_include_path)
+    forward_header_include_path = base + "-forwards" + ext
+    print("Amalgating forward header...")
+    header = AmalgamationFile(source_top_dir)
+    header.add_text("/// Json-cpp amalgated forward header (http://jsoncpp.sourceforge.net/).")
+    header.add_text('/// It is intended to be used with #include "%s"' % forward_header_include_path)
+    header.add_text("/// This header provides forward declaration for all JsonCpp types.")
+    header.add_file("LICENSE", wrap_in_comment=True)
+    header.add_text("#ifndef JSON_FORWARD_AMALGATED_H_INCLUDED")
+    header.add_text("# define JSON_FORWARD_AMALGATED_H_INCLUDED")
+    header.add_text("/// If defined, indicates that the source file is amalgated")
+    header.add_text("/// to prevent private header inclusion.")
+    header.add_text("#define JSON_IS_AMALGAMATION")
+    header.add_file("include/json/config.h")
+    header.add_file("include/json/forwards.h")
+    header.add_text("#endif //ifndef JSON_FORWARD_AMALGATED_H_INCLUDED")
+
+    target_forward_header_path = os.path.join(os.path.dirname(target_source_path),
+                                               forward_header_include_path)
+    print("Writing amalgated forward header to %r" % target_forward_header_path)
+    header.write_to(target_forward_header_path)
+
+    print("Amalgating source...")
+    source = AmalgamationFile(source_top_dir)
+    source.add_text("/// Json-cpp amalgated source (http://jsoncpp.sourceforge.net/).")
+    source.add_text('/// It is intended to be used with #include "%s"' % header_include_path)
+    source.add_file("LICENSE", wrap_in_comment=True)
+    source.add_text("")
+    source.add_text('#include "%s"' % header_include_path)
+    source.add_text("""
+#ifndef JSON_IS_AMALGAMATION
+#error "Compile with -I PATH_TO_JSON_DIRECTORY"
+#endif
+""")
+    source.add_text("")
+    lib_json = "src/lib_json"
+    source.add_file(os.path.join(lib_json, "json_tool.h"))
+    source.add_file(os.path.join(lib_json, "json_reader.cpp"))
+    source.add_file(os.path.join(lib_json, "json_valueiterator.inl"))
+    source.add_file(os.path.join(lib_json, "json_value.cpp"))
+    source.add_file(os.path.join(lib_json, "json_writer.cpp"))
+
+    print("Writing amalgated source to %r" % target_source_path)
+    source.write_to(target_source_path)
+
+def main():
+    usage = """%prog [options]
+Generate a single amalgated source and header file from the sources.
+"""
+    from optparse import OptionParser
+    parser = OptionParser(usage=usage)
+    parser.allow_interspersed_args = False
+    parser.add_option("-s", "--source", dest="target_source_path", action="store", default="dist/jsoncpp.cpp",
+        help="""Output .cpp source path. [Default: %default]""")
+    parser.add_option("-i", "--include", dest="header_include_path", action="store", default="json/json.h",
+        help="""Header include path. Used to include the header from the amalgated source file. [Default: %default]""")
+    parser.add_option("-t", "--top-dir", dest="top_dir", action="store", default=os.getcwd(),
+        help="""Source top-directory. [Default: %default]""")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+
+    msg = amalgamate_source(source_top_dir=options.top_dir,
+                             target_source_path=options.target_source_path,
+                             header_include_path=options.header_include_path)
+    if msg:
+        sys.stderr.write(msg + "\n")
+        sys.exit(1)
+    else:
+        print("Source succesfully amalagated")
+
+if __name__ == "__main__":
+    main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/appveyor.yml polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/appveyor.yml
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/appveyor.yml	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/appveyor.yml	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,35 @@
+# This is a comment.
+
+version: build.{build}
+
+os: Windows Server 2012 R2
+
+clone_folder: c:\projects\jsoncpp
+
+platform:
+    - Win32
+    - x64
+
+configuration:
+    - Debug
+    - Release
+
+# scripts to run before build
+before_build:
+    - echo "Running cmake..."
+    - cd c:\projects\jsoncpp
+    - cmake --version
+    - set PATH=C:\Program Files (x86)\MSBuild\14.0\Bin;%PATH%
+    - if %PLATFORM% == Win32 cmake .
+    - if %PLATFORM% == x64 cmake -G "Visual Studio 12 2013 Win64" .
+
+build:
+    project: jsoncpp.sln        # path to Visual Studio solution or project
+
+deploy:
+    provider: GitHub
+    auth_token:
+        secure: K2Tp1q8pIZ7rs0Ot24ZMWuwr12Ev6Tc6QkhMjGQxoQG3ng1pXtgPasiJ45IDXGdg
+    on:
+        branch: master
+        appveyor_repo_tag: true
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/AUTHORS polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/AUTHORS
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/AUTHORS	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/AUTHORS	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+Baptiste Lepilleur <blep@users.sourceforge.net>
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.clang-format polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.clang-format
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.clang-format	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.clang-format	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,47 @@
+---
+# BasedOnStyle:  LLVM
+AccessModifierOffset: -2
+ConstructorInitializerIndentWidth: 4
+AlignEscapedNewlinesLeft: false
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakTemplateDeclarations: false
+AlwaysBreakBeforeMultilineStrings: false
+BreakBeforeBinaryOperators: false
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BinPackParameters: false
+ColumnLimit:     80
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+DerivePointerBinding: false
+ExperimentalAutoDetectBinPacking: false
+IndentCaseLabels: false
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 60
+PenaltyBreakString: 1000
+PenaltyBreakFirstLessLess: 120
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 60
+PointerBindsToType: true
+SpacesBeforeTrailingComments: 1
+Cpp11BracedListStyle: false
+Standard:        Cpp03
+IndentWidth:     2
+TabWidth:        8
+UseTab:          Never
+BreakBeforeBraces: Attach
+IndentFunctionDeclarationAfterType: false
+SpacesInParentheses: false
+SpacesInAngles:  false
+SpaceInEmptyParentheses: false
+SpacesInCStyleCastParentheses: false
+SpaceAfterControlStatementKeyword: true
+SpaceBeforeAssignmentOperators: true
+ContinuationIndentWidth: 4
+...
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,160 @@
+# vim: et ts=4 sts=4 sw=4 tw=0
+
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8.5)
+PROJECT(jsoncpp)
+ENABLE_TESTING()
+
+OPTION(JSONCPP_WITH_TESTS "Compile and (for jsoncpp_check) run JsonCpp test executables" ON)
+OPTION(JSONCPP_WITH_POST_BUILD_UNITTEST "Automatically run unit-tests as a post build step" ON)
+OPTION(JSONCPP_WITH_WARNING_AS_ERROR "Force compilation to fail if a warning occurs" OFF)
+OPTION(JSONCPP_WITH_STRICT_ISO "Issue all the warnings demanded by strict ISO C and ISO C++" ON)
+OPTION(JSONCPP_WITH_PKGCONFIG_SUPPORT "Generate and install .pc files" ON)
+OPTION(JSONCPP_WITH_CMAKE_PACKAGE "Generate and install cmake package files" OFF)
+OPTION(BUILD_SHARED_LIBS "Build jsoncpp_lib as a shared library." OFF)
+OPTION(BUILD_STATIC_LIBS "Build jsoncpp_lib static library." ON)
+
+# Ensures that CMAKE_BUILD_TYPE is visible in cmake-gui on Unix
+IF(NOT WIN32)
+    IF(NOT CMAKE_BUILD_TYPE)
+        SET(CMAKE_BUILD_TYPE Release CACHE STRING
+            "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel Coverage."
+            FORCE)
+    ENDIF()
+ENDIF()
+
+# Enable runtime search path support for dynamic libraries on OSX
+IF(APPLE)
+    SET(CMAKE_MACOSX_RPATH 1)
+ENDIF()
+
+SET(DEBUG_LIBNAME_SUFFIX "" CACHE STRING "Optional suffix to append to the library name for a debug build")
+SET(LIB_SUFFIX "" CACHE STRING "Optional arch-dependent suffix for the library installation directory")
+
+SET(RUNTIME_INSTALL_DIR bin
+    CACHE PATH "Install dir for executables and dlls")
+SET(ARCHIVE_INSTALL_DIR lib${LIB_SUFFIX}
+    CACHE PATH "Install dir for static libraries")
+SET(LIBRARY_INSTALL_DIR lib${LIB_SUFFIX}
+    CACHE PATH "Install dir for shared libraries")
+SET(INCLUDE_INSTALL_DIR include
+    CACHE PATH "Install dir for headers")
+SET(PACKAGE_INSTALL_DIR lib${LIB_SUFFIX}/cmake
+    CACHE PATH "Install dir for cmake package config files")
+MARK_AS_ADVANCED( RUNTIME_INSTALL_DIR ARCHIVE_INSTALL_DIR INCLUDE_INSTALL_DIR PACKAGE_INSTALL_DIR )
+
+# Set variable named ${VAR_NAME} to value ${VALUE}
+FUNCTION(set_using_dynamic_name VAR_NAME VALUE)
+    SET( "${VAR_NAME}" "${VALUE}" PARENT_SCOPE)
+ENDFUNCTION()
+
+# Extract major, minor, patch from version text
+# Parse a version string "X.Y.Z" and outputs
+# version parts in ${OUPUT_PREFIX}_MAJOR, _MINOR, _PATCH.
+# If parse succeeds then ${OUPUT_PREFIX}_FOUND is TRUE.
+MACRO(jsoncpp_parse_version VERSION_TEXT OUPUT_PREFIX)
+    SET(VERSION_REGEX "[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9_]+)?")
+    IF( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
+        STRING(REGEX MATCHALL "[0-9]+|-([A-Za-z0-9_]+)" VERSION_PARTS ${VERSION_TEXT})
+        LIST(GET VERSION_PARTS 0 ${OUPUT_PREFIX}_MAJOR)
+        LIST(GET VERSION_PARTS 1 ${OUPUT_PREFIX}_MINOR)
+        LIST(GET VERSION_PARTS 2 ${OUPUT_PREFIX}_PATCH)
+        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" TRUE )
+    ELSE( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
+        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" FALSE )
+    ENDIF()
+ENDMACRO()
+
+# Read out version from "version" file
+#FILE(STRINGS "version" JSONCPP_VERSION)
+#SET( JSONCPP_VERSION_MAJOR X )
+#SET( JSONCPP_VERSION_MINOR Y )
+#SET( JSONCPP_VERSION_PATCH Z )
+SET( JSONCPP_VERSION 1.7.7 )
+jsoncpp_parse_version( ${JSONCPP_VERSION} JSONCPP_VERSION )
+#IF(NOT JSONCPP_VERSION_FOUND)
+#    MESSAGE(FATAL_ERROR "Failed to parse version string properly. Expect X.Y.Z")
+#ENDIF(NOT JSONCPP_VERSION_FOUND)
+SET( JSONCPP_SOVERSION 11 )
+SET( JSONCPP_USE_SECURE_MEMORY "0" CACHE STRING "-D...=1 to use memory-wiping allocator for STL" )
+
+MESSAGE(STATUS "JsonCpp Version: ${JSONCPP_VERSION_MAJOR}.${JSONCPP_VERSION_MINOR}.${JSONCPP_VERSION_PATCH}")
+# File version.h is only regenerated on CMake configure step
+CONFIGURE_FILE( "${PROJECT_SOURCE_DIR}/src/lib_json/version.h.in"
+                "${PROJECT_SOURCE_DIR}/include/json/version.h"
+                NEWLINE_STYLE UNIX )
+CONFIGURE_FILE( "${PROJECT_SOURCE_DIR}/version.in"
+                "${PROJECT_SOURCE_DIR}/version"
+                NEWLINE_STYLE UNIX )
+
+macro(UseCompilationWarningAsError)
+	if ( MSVC )
+        # Only enabled in debug because some old versions of VS STL generate
+        # warnings when compiled in release configuration.
+		set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /WX ")
+  elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror")
+    if (JSONCPP_WITH_STRICT_ISO)
+      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic-errors")
+    endif ()
+	endif()
+endmacro()
+
+# Include our configuration header
+INCLUDE_DIRECTORIES( ${jsoncpp_SOURCE_DIR}/include )
+
+if ( MSVC )
+    # Only enabled in debug because some old versions of VS STL generate
+    # unreachable code warning when compiled in release configuration.
+    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /W4 ")
+endif()
+
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  # using regular Clang or AppleClang
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wconversion -Wshadow -Werror=conversion -Werror=sign-compare")
+elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+  # using GCC
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wconversion -Wshadow -Wextra")
+  # not yet ready for -Wsign-conversion
+
+  if (JSONCPP_WITH_STRICT_ISO AND NOT JSONCPP_WITH_WARNING_AS_ERROR)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=conversion -pedantic")
+  endif ()
+elseif (CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
+  #Â using Intel compiler
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wconversion -Wshadow -Wextra -Werror=conversion")
+
+  if (JSONCPP_WITH_STRICT_ISO AND NOT JSONCPP_WITH_WARNING_AS_ERROR)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic")
+  endif ()
+endif()
+
+find_program(CCACHE_FOUND ccache)
+if(CCACHE_FOUND)
+    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
+    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
+endif(CCACHE_FOUND)
+
+IF(JSONCPP_WITH_WARNING_AS_ERROR)
+    UseCompilationWarningAsError()
+ENDIF()
+
+IF(JSONCPP_WITH_PKGCONFIG_SUPPORT)
+	CONFIGURE_FILE(
+		"pkg-config/jsoncpp.pc.in"
+		"pkg-config/jsoncpp.pc"
+		@ONLY)
+	INSTALL(FILES "${CMAKE_CURRENT_BINARY_DIR}/pkg-config/jsoncpp.pc"
+		DESTINATION "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/pkgconfig")
+ENDIF()
+
+IF(JSONCPP_WITH_CMAKE_PACKAGE)
+        INSTALL(EXPORT jsoncpp
+                DESTINATION ${PACKAGE_INSTALL_DIR}/jsoncpp
+                FILE        jsoncppConfig.cmake)
+ENDIF()
+
+# Build the different applications
+ADD_SUBDIRECTORY( src )
+
+#install the includes
+ADD_SUBDIRECTORY( include )
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/dev.makefile polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/dev.makefile
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/dev.makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/dev.makefile	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,35 @@
+# This is only for jsoncpp developers/contributors.
+# We use this to sign releases, generate documentation, etc.
+VER?=$(shell cat version)
+
+default:
+	@echo "VER=${VER}"
+sign: jsoncpp-${VER}.tar.gz
+	gpg --armor --detach-sign $<
+	gpg --verify $<.asc
+	# Then upload .asc to the release.
+jsoncpp-%.tar.gz:
+	curl https://github.com/open-source-parsers/jsoncpp/archive/$*.tar.gz -o $@
+dox:
+	python doxybuild.py --doxygen=$$(which doxygen) --in doc/web_doxyfile.in
+	rsync -va --delete dist/doxygen/jsoncpp-api-html-${VER}/ ../jsoncpp-docs/doxygen/
+	# Then 'git add -A' and 'git push' in jsoncpp-docs.
+build:
+	mkdir -p build/debug
+	cd build/debug; cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_SHARED_LIBS=ON -G "Unix Makefiles" ../..
+	make -C build/debug
+
+# Currently, this depends on include/json/version.h generated
+# by cmake.
+test-amalgamate:
+	python2.7 amalgamate.py
+	python3.4 amalgamate.py
+	cd dist; gcc -I. -c jsoncpp.cpp
+
+valgrind:
+	valgrind --error-exitcode=42 --leak-check=full ./build/debug/src/test_lib_json/jsoncpp_test
+
+clean:
+	\rm -rf *.gz *.asc dist/
+
+.PHONY: build
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmw7.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmw7.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmw7.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmw7.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,33 @@
+{
+    "cmake_variants" : [
+        {"name": "generator",
+         "generators": [
+            {"generator": [
+                "Visual Studio 7 .NET 2003",
+                "Visual Studio 9 2008",
+                "Visual Studio 9 2008 Win64",
+                "Visual Studio 10",
+                "Visual Studio 10 Win64",
+                "Visual Studio 11",
+                "Visual Studio 11 Win64"
+                ]
+            },
+            {"generator": ["MinGW Makefiles"],
+             "env_prepend": [{"path": "c:/wut/prg/MinGW/bin"}]
+            }
+         ]
+        },
+        {"name": "shared_dll",
+         "variables": [
+            ["BUILD_SHARED_LIBS=true"],
+            ["BUILD_SHARED_LIBS=false"]
+          ]
+        },
+        {"name": "build_type",
+         "build_types": [
+            "debug",
+            "release"
+            ]
+        }
+    ]
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmxp.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmxp.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmxp.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/agent_vmxp.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,26 @@
+{
+    "cmake_variants" : [
+        {"name": "generator",
+         "generators": [
+            {"generator": [
+                "Visual Studio 6",
+                "Visual Studio 7",
+                "Visual Studio 8 2005"
+                ]
+            }
+         ]
+        },
+        {"name": "shared_dll",
+         "variables": [
+            ["BUILD_SHARED_LIBS=true"],
+            ["BUILD_SHARED_LIBS=false"]
+          ]
+        },
+        {"name": "build_type",
+         "build_types": [
+            "debug",
+            "release"
+            ]
+        }
+    ]
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/antglob.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/antglob.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/antglob.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/antglob.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,205 @@
+#!/usr/bin/env python
+# encoding: utf-8
+# Copyright 2009 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from __future__ import print_function
+from dircache import listdir
+import re
+import fnmatch
+import os.path
+
+
+# These fnmatch expressions are used by default to prune the directory tree
+# while doing the recursive traversal in the glob_impl method of glob function.
+prune_dirs = '.git .bzr .hg .svn _MTN _darcs CVS SCCS '
+
+# These fnmatch expressions are used by default to exclude files and dirs
+# while doing the recursive traversal in the glob_impl method of glob function.
+##exclude_pats = prune_pats + '*~ #*# .#* %*% ._* .gitignore .cvsignore vssver.scc .DS_Store'.split()
+
+# These ant_glob expressions are used by default to exclude files and dirs and also prune the directory tree
+# while doing the recursive traversal in the glob_impl method of glob function.
+default_excludes = '''
+**/*~
+**/#*#
+**/.#*
+**/%*%
+**/._*
+**/CVS
+**/CVS/**
+**/.cvsignore
+**/SCCS
+**/SCCS/**
+**/vssver.scc
+**/.svn
+**/.svn/**
+**/.git
+**/.git/**
+**/.gitignore
+**/.bzr
+**/.bzr/**
+**/.hg
+**/.hg/**
+**/_MTN
+**/_MTN/**
+**/_darcs
+**/_darcs/**
+**/.DS_Store '''
+
+DIR = 1
+FILE = 2
+DIR_LINK = 4
+FILE_LINK = 8
+LINKS = DIR_LINK | FILE_LINK
+ALL_NO_LINK = DIR | FILE
+ALL = DIR | FILE | LINKS
+
+_ANT_RE = re.compile(r'(/\*\*/)|(\*\*/)|(/\*\*)|(\*)|(/)|([^\*/]*)')
+
+def ant_pattern_to_re(ant_pattern):
+    """Generates a regular expression from the ant pattern.
+    Matching convention:
+    **/a: match 'a', 'dir/a', 'dir1/dir2/a'
+    a/**/b: match 'a/b', 'a/c/b', 'a/d/c/b'
+    *.py: match 'script.py' but not 'a/script.py'
+    """
+    rex = ['^']
+    next_pos = 0
+    sep_rex = r'(?:/|%s)' % re.escape(os.path.sep)
+##    print 'Converting', ant_pattern
+    for match in _ANT_RE.finditer(ant_pattern):
+##        print 'Matched', match.group()
+##        print match.start(0), next_pos
+        if match.start(0) != next_pos:
+            raise ValueError("Invalid ant pattern")
+        if match.group(1): # /**/
+            rex.append(sep_rex + '(?:.*%s)?' % sep_rex)
+        elif match.group(2): # **/
+            rex.append('(?:.*%s)?' % sep_rex)
+        elif match.group(3): # /**
+            rex.append(sep_rex + '.*')
+        elif match.group(4): # *
+            rex.append('[^/%s]*' % re.escape(os.path.sep))
+        elif match.group(5): # /
+            rex.append(sep_rex)
+        else: # somepath
+            rex.append(re.escape(match.group(6)))
+        next_pos = match.end()
+    rex.append('$')
+    return re.compile(''.join(rex))
+
+def _as_list(l):
+    if isinstance(l, basestring):
+        return l.split()
+    return l
+
+def glob(dir_path,
+         includes = '**/*',
+         excludes = default_excludes,
+         entry_type = FILE,
+         prune_dirs = prune_dirs,
+         max_depth = 25):
+    include_filter = [ant_pattern_to_re(p) for p in _as_list(includes)]
+    exclude_filter = [ant_pattern_to_re(p) for p in _as_list(excludes)]
+    prune_dirs = [p.replace('/',os.path.sep) for p in _as_list(prune_dirs)]
+    dir_path = dir_path.replace('/',os.path.sep)
+    entry_type_filter = entry_type
+
+    def is_pruned_dir(dir_name):
+        for pattern in prune_dirs:
+            if fnmatch.fnmatch(dir_name, pattern):
+                return True
+        return False
+
+    def apply_filter(full_path, filter_rexs):
+        """Return True if at least one of the filter regular expression match full_path."""
+        for rex in filter_rexs:
+            if rex.match(full_path):
+                return True
+        return False
+
+    def glob_impl(root_dir_path):
+        child_dirs = [root_dir_path]
+        while child_dirs:
+            dir_path = child_dirs.pop()
+            for entry in listdir(dir_path):
+                full_path = os.path.join(dir_path, entry)
+##                print 'Testing:', full_path,
+                is_dir = os.path.isdir(full_path)
+                if is_dir and not is_pruned_dir(entry): # explore child directory ?
+##                    print '===> marked for recursion',
+                    child_dirs.append(full_path)
+                included = apply_filter(full_path, include_filter)
+                rejected = apply_filter(full_path, exclude_filter)
+                if not included or rejected: # do not include entry ?
+##                    print '=> not included or rejected'
+                    continue
+                link = os.path.islink(full_path)
+                is_file = os.path.isfile(full_path)
+                if not is_file and not is_dir:
+##                    print '=> unknown entry type'
+                    continue
+                if link:
+                    entry_type = is_file and FILE_LINK or DIR_LINK
+                else:
+                    entry_type = is_file and FILE or DIR
+##                print '=> type: %d' % entry_type, 
+                if (entry_type & entry_type_filter) != 0:
+##                    print ' => KEEP'
+                    yield os.path.join(dir_path, entry)
+##                else:
+##                    print ' => TYPE REJECTED'
+    return list(glob_impl(dir_path))
+
+
+if __name__ == "__main__":
+    import unittest
+
+    class AntPatternToRETest(unittest.TestCase):
+##        def test_conversion(self):
+##            self.assertEqual('^somepath$', ant_pattern_to_re('somepath').pattern)
+
+        def test_matching(self):
+            test_cases = [ ('path',
+                             ['path'],
+                             ['somepath', 'pathsuffix', '/path', '/path']),
+                           ('*.py',
+                             ['source.py', 'source.ext.py', '.py'],
+                             ['path/source.py', '/.py', 'dir.py/z', 'z.pyc', 'z.c']),
+                           ('**/path',
+                             ['path', '/path', '/a/path', 'c:/a/path', '/a/b/path', '//a/path', '/a/path/b/path'],
+                             ['path/', 'a/path/b', 'dir.py/z', 'somepath', 'pathsuffix', 'a/somepath']),
+                           ('path/**',
+                             ['path/a', 'path/path/a', 'path//'],
+                             ['path', 'somepath/a', 'a/path', 'a/path/a', 'pathsuffix/a']),
+                           ('/**/path',
+                             ['/path', '/a/path', '/a/b/path/path', '/path/path'],
+                             ['path', 'path/', 'a/path', '/pathsuffix', '/somepath']),
+                           ('a/b',
+                             ['a/b'],
+                             ['somea/b', 'a/bsuffix', 'a/b/c']),
+                           ('**/*.py',
+                             ['script.py', 'src/script.py', 'a/b/script.py', '/a/b/script.py'],
+                             ['script.pyc', 'script.pyo', 'a.py/b']),
+                           ('src/**/*.py',
+                             ['src/a.py', 'src/dir/a.py'],
+                             ['a/src/a.py', '/src/a.py']),
+                           ]
+            for ant_pattern, accepted_matches, rejected_matches in list(test_cases):
+                def local_path(paths):
+                    return [ p.replace('/',os.path.sep) for p in paths ]
+                test_cases.append((ant_pattern, local_path(accepted_matches), local_path(rejected_matches)))
+            for ant_pattern, accepted_matches, rejected_matches in test_cases:
+                rex = ant_pattern_to_re(ant_pattern)
+                print('ant_pattern:', ant_pattern, ' => ', rex.pattern)
+                for accepted_match in accepted_matches:
+                    print('Accepted?:', accepted_match)
+                    self.assertTrue(rex.match(accepted_match) is not None)
+                for rejected_match in rejected_matches:
+                    print('Rejected?:', rejected_match)
+                    self.assertTrue(rex.match(rejected_match) is None)
+
+    unittest.main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/batchbuild.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/batchbuild.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/batchbuild.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/batchbuild.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,278 @@
+from __future__ import print_function
+import collections
+import itertools
+import json
+import os
+import os.path
+import re
+import shutil
+import string
+import subprocess
+import sys
+import cgi
+
+class BuildDesc:
+    def __init__(self, prepend_envs=None, variables=None, build_type=None, generator=None):
+        self.prepend_envs = prepend_envs or [] # [ { "var": "value" } ]
+        self.variables = variables or []
+        self.build_type = build_type
+        self.generator = generator
+
+    def merged_with(self, build_desc):
+        """Returns a new BuildDesc by merging field content.
+           Prefer build_desc fields to self fields for single valued field.
+        """
+        return BuildDesc(self.prepend_envs + build_desc.prepend_envs,
+                          self.variables + build_desc.variables,
+                          build_desc.build_type or self.build_type,
+                          build_desc.generator or self.generator)
+
+    def env(self):
+        environ = os.environ.copy()
+        for values_by_name in self.prepend_envs:
+            for var, value in list(values_by_name.items()):
+                var = var.upper()
+                if type(value) is unicode:
+                    value = value.encode(sys.getdefaultencoding())
+                if var in environ:
+                    environ[var] = value + os.pathsep + environ[var]
+                else:
+                    environ[var] = value
+        return environ
+
+    def cmake_args(self):
+        args = ["-D%s" % var for var in self.variables]
+        # skip build type for Visual Studio solution as it cause warning
+        if self.build_type and 'Visual' not in self.generator:
+            args.append("-DCMAKE_BUILD_TYPE=%s" % self.build_type)
+        if self.generator:
+            args.extend(['-G', self.generator])
+        return args
+
+    def __repr__(self):
+        return "BuildDesc(%s, build_type=%s)" %  (" ".join(self.cmake_args()), self.build_type)
+
+class BuildData:
+    def __init__(self, desc, work_dir, source_dir):
+        self.desc = desc
+        self.work_dir = work_dir
+        self.source_dir = source_dir
+        self.cmake_log_path = os.path.join(work_dir, 'batchbuild_cmake.log')
+        self.build_log_path = os.path.join(work_dir, 'batchbuild_build.log')
+        self.cmake_succeeded = False
+        self.build_succeeded = False
+
+    def execute_build(self):
+        print('Build %s' % self.desc)
+        self._make_new_work_dir()
+        self.cmake_succeeded = self._generate_makefiles()
+        if self.cmake_succeeded:
+            self.build_succeeded = self._build_using_makefiles()
+        return self.build_succeeded
+
+    def _generate_makefiles(self):
+        print('  Generating makefiles: ', end=' ')
+        cmd = ['cmake'] + self.desc.cmake_args() + [os.path.abspath(self.source_dir)]
+        succeeded = self._execute_build_subprocess(cmd, self.desc.env(), self.cmake_log_path)
+        print('done' if succeeded else 'FAILED')
+        return succeeded
+
+    def _build_using_makefiles(self):
+        print('  Building:', end=' ')
+        cmd = ['cmake', '--build', self.work_dir]
+        if self.desc.build_type:
+            cmd += ['--config', self.desc.build_type]
+        succeeded = self._execute_build_subprocess(cmd, self.desc.env(), self.build_log_path)
+        print('done' if succeeded else 'FAILED')
+        return succeeded
+
+    def _execute_build_subprocess(self, cmd, env, log_path):
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=self.work_dir,
+                                    env=env)
+        stdout, _ = process.communicate()
+        succeeded = (process.returncode == 0)
+        with open(log_path, 'wb') as flog:
+            log = ' '.join(cmd) + '\n' + stdout + '\nExit code: %r\n' % process.returncode
+            flog.write(fix_eol(log))
+        return succeeded
+
+    def _make_new_work_dir(self):
+        if os.path.isdir(self.work_dir):
+            print('  Removing work directory', self.work_dir)
+            shutil.rmtree(self.work_dir, ignore_errors=True)
+        if not os.path.isdir(self.work_dir):
+            os.makedirs(self.work_dir)
+
+def fix_eol(stdout):
+    """Fixes wrong EOL produced by cmake --build on Windows (\r\r\n instead of \r\n).
+    """
+    return re.sub('\r*\n', os.linesep, stdout)
+
+def load_build_variants_from_config(config_path):
+    with open(config_path, 'rb') as fconfig:
+        data = json.load(fconfig)
+    variants = data[ 'cmake_variants' ]
+    build_descs_by_axis = collections.defaultdict(list)
+    for axis in variants:
+        axis_name = axis["name"]
+        build_descs = []
+        if "generators" in axis:
+            for generator_data in axis["generators"]:
+                for generator in generator_data["generator"]:
+                    build_desc = BuildDesc(generator=generator,
+                                            prepend_envs=generator_data.get("env_prepend"))
+                    build_descs.append(build_desc)
+        elif "variables" in axis:
+            for variables in axis["variables"]:
+                build_desc = BuildDesc(variables=variables)
+                build_descs.append(build_desc)
+        elif "build_types" in axis:
+            for build_type in axis["build_types"]:
+                build_desc = BuildDesc(build_type=build_type)
+                build_descs.append(build_desc)
+        build_descs_by_axis[axis_name].extend(build_descs)
+    return build_descs_by_axis
+
+def generate_build_variants(build_descs_by_axis):
+    """Returns a list of BuildDesc generated for the partial BuildDesc for each axis."""
+    axis_names = list(build_descs_by_axis.keys())
+    build_descs = []
+    for axis_name, axis_build_descs in list(build_descs_by_axis.items()):
+        if len(build_descs):
+            # for each existing build_desc and each axis build desc, create a new build_desc
+            new_build_descs = []
+            for prototype_build_desc, axis_build_desc in itertools.product(build_descs, axis_build_descs):
+                new_build_descs.append(prototype_build_desc.merged_with(axis_build_desc))
+            build_descs = new_build_descs
+        else:
+            build_descs = axis_build_descs
+    return build_descs
+
+HTML_TEMPLATE = string.Template('''<html>
+<head>
+    <title>$title</title>
+    <style type="text/css">
+    td.failed {background-color:#f08080;}
+    td.ok {background-color:#c0eec0;}
+    </style>
+</head>
+<body>
+<table border="1">
+<thead>
+    <tr>
+        <th>Variables</th>
+        $th_vars
+    </tr>
+    <tr>
+        <th>Build type</th>
+        $th_build_types
+    </tr>
+</thead>
+<tbody>
+$tr_builds
+</tbody>
+</table>
+</body></html>''')
+
+def generate_html_report(html_report_path, builds):
+    report_dir = os.path.dirname(html_report_path)
+    # Vertical axis: generator
+    # Horizontal: variables, then build_type
+    builds_by_generator = collections.defaultdict(list)
+    variables = set()
+    build_types_by_variable = collections.defaultdict(set)
+    build_by_pos_key = {} # { (generator, var_key, build_type): build }
+    for build in builds:
+        builds_by_generator[build.desc.generator].append(build)
+        var_key = tuple(sorted(build.desc.variables))
+        variables.add(var_key)
+        build_types_by_variable[var_key].add(build.desc.build_type)
+        pos_key = (build.desc.generator, var_key, build.desc.build_type)
+        build_by_pos_key[pos_key] = build
+    variables = sorted(variables)
+    th_vars = []
+    th_build_types = []
+    for variable in variables:
+        build_types = sorted(build_types_by_variable[variable])
+        nb_build_type = len(build_types_by_variable[variable])
+        th_vars.append('<th colspan="%d">%s</th>' % (nb_build_type, cgi.escape(' '.join(variable))))
+        for build_type in build_types:
+            th_build_types.append('<th>%s</th>' % cgi.escape(build_type))
+    tr_builds = []
+    for generator in sorted(builds_by_generator):
+        tds = [ '<td>%s</td>\n' % cgi.escape(generator) ]
+        for variable in variables:
+            build_types = sorted(build_types_by_variable[variable])
+            for build_type in build_types:
+                pos_key = (generator, variable, build_type)
+                build = build_by_pos_key.get(pos_key)
+                if build:
+                    cmake_status = 'ok' if build.cmake_succeeded else 'FAILED'
+                    build_status = 'ok' if build.build_succeeded else 'FAILED'
+                    cmake_log_url = os.path.relpath(build.cmake_log_path, report_dir)
+                    build_log_url = os.path.relpath(build.build_log_path, report_dir)
+                    td = '<td class="%s"><a href="%s" class="%s">CMake: %s</a>' % (                        build_status.lower(), cmake_log_url, cmake_status.lower(), cmake_status)
+                    if build.cmake_succeeded:
+                        td += '<br><a href="%s" class="%s">Build: %s</a>' % (                            build_log_url, build_status.lower(), build_status)
+                    td += '</td>'
+                else:
+                    td = '<td></td>'
+                tds.append(td)
+        tr_builds.append('<tr>%s</tr>' % '\n'.join(tds))
+    html = HTML_TEMPLATE.substitute(        title='Batch build report',
+        th_vars=' '.join(th_vars),
+        th_build_types=' '.join(th_build_types),
+        tr_builds='\n'.join(tr_builds))
+    with open(html_report_path, 'wt') as fhtml:
+        fhtml.write(html)
+    print('HTML report generated in:', html_report_path)
+
+def main():
+    usage = r"""%prog WORK_DIR SOURCE_DIR CONFIG_JSON_PATH [CONFIG2_JSON_PATH...]
+Build a given CMake based project located in SOURCE_DIR with multiple generators/options.dry_run
+as described in CONFIG_JSON_PATH building in WORK_DIR.
+
+Example of call:
+python devtools\batchbuild.py e:\buildbots\jsoncpp\build . devtools\agent_vmw7.json
+"""
+    from optparse import OptionParser
+    parser = OptionParser(usage=usage)
+    parser.allow_interspersed_args = True
+#    parser.add_option('-v', '--verbose', dest="verbose", action='store_true',
+#        help="""Be verbose.""")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+    if len(args) < 3:
+        parser.error("Missing one of WORK_DIR SOURCE_DIR CONFIG_JSON_PATH.")
+    work_dir = args[0]
+    source_dir = args[1].rstrip('/\\')
+    config_paths = args[2:]
+    for config_path in config_paths:
+        if not os.path.isfile(config_path):
+            parser.error("Can not read: %r" % config_path)
+
+    # generate build variants
+    build_descs = []
+    for config_path in config_paths:
+        build_descs_by_axis = load_build_variants_from_config(config_path)
+        build_descs.extend(generate_build_variants(build_descs_by_axis))
+    print('Build variants (%d):' % len(build_descs))
+    # assign build directory for each variant
+    if not os.path.isdir(work_dir):
+        os.makedirs(work_dir)
+    builds = []
+    with open(os.path.join(work_dir, 'matrix-dir-map.txt'), 'wt') as fmatrixmap:
+        for index, build_desc in enumerate(build_descs):
+            build_desc_work_dir = os.path.join(work_dir, '%03d' % (index+1))
+            builds.append(BuildData(build_desc, build_desc_work_dir, source_dir))
+            fmatrixmap.write('%s: %s\n' % (build_desc_work_dir, build_desc))
+    for build in builds:
+        build.execute_build()
+    html_report_path = os.path.join(work_dir, 'batchbuild-report.html')
+    generate_html_report(html_report_path, builds)
+    print('Done')
+
+
+if __name__ == '__main__':
+    main()
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/fixeol.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/fixeol.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/fixeol.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/fixeol.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,70 @@
+# Copyright 2010 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from __future__ import print_function
+import os.path
+import sys
+
+def fix_source_eol(path, is_dry_run = True, verbose = True, eol = '\n'):
+    """Makes sure that all sources have the specified eol sequence (default: unix)."""
+    if not os.path.isfile(path):
+        raise ValueError('Path "%s" is not a file' % path)
+    try:
+        f = open(path, 'rb')
+    except IOError as msg:
+        print("%s: I/O Error: %s" % (file, str(msg)), file=sys.stderr)
+        return False
+    try:
+        raw_lines = f.readlines()
+    finally:
+        f.close()
+    fixed_lines = [line.rstrip('\r\n') + eol for line in raw_lines]
+    if raw_lines != fixed_lines:
+        print('%s =>' % path, end=' ')
+        if not is_dry_run:
+            f = open(path, "wb")
+            try:
+                f.writelines(fixed_lines)
+            finally:
+                f.close()
+        if verbose:
+            print(is_dry_run and ' NEED FIX' or ' FIXED')
+    return True
+##    
+##    
+##
+##def _do_fix(is_dry_run = True):
+##    from waftools import antglob
+##    python_sources = antglob.glob('.',
+##        includes = '**/*.py **/wscript **/wscript_build',
+##        excludes = antglob.default_excludes + './waf.py',
+##        prune_dirs = antglob.prune_dirs + 'waf-* ./build')
+##    for path in python_sources:
+##        _fix_python_source(path, is_dry_run)
+##
+##    cpp_sources = antglob.glob('.',
+##        includes = '**/*.cpp **/*.h **/*.inl',
+##        prune_dirs = antglob.prune_dirs + 'waf-* ./build')
+##    for path in cpp_sources:
+##        _fix_source_eol(path, is_dry_run)
+##
+##
+##def dry_fix(context):
+##    _do_fix(is_dry_run = True)
+##
+##def fix(context):
+##    _do_fix(is_dry_run = False)
+##
+##def shutdown():
+##    pass
+##
+##def check(context):
+##    # Unit tests are run when "check" target is used
+##    ut = UnitTest.unit_test()
+##    ut.change_to_testfile_dir = True
+##    ut.want_to_see_test_output = True
+##    ut.want_to_see_test_error = True
+##    ut.run()
+##    ut.print_results()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/__init__.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/__init__.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/__init__.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/__init__.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,6 @@
+# Copyright 2010 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+# module
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/licenseupdater.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/licenseupdater.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/licenseupdater.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/licenseupdater.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,94 @@
+"""Updates the license text in source file.
+"""
+from __future__ import print_function
+
+# An existing license is found if the file starts with the string below,
+# and ends with the first blank line.
+LICENSE_BEGIN = "// Copyright "
+
+BRIEF_LICENSE = LICENSE_BEGIN + """2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+""".replace('\r\n','\n')
+
+def update_license(path, dry_run, show_diff):
+    """Update the license statement in the specified file.
+    Parameters:
+      path: path of the C++ source file to update.
+      dry_run: if True, just print the path of the file that would be updated,
+               but don't change it.
+      show_diff: if True, print the path of the file that would be modified,
+                 as well as the change made to the file. 
+    """
+    with open(path, 'rt') as fin:
+        original_text = fin.read().replace('\r\n','\n')
+        newline = fin.newlines and fin.newlines[0] or '\n'
+    if not original_text.startswith(LICENSE_BEGIN):
+        # No existing license found => prepend it
+        new_text = BRIEF_LICENSE + original_text
+    else:
+        license_end_index = original_text.index('\n\n') # search first blank line
+        new_text = BRIEF_LICENSE + original_text[license_end_index+2:]
+    if original_text != new_text:
+        if not dry_run:
+            with open(path, 'wb') as fout:
+                fout.write(new_text.replace('\n', newline))
+        print('Updated', path)
+        if show_diff:
+            import difflib
+            print('\n'.join(difflib.unified_diff(original_text.split('\n'),
+                                                   new_text.split('\n'))))
+        return True
+    return False
+
+def update_license_in_source_directories(source_dirs, dry_run, show_diff):
+    """Updates license text in C++ source files found in directory source_dirs.
+    Parameters:
+      source_dirs: list of directory to scan for C++ sources. Directories are
+                   scanned recursively.
+      dry_run: if True, just print the path of the file that would be updated,
+               but don't change it.
+      show_diff: if True, print the path of the file that would be modified,
+                 as well as the change made to the file. 
+    """
+    from devtools import antglob
+    prune_dirs = antglob.prune_dirs + 'scons-local* ./build* ./libs ./dist'
+    for source_dir in source_dirs:
+        cpp_sources = antglob.glob(source_dir,
+            includes = '''**/*.h **/*.cpp **/*.inl''',
+            prune_dirs = prune_dirs)
+        for source in cpp_sources:
+            update_license(source, dry_run, show_diff)
+
+def main():
+    usage = """%prog DIR [DIR2...]
+Updates license text in sources of the project in source files found
+in the directory specified on the command-line.
+
+Example of call:
+python devtools\licenseupdater.py include src -n --diff
+=> Show change that would be made to the sources.
+
+python devtools\licenseupdater.py include src
+=> Update license statement on all sources in directories include/ and src/.
+"""
+    from optparse import OptionParser
+    parser = OptionParser(usage=usage)
+    parser.allow_interspersed_args = False
+    parser.add_option('-n', '--dry-run', dest="dry_run", action='store_true', default=False,
+        help="""Only show what files are updated, do not update the files""")
+    parser.add_option('--diff', dest="show_diff", action='store_true', default=False,
+        help="""On update, show change made to the file.""")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+    update_license_in_source_directories(args, options.dry_run, options.show_diff)
+    print('Done')
+
+if __name__ == '__main__':
+    import sys
+    import os.path
+    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+    main()
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/tarball.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/tarball.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/tarball.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/devtools/tarball.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,52 @@
+# Copyright 2010 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from contextlib import closing
+import os
+import tarfile
+
+TARGZ_DEFAULT_COMPRESSION_LEVEL = 9
+
+def make_tarball(tarball_path, sources, base_dir, prefix_dir=''):
+    """Parameters:
+    tarball_path: output path of the .tar.gz file
+    sources: list of sources to include in the tarball, relative to the current directory
+    base_dir: if a source file is in a sub-directory of base_dir, then base_dir is stripped
+        from path in the tarball.
+    prefix_dir: all files stored in the tarball be sub-directory of prefix_dir. Set to ''
+        to make them child of root.
+    """
+    base_dir = os.path.normpath(os.path.abspath(base_dir))
+    def archive_name(path):
+        """Makes path relative to base_dir."""
+        path = os.path.normpath(os.path.abspath(path))
+        common_path = os.path.commonprefix((base_dir, path))
+        archive_name = path[len(common_path):]
+        if os.path.isabs(archive_name):
+            archive_name = archive_name[1:]
+        return os.path.join(prefix_dir, archive_name)
+    def visit(tar, dirname, names):
+        for name in names:
+            path = os.path.join(dirname, name)
+            if os.path.isfile(path):
+                path_in_tar = archive_name(path)
+                tar.add(path, path_in_tar)
+    compression = TARGZ_DEFAULT_COMPRESSION_LEVEL
+    with closing(tarfile.TarFile.open(tarball_path, 'w:gz',
+            compresslevel=compression)) as tar:
+        for source in sources:
+            source_path = source
+            if os.path.isdir(source):
+                for dirpath, dirnames, filenames in os.walk(source_path):
+                    visit(tar, dirpath, filenames)
+            else:
+                path_in_tar = archive_name(source_path)
+                tar.add(source_path, path_in_tar)      # filename, arcname
+
+def decompress(tarball_path, base_dir):
+    """Decompress the gzipped tarball into directory base_dir.
+    """
+    with closing(tarfile.TarFile.open(tarball_path)) as tar:
+        tar.extractall(base_dir)
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/doxybuild.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/doxybuild.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/doxybuild.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/doxybuild.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,189 @@
+"""Script to generate doxygen documentation.
+"""
+from __future__ import print_function
+from __future__ import unicode_literals
+from devtools import tarball
+from contextlib import contextmanager
+import subprocess
+import traceback
+import re
+import os
+import sys
+import shutil
+
+@contextmanager
+def cd(newdir):
+    """
+    http://stackoverflow.com/questions/431684/how-do-i-cd-in-python
+    """
+    prevdir = os.getcwd()
+    os.chdir(newdir)
+    try:
+        yield
+    finally:
+        os.chdir(prevdir)
+
+def find_program(*filenames):
+    """find a program in folders path_lst, and sets env[var]
+    @param filenames: a list of possible names of the program to search for
+    @return: the full path of the filename if found, or '' if filename could not be found
+"""
+    paths = os.environ.get('PATH', '').split(os.pathsep)
+    suffixes = ('win32' in sys.platform) and '.exe .com .bat .cmd' or ''
+    for filename in filenames:
+        for name in [filename+ext for ext in suffixes.split(' ')]:
+            for directory in paths:
+                full_path = os.path.join(directory, name)
+                if os.path.isfile(full_path):
+                    return full_path
+    return ''
+
+def do_subst_in_file(targetfile, sourcefile, dict):
+    """Replace all instances of the keys of dict with their values.
+    For example, if dict is {'%VERSION%': '1.2345', '%BASE%': 'MyProg'},
+    then all instances of %VERSION% in the file will be replaced with 1.2345 etc.
+    """
+    with open(sourcefile, 'r') as f:
+        contents = f.read()
+    for (k,v) in list(dict.items()):
+        v = v.replace('\\','\\\\') 
+        contents = re.sub(k, v, contents)
+    with open(targetfile, 'w') as f:
+        f.write(contents)
+
+def getstatusoutput(cmd):
+    """cmd is a list.
+    """
+    try:
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+        output, _ = process.communicate()
+        status = process.returncode
+    except:
+        status = -1
+        output = traceback.format_exc()
+    return status, output
+
+def run_cmd(cmd, silent=False):
+    """Raise exception on failure.
+    """
+    info = 'Running: %r in %r' %(' '.join(cmd), os.getcwd())
+    print(info)
+    sys.stdout.flush()
+    if silent:
+        status, output = getstatusoutput(cmd)
+    else:
+        status, output = subprocess.call(cmd), ''
+    if status:
+        msg = 'Error while %s ...\n\terror=%d, output="""%s"""' %(info, status, output)
+        raise Exception(msg)
+
+def assert_is_exe(path):
+    if not path:
+        raise Exception('path is empty.')
+    if not os.path.isfile(path):
+        raise Exception('%r is not a file.' %path)
+    if not os.access(path, os.X_OK):
+        raise Exception('%r is not executable by this user.' %path)
+
+def run_doxygen(doxygen_path, config_file, working_dir, is_silent):
+    assert_is_exe(doxygen_path)
+    config_file = os.path.abspath(config_file)
+    with cd(working_dir):
+        cmd = [doxygen_path, config_file]
+        run_cmd(cmd, is_silent)
+
+def build_doc(options,  make_release=False):
+    if make_release:
+        options.make_tarball = True
+        options.with_dot = True
+        options.with_html_help = True
+        options.with_uml_look = True
+        options.open = False
+        options.silent = True
+
+    version = open('version', 'rt').read().strip()
+    output_dir = 'dist/doxygen' # relative to doc/doxyfile location.
+    if not os.path.isdir(output_dir):
+        os.makedirs(output_dir)
+    top_dir = os.path.abspath('.')
+    html_output_dirname = 'jsoncpp-api-html-' + version
+    tarball_path = os.path.join('dist', html_output_dirname + '.tar.gz')
+    warning_log_path = os.path.join(output_dir, '../jsoncpp-doxygen-warning.log')
+    html_output_path = os.path.join(output_dir, html_output_dirname)
+    def yesno(bool):
+        return bool and 'YES' or 'NO'
+    subst_keys = {
+        '%JSONCPP_VERSION%': version,
+        '%DOC_TOPDIR%': '',
+        '%TOPDIR%': top_dir,
+        '%HTML_OUTPUT%': os.path.join('..', output_dir, html_output_dirname),
+        '%HAVE_DOT%': yesno(options.with_dot),
+        '%DOT_PATH%': os.path.split(options.dot_path)[0],
+        '%HTML_HELP%': yesno(options.with_html_help),
+        '%UML_LOOK%': yesno(options.with_uml_look),
+        '%WARNING_LOG_PATH%': os.path.join('..', warning_log_path)
+        }
+
+    if os.path.isdir(output_dir):
+        print('Deleting directory:', output_dir)
+        shutil.rmtree(output_dir)
+    if not os.path.isdir(output_dir):
+        os.makedirs(output_dir)
+
+    do_subst_in_file('doc/doxyfile', options.doxyfile_input_path, subst_keys)
+    run_doxygen(options.doxygen_path, 'doc/doxyfile', 'doc', is_silent=options.silent)
+    if not options.silent:
+        print(open(warning_log_path, 'r').read())
+    index_path = os.path.abspath(os.path.join('doc', subst_keys['%HTML_OUTPUT%'], 'index.html'))
+    print('Generated documentation can be found in:')
+    print(index_path)
+    if options.open:
+        import webbrowser
+        webbrowser.open('file://' + index_path)
+    if options.make_tarball:
+        print('Generating doc tarball to', tarball_path)
+        tarball_sources = [
+            output_dir,
+            'README.md',
+            'LICENSE',
+            'NEWS.txt',
+            'version'
+            ]
+        tarball_basedir = os.path.join(output_dir, html_output_dirname)
+        tarball.make_tarball(tarball_path, tarball_sources, tarball_basedir, html_output_dirname)
+    return tarball_path, html_output_dirname
+
+def main():
+    usage = """%prog
+    Generates doxygen documentation in build/doxygen.
+    Optionaly makes a tarball of the documentation to dist/.
+
+    Must be started in the project top directory.    
+    """
+    from optparse import OptionParser
+    parser = OptionParser(usage=usage)
+    parser.allow_interspersed_args = False
+    parser.add_option('--with-dot', dest="with_dot", action='store_true', default=False,
+        help="""Enable usage of DOT to generate collaboration diagram""")
+    parser.add_option('--dot', dest="dot_path", action='store', default=find_program('dot'),
+        help="""Path to GraphViz dot tool. Must be full qualified path. [Default: %default]""")
+    parser.add_option('--doxygen', dest="doxygen_path", action='store', default=find_program('doxygen'),
+        help="""Path to Doxygen tool. [Default: %default]""")
+    parser.add_option('--in', dest="doxyfile_input_path", action='store', default='doc/doxyfile.in',
+        help="""Path to doxygen inputs. [Default: %default]""")
+    parser.add_option('--with-html-help', dest="with_html_help", action='store_true', default=False,
+        help="""Enable generation of Microsoft HTML HELP""")
+    parser.add_option('--no-uml-look', dest="with_uml_look", action='store_false', default=True,
+        help="""Generates DOT graph without UML look [Default: False]""")
+    parser.add_option('--open', dest="open", action='store_true', default=False,
+        help="""Open the HTML index in the web browser after generation""")
+    parser.add_option('--tarball', dest="make_tarball", action='store_true', default=False,
+        help="""Generates a tarball of the documentation in dist/ directory""")
+    parser.add_option('-s', '--silent', dest="silent", action='store_true', default=False,
+        help="""Hides doxygen output""")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+    build_doc(options)
+
+if __name__ == '__main__':
+    main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitattributes polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitattributes
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitattributes	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitattributes	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,11 @@
+*           text=auto
+*.h         text
+*.cpp       text
+*.json      text
+*.in        text
+*.sh        eol=lf
+*.bat       eol=crlf
+*.vcproj    eol=crlf
+*.vcxproj   eol=crlf
+*.sln       eol=crlf
+devtools/agent_vm* eol=crlf
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitignore polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitignore
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.gitignore	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,52 @@
+/build/
+*.pyc
+*.swp
+*.actual
+*.actual-rewrite
+*.process-output
+*.rewrite
+/bin/
+/buildscons/
+/libs/
+/doc/doxyfile
+/dist/
+#/version
+#/include/json/version.h
+
+# MSVC project files:
+*.sln
+*.vcxproj
+*.filters
+*.user
+*.sdf
+*.opensdf
+*.suo
+
+# MSVC build files:
+*.lib
+*.obj
+*.tlog/
+*.pdb
+
+# CMake-generated files:
+CMakeFiles/
+CTestTestFile.cmake
+cmake_install.cmake
+pkg-config/jsoncpp.pc
+jsoncpp_lib_static.dir/
+
+# In case someone runs cmake in the root-dir:
+/CMakeCache.txt
+/Makefile
+/include/Makefile
+/src/Makefile
+/src/jsontestrunner/Makefile
+/src/jsontestrunner/jsontestrunner_exe
+/src/lib_json/Makefile
+/src/test_lib_json/Makefile
+/src/test_lib_json/jsoncpp_test
+
+# eclipse project files
+.project
+.cproject
+/.settings/
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+FILE(GLOB INCLUDE_FILES "json/*.h")
+INSTALL(FILES ${INCLUDE_FILES} DESTINATION ${INCLUDE_INSTALL_DIR}/json)
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/allocator.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/allocator.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/allocator.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/allocator.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,94 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef CPPTL_JSON_ALLOCATOR_H_INCLUDED
+#define CPPTL_JSON_ALLOCATOR_H_INCLUDED
+
+#include <cstring>
+#include <memory>
+
+namespace Json {
+template<typename T>
+class SecureAllocator {
+	public:
+		// Type definitions
+		using value_type      = T;
+		using pointer         = T*;
+		using const_pointer   = const T*;
+		using reference       = T&;
+		using const_reference = const T&;
+		using size_type       = std::size_t;
+		using difference_type = std::ptrdiff_t;
+
+		/**
+		 * Allocate memory for N items using the standard allocator.
+		 */
+		pointer allocate(size_type n) {
+			// allocate using "global operator new"
+			return static_cast<pointer>(::operator new(n * sizeof(T)));
+		}
+
+		/**
+		 * Release memory which was allocated for N items at pointer P.
+		 *
+		 * The memory block is filled with zeroes before being released.
+		 * The pointer argument is tagged as "volatile" to prevent the
+		 * compiler optimizing out this critical step.
+		 */
+		void deallocate(volatile pointer p, size_type n) {
+			std::memset(p, 0, n * sizeof(T));
+			// free using "global operator delete"
+			::operator delete(p);
+		}
+
+		/**
+		 * Construct an item in-place at pointer P.
+		 */
+		template<typename... Args>
+		void construct(pointer p, Args&&... args) {
+			// construct using "placement new" and "perfect forwarding"
+			::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);
+		}
+
+		size_type max_size() const {
+			return size_t(-1) / sizeof(T);
+		}
+
+		pointer address( reference x ) const {
+			return std::addressof(x);
+		}
+
+		const_pointer address( const_reference x ) const {
+			return std::addressof(x);
+		}
+
+		/**
+		 * Destroy an item in-place at pointer P.
+		 */
+		void destroy(pointer p) {
+			// destroy using "explicit destructor"
+			p->~T();
+		}
+
+		// Boilerplate
+		SecureAllocator() {}
+		template<typename U> SecureAllocator(const SecureAllocator<U>&) {}
+		template<typename U> struct rebind { using other = SecureAllocator<U>; };
+};
+
+
+template<typename T, typename U>
+bool operator==(const SecureAllocator<T>&, const SecureAllocator<U>&) {
+	return true;
+}
+
+template<typename T, typename U>
+bool operator!=(const SecureAllocator<T>&, const SecureAllocator<U>&) {
+	return false;
+}
+
+} //namespace Json
+
+#endif // CPPTL_JSON_ALLOCATOR_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/assertions.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/assertions.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/assertions.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/assertions.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,54 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef CPPTL_JSON_ASSERTIONS_H_INCLUDED
+#define CPPTL_JSON_ASSERTIONS_H_INCLUDED
+
+#include <stdlib.h>
+#include <sstream>
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "config.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+
+/** It should not be possible for a maliciously designed file to
+ *  cause an abort() or seg-fault, so these macros are used only
+ *  for pre-condition violations and internal logic errors.
+ */
+#if JSON_USE_EXCEPTION
+
+// @todo <= add detail about condition in exception
+# define JSON_ASSERT(condition)                                                \
+  {if (!(condition)) {Json::throwLogicError( "assert json failed" );}}
+
+# define JSON_FAIL_MESSAGE(message)                                            \
+  {                                                                            \
+    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
+    Json::throwLogicError(oss.str());                                          \
+    abort();                                                                   \
+  }
+
+#else // JSON_USE_EXCEPTION
+
+# define JSON_ASSERT(condition) assert(condition)
+
+// The call to assert() will show the failure message in debug builds. In
+// release builds we abort, for a core-dump or debugger.
+# define JSON_FAIL_MESSAGE(message)                                            \
+  {                                                                            \
+    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
+    assert(false && oss.str().c_str());                                        \
+    abort();                                                                   \
+  }
+
+
+#endif
+
+#define JSON_ASSERT_MESSAGE(condition, message)                                \
+  if (!(condition)) {                                                          \
+    JSON_FAIL_MESSAGE(message);                                                \
+  }
+
+#endif // CPPTL_JSON_ASSERTIONS_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/autolink.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/autolink.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/autolink.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/autolink.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,25 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSON_AUTOLINK_H_INCLUDED
+#define JSON_AUTOLINK_H_INCLUDED
+
+#include "config.h"
+
+#ifdef JSON_IN_CPPTL
+#include <cpptl/cpptl_autolink.h>
+#endif
+
+#if !defined(JSON_NO_AUTOLINK) && !defined(JSON_DLL_BUILD) &&                  \
+    !defined(JSON_IN_CPPTL)
+#define CPPTL_AUTOLINK_NAME "json"
+#undef CPPTL_AUTOLINK_DLL
+#ifdef JSON_DLL
+#define CPPTL_AUTOLINK_DLL
+#endif
+#include "autolink.h"
+#endif
+
+#endif // JSON_AUTOLINK_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/config.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/config.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/config.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/config.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,178 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSON_CONFIG_H_INCLUDED
+#define JSON_CONFIG_H_INCLUDED
+#include <stddef.h>
+#include <string> //typedef String
+#include <stdint.h> //typedef int64_t, uint64_t
+
+/// If defined, indicates that json library is embedded in CppTL library.
+//# define JSON_IN_CPPTL 1
+
+/// If defined, indicates that json may leverage CppTL library
+//#  define JSON_USE_CPPTL 1
+/// If defined, indicates that cpptl vector based map should be used instead of
+/// std::map
+/// as Value container.
+//#  define JSON_USE_CPPTL_SMALLMAP 1
+
+// If non-zero, the library uses exceptions to report bad input instead of C
+// assertion macros. The default is to use exceptions.
+#ifndef JSON_USE_EXCEPTION
+#define JSON_USE_EXCEPTION 1
+#endif
+
+/// If defined, indicates that the source file is amalgated
+/// to prevent private header inclusion.
+/// Remarks: it is automatically defined in the generated amalgated header.
+// #define JSON_IS_AMALGAMATION
+
+#ifdef JSON_IN_CPPTL
+#include <cpptl/config.h>
+#ifndef JSON_USE_CPPTL
+#define JSON_USE_CPPTL 1
+#endif
+#endif
+
+#ifdef JSON_IN_CPPTL
+#define JSON_API CPPTL_API
+#elif defined(JSON_DLL_BUILD)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+#define JSON_API __declspec(dllexport)
+#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
+#endif // if defined(_MSC_VER)
+#elif defined(JSON_DLL)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+#define JSON_API __declspec(dllimport)
+#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
+#endif // if defined(_MSC_VER)
+#endif // ifdef JSON_IN_CPPTL
+#if !defined(JSON_API)
+#define JSON_API
+#endif
+
+// If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
+// integer
+// Storages, and 64 bits integer support is disabled.
+// #define JSON_NO_INT64 1
+
+#if defined(_MSC_VER) // MSVC
+#  if _MSC_VER <= 1200 // MSVC 6
+    // Microsoft Visual Studio 6 only support conversion from __int64 to double
+    // (no conversion from unsigned __int64).
+#    define JSON_USE_INT64_DOUBLE_CONVERSION 1
+    // Disable warning 4786 for VS6 caused by STL (identifier was truncated to '255'
+    // characters in the debug information)
+    // All projects I've ever seen with VS6 were using this globally (not bothering
+    // with pragma push/pop).
+#    pragma warning(disable : 4786)
+#  endif // MSVC 6
+
+#  if _MSC_VER >= 1500 // MSVC 2008
+    /// Indicates that the following function is deprecated.
+#    define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
+#  endif
+
+#endif // defined(_MSC_VER)
+
+// In c++11 the override keyword allows you to explicity define that a function
+// is intended to override the base-class version.  This makes the code more
+// managable and fixes a set of common hard-to-find bugs.
+#if __cplusplus >= 201103L
+# define JSONCPP_OVERRIDE override
+#elif defined(_MSC_VER) && _MSC_VER > 1600
+# define JSONCPP_OVERRIDE override
+#else
+# define JSONCPP_OVERRIDE
+#endif
+
+#ifndef JSON_HAS_RVALUE_REFERENCES
+
+#if defined(_MSC_VER) && _MSC_VER >= 1600 // MSVC >= 2010
+#define JSON_HAS_RVALUE_REFERENCES 1
+#endif // MSVC >= 2010
+
+#ifdef __clang__
+#if __has_feature(cxx_rvalue_references)
+#define JSON_HAS_RVALUE_REFERENCES 1
+#endif  // has_feature
+
+#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
+#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)
+#define JSON_HAS_RVALUE_REFERENCES 1
+#endif  // GXX_EXPERIMENTAL
+
+#endif // __clang__ || __GNUC__
+
+#endif // not defined JSON_HAS_RVALUE_REFERENCES
+
+#ifndef JSON_HAS_RVALUE_REFERENCES
+#define JSON_HAS_RVALUE_REFERENCES 0
+#endif
+
+#ifdef __clang__
+#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
+#  if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
+#    define JSONCPP_DEPRECATED(message)  __attribute__ ((deprecated(message)))
+#  elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
+#    define JSONCPP_DEPRECATED(message)  __attribute__((__deprecated__))
+#  endif  // GNUC version
+#endif // __clang__ || __GNUC__
+
+#if !defined(JSONCPP_DEPRECATED)
+#define JSONCPP_DEPRECATED(message)
+#endif // if !defined(JSONCPP_DEPRECATED)
+
+#if __GNUC__ >= 6
+#  define JSON_USE_INT64_DOUBLE_CONVERSION 1
+#endif
+
+#if !defined(JSON_IS_AMALGAMATION)
+
+# include "version.h"
+
+# if JSONCPP_USING_SECURE_MEMORY
+#  include "allocator.h" //typedef Allocator
+# endif
+
+#endif // if !defined(JSON_IS_AMALGAMATION)
+
+namespace Json {
+typedef int Int;
+typedef unsigned int UInt;
+#if defined(JSON_NO_INT64)
+typedef int LargestInt;
+typedef unsigned int LargestUInt;
+#undef JSON_HAS_INT64
+#else                 // if defined(JSON_NO_INT64)
+// For Microsoft Visual use specific types as long long is not supported
+#if defined(_MSC_VER) // Microsoft Visual Studio
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#else                 // if defined(_MSC_VER) // Other platforms, use long long
+typedef int64_t Int64;
+typedef uint64_t UInt64;
+#endif // if defined(_MSC_VER)
+typedef Int64 LargestInt;
+typedef UInt64 LargestUInt;
+#define JSON_HAS_INT64
+#endif // if defined(JSON_NO_INT64)
+#if JSONCPP_USING_SECURE_MEMORY
+#define JSONCPP_STRING        std::basic_string<char, std::char_traits<char>, Json::SecureAllocator<char> >
+#define JSONCPP_OSTRINGSTREAM std::basic_ostringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
+#define JSONCPP_OSTREAM       std::basic_ostream<char, std::char_traits<char>>
+#define JSONCPP_ISTRINGSTREAM std::basic_istringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
+#define JSONCPP_ISTREAM       std::istream
+#else
+#define JSONCPP_STRING        std::string
+#define JSONCPP_OSTRINGSTREAM std::ostringstream
+#define JSONCPP_OSTREAM       std::ostream
+#define JSONCPP_ISTRINGSTREAM std::istringstream
+#define JSONCPP_ISTREAM       std::istream
+#endif // if JSONCPP_USING_SECURE_MEMORY
+} // end namespace Json
+
+#endif // JSON_CONFIG_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/features.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/features.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/features.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/features.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,57 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef CPPTL_JSON_FEATURES_H_INCLUDED
+#define CPPTL_JSON_FEATURES_H_INCLUDED
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "forwards.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+
+namespace Json {
+
+/** \brief Configuration passed to reader and writer.
+ * This configuration object can be used to force the Reader or Writer
+ * to behave in a standard conforming way.
+ */
+class JSON_API Features {
+public:
+  /** \brief A configuration that allows all features and assumes all strings
+   * are UTF-8.
+   * - C & C++ comments are allowed
+   * - Root object can be any JSON value
+   * - Assumes Value strings are encoded in UTF-8
+   */
+  static Features all();
+
+  /** \brief A configuration that is strictly compatible with the JSON
+   * specification.
+   * - Comments are forbidden.
+   * - Root object must be either an array or an object value.
+   * - Assumes Value strings are encoded in UTF-8
+   */
+  static Features strictMode();
+
+  /** \brief Initialize the configuration like JsonConfig::allFeatures;
+   */
+  Features();
+
+  /// \c true if comments are allowed. Default: \c true.
+  bool allowComments_;
+
+  /// \c true if root must be either an array or an object value. Default: \c
+  /// false.
+  bool strictRoot_;
+
+  /// \c true if dropped null placeholders are allowed. Default: \c false.
+  bool allowDroppedNullPlaceholders_;
+
+  /// \c true if numeric object key are allowed. Default: \c false.
+  bool allowNumericKeys_;
+};
+
+} // namespace Json
+
+#endif // CPPTL_JSON_FEATURES_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/forwards.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/forwards.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/forwards.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/forwards.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,37 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSON_FORWARDS_H_INCLUDED
+#define JSON_FORWARDS_H_INCLUDED
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "config.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+
+namespace Json {
+
+// writer.h
+class FastWriter;
+class StyledWriter;
+
+// reader.h
+class Reader;
+
+// features.h
+class Features;
+
+// value.h
+typedef unsigned int ArrayIndex;
+class StaticString;
+class Path;
+class PathArgument;
+class Value;
+class ValueIteratorBase;
+class ValueIterator;
+class ValueConstIterator;
+
+} // namespace Json
+
+#endif // JSON_FORWARDS_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/json.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/json.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/json.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/json.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,15 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSON_JSON_H_INCLUDED
+#define JSON_JSON_H_INCLUDED
+
+#include "autolink.h"
+#include "value.h"
+#include "reader.h"
+#include "writer.h"
+#include "features.h"
+
+#endif // JSON_JSON_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/reader.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/reader.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/reader.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/reader.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,404 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef CPPTL_JSON_READER_H_INCLUDED
+#define CPPTL_JSON_READER_H_INCLUDED
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "features.h"
+#include "value.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <deque>
+#include <iosfwd>
+#include <stack>
+#include <string>
+#include <istream>
+
+// Disable warning C4251: <data member>: <type> needs to have dll-interface to
+// be used by...
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(push)
+#pragma warning(disable : 4251)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+namespace Json {
+
+/** \brief Unserialize a <a HREF="http://www.json.org">JSON</a> document into a
+ *Value.
+ *
+ * \deprecated Use CharReader and CharReaderBuilder.
+ */
+class JSON_API Reader {
+public:
+  typedef char Char;
+  typedef const Char* Location;
+
+  /** \brief An error tagged with where in the JSON text it was encountered.
+   *
+   * The offsets give the [start, limit) range of bytes within the text. Note
+   * that this is bytes, not codepoints.
+   *
+   */
+  struct StructuredError {
+    ptrdiff_t offset_start;
+    ptrdiff_t offset_limit;
+    JSONCPP_STRING message;
+  };
+
+  /** \brief Constructs a Reader allowing all features
+   * for parsing.
+   */
+  Reader();
+
+  /** \brief Constructs a Reader allowing the specified feature set
+   * for parsing.
+   */
+  Reader(const Features& features);
+
+  /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
+   * document.
+   * \param document UTF-8 encoded string containing the document to read.
+   * \param root [out] Contains the root value of the document if it was
+   *             successfully parsed.
+   * \param collectComments \c true to collect comment and allow writing them
+   * back during
+   *                        serialization, \c false to discard comments.
+   *                        This parameter is ignored if
+   * Features::allowComments_
+   *                        is \c false.
+   * \return \c true if the document was successfully parsed, \c false if an
+   * error occurred.
+   */
+  bool
+  parse(const std::string& document, Value& root, bool collectComments = true);
+
+  /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
+   document.
+   * \param beginDoc Pointer on the beginning of the UTF-8 encoded string of the
+   document to read.
+   * \param endDoc Pointer on the end of the UTF-8 encoded string of the
+   document to read.
+   *               Must be >= beginDoc.
+   * \param root [out] Contains the root value of the document if it was
+   *             successfully parsed.
+   * \param collectComments \c true to collect comment and allow writing them
+   back during
+   *                        serialization, \c false to discard comments.
+   *                        This parameter is ignored if
+   Features::allowComments_
+   *                        is \c false.
+   * \return \c true if the document was successfully parsed, \c false if an
+   error occurred.
+   */
+  bool parse(const char* beginDoc,
+             const char* endDoc,
+             Value& root,
+             bool collectComments = true);
+
+  /// \brief Parse from input stream.
+  /// \see Json::operator>>(std::istream&, Json::Value&).
+  bool parse(JSONCPP_ISTREAM& is, Value& root, bool collectComments = true);
+
+  /** \brief Returns a user friendly string that list errors in the parsed
+   * document.
+   * \return Formatted error message with the list of errors with their location
+   * in
+   *         the parsed document. An empty string is returned if no error
+   * occurred
+   *         during parsing.
+   * \deprecated Use getFormattedErrorMessages() instead (typo fix).
+   */
+  JSONCPP_DEPRECATED("Use getFormattedErrorMessages() instead.")
+  JSONCPP_STRING getFormatedErrorMessages() const;
+
+  /** \brief Returns a user friendly string that list errors in the parsed
+   * document.
+   * \return Formatted error message with the list of errors with their location
+   * in
+   *         the parsed document. An empty string is returned if no error
+   * occurred
+   *         during parsing.
+   */
+  JSONCPP_STRING getFormattedErrorMessages() const;
+
+  /** \brief Returns a vector of structured erros encounted while parsing.
+   * \return A (possibly empty) vector of StructuredError objects. Currently
+   *         only one error can be returned, but the caller should tolerate
+   * multiple
+   *         errors.  This can occur if the parser recovers from a non-fatal
+   *         parse error and then encounters additional errors.
+   */
+  std::vector<StructuredError> getStructuredErrors() const;
+
+  /** \brief Add a semantic error message.
+   * \param value JSON Value location associated with the error
+   * \param message The error message.
+   * \return \c true if the error was successfully added, \c false if the
+   * Value offset exceeds the document size.
+   */
+  bool pushError(const Value& value, const JSONCPP_STRING& message);
+
+  /** \brief Add a semantic error message with extra context.
+   * \param value JSON Value location associated with the error
+   * \param message The error message.
+   * \param extra Additional JSON Value location to contextualize the error
+   * \return \c true if the error was successfully added, \c false if either
+   * Value offset exceeds the document size.
+   */
+  bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
+
+  /** \brief Return whether there are any errors.
+   * \return \c true if there are no errors to report \c false if
+   * errors have occurred.
+   */
+  bool good() const;
+
+private:
+  enum TokenType {
+    tokenEndOfStream = 0,
+    tokenObjectBegin,
+    tokenObjectEnd,
+    tokenArrayBegin,
+    tokenArrayEnd,
+    tokenString,
+    tokenNumber,
+    tokenTrue,
+    tokenFalse,
+    tokenNull,
+    tokenArraySeparator,
+    tokenMemberSeparator,
+    tokenComment,
+    tokenError
+  };
+
+  class Token {
+  public:
+    TokenType type_;
+    Location start_;
+    Location end_;
+  };
+
+  class ErrorInfo {
+  public:
+    Token token_;
+    JSONCPP_STRING message_;
+    Location extra_;
+  };
+
+  typedef std::deque<ErrorInfo> Errors;
+
+  bool readToken(Token& token);
+  void skipSpaces();
+  bool match(Location pattern, int patternLength);
+  bool readComment();
+  bool readCStyleComment();
+  bool readCppStyleComment();
+  bool readString();
+  void readNumber();
+  bool readValue();
+  bool readObject(Token& token);
+  bool readArray(Token& token);
+  bool decodeNumber(Token& token);
+  bool decodeNumber(Token& token, Value& decoded);
+  bool decodeString(Token& token);
+  bool decodeString(Token& token, JSONCPP_STRING& decoded);
+  bool decodeDouble(Token& token);
+  bool decodeDouble(Token& token, Value& decoded);
+  bool decodeUnicodeCodePoint(Token& token,
+                              Location& current,
+                              Location end,
+                              unsigned int& unicode);
+  bool decodeUnicodeEscapeSequence(Token& token,
+                                   Location& current,
+                                   Location end,
+                                   unsigned int& unicode);
+  bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
+  bool recoverFromError(TokenType skipUntilToken);
+  bool addErrorAndRecover(const JSONCPP_STRING& message,
+                          Token& token,
+                          TokenType skipUntilToken);
+  void skipUntilSpace();
+  Value& currentValue();
+  Char getNextChar();
+  void
+  getLocationLineAndColumn(Location location, int& line, int& column) const;
+  JSONCPP_STRING getLocationLineAndColumn(Location location) const;
+  void addComment(Location begin, Location end, CommentPlacement placement);
+  void skipCommentTokens(Token& token);
+
+  typedef std::stack<Value*> Nodes;
+  Nodes nodes_;
+  Errors errors_;
+  JSONCPP_STRING document_;
+  Location begin_;
+  Location end_;
+  Location current_;
+  Location lastValueEnd_;
+  Value* lastValue_;
+  JSONCPP_STRING commentsBefore_;
+  Features features_;
+  bool collectComments_;
+};  // Reader
+
+/** Interface for reading JSON from a char array.
+ */
+class JSON_API CharReader {
+public:
+  virtual ~CharReader() {}
+  /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
+   document.
+   * The document must be a UTF-8 encoded string containing the document to read.
+   *
+   * \param beginDoc Pointer on the beginning of the UTF-8 encoded string of the
+   document to read.
+   * \param endDoc Pointer on the end of the UTF-8 encoded string of the
+   document to read.
+   *        Must be >= beginDoc.
+   * \param root [out] Contains the root value of the document if it was
+   *             successfully parsed.
+   * \param errs [out] Formatted error messages (if not NULL)
+   *        a user friendly string that lists errors in the parsed
+   * document.
+   * \return \c true if the document was successfully parsed, \c false if an
+   error occurred.
+   */
+  virtual bool parse(
+      char const* beginDoc, char const* endDoc,
+      Value* root, JSONCPP_STRING* errs) = 0;
+
+  class JSON_API Factory {
+  public:
+    virtual ~Factory() {}
+    /** \brief Allocate a CharReader via operator new().
+     * \throw std::exception if something goes wrong (e.g. invalid settings)
+     */
+    virtual CharReader* newCharReader() const = 0;
+  };  // Factory
+};  // CharReader
+
+/** \brief Build a CharReader implementation.
+
+Usage:
+\code
+  using namespace Json;
+  CharReaderBuilder builder;
+  builder["collectComments"] = false;
+  Value value;
+  JSONCPP_STRING errs;
+  bool ok = parseFromStream(builder, std::cin, &value, &errs);
+\endcode
+*/
+class JSON_API CharReaderBuilder : public CharReader::Factory {
+public:
+  // Note: We use a Json::Value so that we can add data-members to this class
+  // without a major version bump.
+  /** Configuration of this builder.
+    These are case-sensitive.
+    Available settings (case-sensitive):
+    - `"collectComments": false or true`
+      - true to collect comment and allow writing them
+        back during serialization, false to discard comments.
+        This parameter is ignored if allowComments is false.
+    - `"allowComments": false or true`
+      - true if comments are allowed.
+    - `"strictRoot": false or true`
+      - true if root must be either an array or an object value
+    - `"allowDroppedNullPlaceholders": false or true`
+      - true if dropped null placeholders are allowed. (See StreamWriterBuilder.)
+    - `"allowNumericKeys": false or true`
+      - true if numeric object keys are allowed.
+    - `"allowSingleQuotes": false or true`
+      - true if '' are allowed for strings (both keys and values)
+    - `"stackLimit": integer`
+      - Exceeding stackLimit (recursive depth of `readValue()`) will
+        cause an exception.
+      - This is a security issue (seg-faults caused by deeply nested JSON),
+        so the default is low.
+    - `"failIfExtra": false or true`
+      - If true, `parse()` returns false when extra non-whitespace trails
+        the JSON value in the input string.
+    - `"rejectDupKeys": false or true`
+      - If true, `parse()` returns false when a key is duplicated within an object.
+    - `"allowSpecialFloats": false or true`
+      - If true, special float values (NaNs and infinities) are allowed 
+        and their values are lossfree restorable.
+
+    You can examine 'settings_` yourself
+    to see the defaults. You can also write and read them just like any
+    JSON Value.
+    \sa setDefaults()
+    */
+  Json::Value settings_;
+
+  CharReaderBuilder();
+  ~CharReaderBuilder() JSONCPP_OVERRIDE;
+
+  CharReader* newCharReader() const JSONCPP_OVERRIDE;
+
+  /** \return true if 'settings' are legal and consistent;
+   *   otherwise, indicate bad settings via 'invalid'.
+   */
+  bool validate(Json::Value* invalid) const;
+
+  /** A simple way to update a specific setting.
+   */
+  Value& operator[](JSONCPP_STRING key);
+
+  /** Called by ctor, but you can use this to reset settings_.
+   * \pre 'settings' != NULL (but Json::null is fine)
+   * \remark Defaults:
+   * \snippet src/lib_json/json_reader.cpp CharReaderBuilderDefaults
+   */
+  static void setDefaults(Json::Value* settings);
+  /** Same as old Features::strictMode().
+   * \pre 'settings' != NULL (but Json::null is fine)
+   * \remark Defaults:
+   * \snippet src/lib_json/json_reader.cpp CharReaderBuilderStrictMode
+   */
+  static void strictMode(Json::Value* settings);
+};
+
+/** Consume entire stream and use its begin/end.
+  * Someday we might have a real StreamReader, but for now this
+  * is convenient.
+  */
+bool JSON_API parseFromStream(
+    CharReader::Factory const&,
+    JSONCPP_ISTREAM&,
+    Value* root, std::string* errs);
+
+/** \brief Read from 'sin' into 'root'.
+
+ Always keep comments from the input JSON.
+
+ This can be used to read a file into a particular sub-object.
+ For example:
+ \code
+ Json::Value root;
+ cin >> root["dir"]["file"];
+ cout << root;
+ \endcode
+ Result:
+ \verbatim
+ {
+ "dir": {
+     "file": {
+     // The input stream JSON would be nested here.
+     }
+ }
+ }
+ \endverbatim
+ \throw std::exception on parse error.
+ \see Json::operator<<()
+*/
+JSON_API JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM&, Value&);
+
+} // namespace Json
+
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(pop)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+#endif // CPPTL_JSON_READER_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/value.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/value.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/value.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/value.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,867 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef CPPTL_JSON_H_INCLUDED
+#define CPPTL_JSON_H_INCLUDED
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "forwards.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <string>
+#include <vector>
+#include <exception>
+
+#ifndef JSON_USE_CPPTL_SMALLMAP
+#include <map>
+#else
+#include <cpptl/smallmap.h>
+#endif
+#ifdef JSON_USE_CPPTL
+#include <cpptl/forwards.h>
+#endif
+
+//Conditional NORETURN attribute on the throw functions would:
+// a) suppress false positives from static code analysis 
+// b) possibly improve optimization opportunities.
+#if !defined(JSONCPP_NORETURN)
+#  if defined(_MSC_VER)
+#    define JSONCPP_NORETURN __declspec(noreturn)
+#  elif defined(__GNUC__)
+#    define JSONCPP_NORETURN __attribute__ ((__noreturn__))
+#  else
+#    define JSONCPP_NORETURN
+#  endif
+#endif
+
+// Disable warning C4251: <data member>: <type> needs to have dll-interface to
+// be used by...
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(push)
+#pragma warning(disable : 4251)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+/** \brief JSON (JavaScript Object Notation).
+ */
+namespace Json {
+
+/** Base class for all exceptions we throw.
+ *
+ * We use nothing but these internally. Of course, STL can throw others.
+ */
+class JSON_API Exception : public std::exception {
+public:
+  Exception(JSONCPP_STRING const& msg);
+  ~Exception() throw() JSONCPP_OVERRIDE;
+  char const* what() const throw() JSONCPP_OVERRIDE;
+protected:
+  JSONCPP_STRING msg_;
+};
+
+/** Exceptions which the user cannot easily avoid.
+ *
+ * E.g. out-of-memory (when we use malloc), stack-overflow, malicious input
+ * 
+ * \remark derived from Json::Exception
+ */
+class JSON_API RuntimeError : public Exception {
+public:
+  RuntimeError(JSONCPP_STRING const& msg);
+};
+
+/** Exceptions thrown by JSON_ASSERT/JSON_FAIL macros.
+ *
+ * These are precondition-violations (user bugs) and internal errors (our bugs).
+ * 
+ * \remark derived from Json::Exception
+ */
+class JSON_API LogicError : public Exception {
+public:
+  LogicError(JSONCPP_STRING const& msg);
+};
+
+/// used internally
+JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg);
+/// used internally
+JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg);
+
+/** \brief Type of the value held by a Value object.
+ */
+enum ValueType {
+  nullValue = 0, ///< 'null' value
+  intValue,      ///< signed integer value
+  uintValue,     ///< unsigned integer value
+  realValue,     ///< double value
+  stringValue,   ///< UTF-8 string value
+  booleanValue,  ///< bool value
+  arrayValue,    ///< array value (ordered list)
+  objectValue    ///< object value (collection of name/value pairs).
+};
+
+enum CommentPlacement {
+  commentBefore = 0,      ///< a comment placed on the line before a value
+  commentAfterOnSameLine, ///< a comment just after a value on the same line
+  commentAfter, ///< a comment on the line after a value (only make sense for
+  /// root value)
+  numberOfCommentPlacement
+};
+
+//# ifdef JSON_USE_CPPTL
+//   typedef CppTL::AnyEnumerator<const char *> EnumMemberNames;
+//   typedef CppTL::AnyEnumerator<const Value &> EnumValues;
+//# endif
+
+/** \brief Lightweight wrapper to tag static string.
+ *
+ * Value constructor and objectValue member assignement takes advantage of the
+ * StaticString and avoid the cost of string duplication when storing the
+ * string or the member name.
+ *
+ * Example of usage:
+ * \code
+ * Json::Value aValue( StaticString("some text") );
+ * Json::Value object;
+ * static const StaticString code("code");
+ * object[code] = 1234;
+ * \endcode
+ */
+class JSON_API StaticString {
+public:
+  explicit StaticString(const char* czstring) : c_str_(czstring) {}
+
+  operator const char*() const { return c_str_; }
+
+  const char* c_str() const { return c_str_; }
+
+private:
+  const char* c_str_;
+};
+
+/** \brief Represents a <a HREF="http://www.json.org">JSON</a> value.
+ *
+ * This class is a discriminated union wrapper that can represents a:
+ * - signed integer [range: Value::minInt - Value::maxInt]
+ * - unsigned integer (range: 0 - Value::maxUInt)
+ * - double
+ * - UTF-8 string
+ * - boolean
+ * - 'null'
+ * - an ordered list of Value
+ * - collection of name/value pairs (javascript object)
+ *
+ * The type of the held value is represented by a #ValueType and
+ * can be obtained using type().
+ *
+ * Values of an #objectValue or #arrayValue can be accessed using operator[]()
+ * methods.
+ * Non-const methods will automatically create the a #nullValue element
+ * if it does not exist.
+ * The sequence of an #arrayValue will be automatically resized and initialized
+ * with #nullValue. resize() can be used to enlarge or truncate an #arrayValue.
+ *
+ * The get() methods can be used to obtain default value in the case the
+ * required element does not exist.
+ *
+ * It is possible to iterate over the list of a #objectValue values using
+ * the getMemberNames() method.
+ *
+ * \note #Value string-length fit in size_t, but keys must be < 2^30.
+ * (The reason is an implementation detail.) A #CharReader will raise an
+ * exception if a bound is exceeded to avoid security holes in your app,
+ * but the Value API does *not* check bounds. That is the responsibility
+ * of the caller.
+ */
+class JSON_API Value {
+  friend class ValueIteratorBase;
+public:
+  typedef std::vector<JSONCPP_STRING> Members;
+  typedef ValueIterator iterator;
+  typedef ValueConstIterator const_iterator;
+  typedef Json::UInt UInt;
+  typedef Json::Int Int;
+#if defined(JSON_HAS_INT64)
+  typedef Json::UInt64 UInt64;
+  typedef Json::Int64 Int64;
+#endif // defined(JSON_HAS_INT64)
+  typedef Json::LargestInt LargestInt;
+  typedef Json::LargestUInt LargestUInt;
+  typedef Json::ArrayIndex ArrayIndex;
+
+  static const Value& null;  ///< We regret this reference to a global instance; prefer the simpler Value().
+  static const Value& nullRef;  ///< just a kludge for binary-compatibility; same as null
+  static Value const& nullSingleton(); ///< Prefer this to null or nullRef.
+
+  /// Minimum signed integer value that can be stored in a Json::Value.
+  static const LargestInt minLargestInt;
+  /// Maximum signed integer value that can be stored in a Json::Value.
+  static const LargestInt maxLargestInt;
+  /// Maximum unsigned integer value that can be stored in a Json::Value.
+  static const LargestUInt maxLargestUInt;
+
+  /// Minimum signed int value that can be stored in a Json::Value.
+  static const Int minInt;
+  /// Maximum signed int value that can be stored in a Json::Value.
+  static const Int maxInt;
+  /// Maximum unsigned int value that can be stored in a Json::Value.
+  static const UInt maxUInt;
+
+#if defined(JSON_HAS_INT64)
+  /// Minimum signed 64 bits int value that can be stored in a Json::Value.
+  static const Int64 minInt64;
+  /// Maximum signed 64 bits int value that can be stored in a Json::Value.
+  static const Int64 maxInt64;
+  /// Maximum unsigned 64 bits int value that can be stored in a Json::Value.
+  static const UInt64 maxUInt64;
+#endif // defined(JSON_HAS_INT64)
+
+private:
+#ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
+  class CZString {
+  public:
+    enum DuplicationPolicy {
+      noDuplication = 0,
+      duplicate,
+      duplicateOnCopy
+    };
+    CZString(ArrayIndex index);
+    CZString(char const* str, unsigned length, DuplicationPolicy allocate);
+    CZString(CZString const& other);
+#if JSON_HAS_RVALUE_REFERENCES
+    CZString(CZString&& other);
+#endif
+    ~CZString();
+    CZString& operator=(CZString other);
+    bool operator<(CZString const& other) const;
+    bool operator==(CZString const& other) const;
+    ArrayIndex index() const;
+    //const char* c_str() const; ///< \deprecated
+    char const* data() const;
+    unsigned length() const;
+    bool isStaticString() const;
+
+  private:
+    void swap(CZString& other);
+
+    struct StringStorage {
+      unsigned policy_: 2;
+      unsigned length_: 30; // 1GB max
+    };
+
+    char const* cstr_;  // actually, a prefixed string, unless policy is noDup
+    union {
+      ArrayIndex index_;
+      StringStorage storage_;
+    };
+  };
+
+public:
+#ifndef JSON_USE_CPPTL_SMALLMAP
+  typedef std::map<CZString, Value> ObjectValues;
+#else
+  typedef CppTL::SmallMap<CZString, Value> ObjectValues;
+#endif // ifndef JSON_USE_CPPTL_SMALLMAP
+#endif // ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
+
+public:
+  /** \brief Create a default Value of the given type.
+
+    This is a very useful constructor.
+    To create an empty array, pass arrayValue.
+    To create an empty object, pass objectValue.
+    Another Value can then be set to this one by assignment.
+This is useful since clear() and resize() will not alter types.
+
+    Examples:
+\code
+Json::Value null_value; // null
+Json::Value arr_value(Json::arrayValue); // []
+Json::Value obj_value(Json::objectValue); // {}
+\endcode
+  */
+  Value(ValueType type = nullValue);
+  Value(Int value);
+  Value(UInt value);
+#if defined(JSON_HAS_INT64)
+  Value(Int64 value);
+  Value(UInt64 value);
+#endif // if defined(JSON_HAS_INT64)
+  Value(double value);
+  Value(const char* value); ///< Copy til first 0. (NULL causes to seg-fault.)
+  Value(const char* begin, const char* end); ///< Copy all, incl zeroes.
+  /** \brief Constructs a value from a static string.
+
+   * Like other value string constructor but do not duplicate the string for
+   * internal storage. The given string must remain alive after the call to this
+   * constructor.
+   * \note This works only for null-terminated strings. (We cannot change the
+   *   size of this class, so we have nowhere to store the length,
+   *   which might be computed later for various operations.)
+   *
+   * Example of usage:
+   * \code
+   * static StaticString foo("some text");
+   * Json::Value aValue(foo);
+   * \endcode
+   */
+  Value(const StaticString& value);
+  Value(const JSONCPP_STRING& value); ///< Copy data() til size(). Embedded zeroes too.
+#ifdef JSON_USE_CPPTL
+  Value(const CppTL::ConstString& value);
+#endif
+  Value(bool value);
+  /// Deep copy.
+  Value(const Value& other);
+#if JSON_HAS_RVALUE_REFERENCES
+  /// Move constructor
+  Value(Value&& other);
+#endif
+  ~Value();
+
+  /// Deep copy, then swap(other).
+  /// \note Over-write existing comments. To preserve comments, use #swapPayload().
+  Value& operator=(Value other);
+  /// Swap everything.
+  void swap(Value& other);
+  /// Swap values but leave comments and source offsets in place.
+  void swapPayload(Value& other);
+
+  ValueType type() const;
+
+  /// Compare payload only, not comments etc.
+  bool operator<(const Value& other) const;
+  bool operator<=(const Value& other) const;
+  bool operator>=(const Value& other) const;
+  bool operator>(const Value& other) const;
+  bool operator==(const Value& other) const;
+  bool operator!=(const Value& other) const;
+  int compare(const Value& other) const;
+
+  const char* asCString() const; ///< Embedded zeroes could cause you trouble!
+#if JSONCPP_USING_SECURE_MEMORY
+  unsigned getCStringLength() const; //Allows you to understand the length of the CString
+#endif
+  JSONCPP_STRING asString() const; ///< Embedded zeroes are possible.
+  /** Get raw char* of string-value.
+   *  \return false if !string. (Seg-fault if str or end are NULL.)
+   */
+  bool getString(
+      char const** begin, char const** end) const;
+#ifdef JSON_USE_CPPTL
+  CppTL::ConstString asConstString() const;
+#endif
+  Int asInt() const;
+  UInt asUInt() const;
+#if defined(JSON_HAS_INT64)
+  Int64 asInt64() const;
+  UInt64 asUInt64() const;
+#endif // if defined(JSON_HAS_INT64)
+  LargestInt asLargestInt() const;
+  LargestUInt asLargestUInt() const;
+  float asFloat() const;
+  double asDouble() const;
+  bool asBool() const;
+
+  bool isNull() const;
+  bool isBool() const;
+  bool isInt() const;
+  bool isInt64() const;
+  bool isUInt() const;
+  bool isUInt64() const;
+  bool isIntegral() const;
+  bool isDouble() const;
+  bool isNumeric() const;
+  bool isString() const;
+  bool isArray() const;
+  bool isObject() const;
+
+  bool isConvertibleTo(ValueType other) const;
+
+  /// Number of values in array or object
+  ArrayIndex size() const;
+
+  /// \brief Return true if empty array, empty object, or null;
+  /// otherwise, false.
+  bool empty() const;
+
+  /// Return isNull()
+  bool operator!() const;
+
+  /// Remove all object members and array elements.
+  /// \pre type() is arrayValue, objectValue, or nullValue
+  /// \post type() is unchanged
+  void clear();
+
+  /// Resize the array to size elements.
+  /// New elements are initialized to null.
+  /// May only be called on nullValue or arrayValue.
+  /// \pre type() is arrayValue or nullValue
+  /// \post type() is arrayValue
+  void resize(ArrayIndex size);
+
+  /// Access an array element (zero based index ).
+  /// If the array contains less than index element, then null value are
+  /// inserted
+  /// in the array so that its size is index+1.
+  /// (You may need to say 'value[0u]' to get your compiler to distinguish
+  ///  this from the operator[] which takes a string.)
+  Value& operator[](ArrayIndex index);
+
+  /// Access an array element (zero based index ).
+  /// If the array contains less than index element, then null value are
+  /// inserted
+  /// in the array so that its size is index+1.
+  /// (You may need to say 'value[0u]' to get your compiler to distinguish
+  ///  this from the operator[] which takes a string.)
+  Value& operator[](int index);
+
+  /// Access an array element (zero based index )
+  /// (You may need to say 'value[0u]' to get your compiler to distinguish
+  ///  this from the operator[] which takes a string.)
+  const Value& operator[](ArrayIndex index) const;
+
+  /// Access an array element (zero based index )
+  /// (You may need to say 'value[0u]' to get your compiler to distinguish
+  ///  this from the operator[] which takes a string.)
+  const Value& operator[](int index) const;
+
+  /// If the array contains at least index+1 elements, returns the element
+  /// value,
+  /// otherwise returns defaultValue.
+  Value get(ArrayIndex index, const Value& defaultValue) const;
+  /// Return true if index < size().
+  bool isValidIndex(ArrayIndex index) const;
+  /// \brief Append value to array at the end.
+  ///
+  /// Equivalent to jsonvalue[jsonvalue.size()] = value;
+  Value& append(const Value& value);
+
+  /// Access an object value by name, create a null member if it does not exist.
+  /// \note Because of our implementation, keys are limited to 2^30 -1 chars.
+  ///  Exceeding that will cause an exception.
+  Value& operator[](const char* key);
+  /// Access an object value by name, returns null if there is no member with
+  /// that name.
+  const Value& operator[](const char* key) const;
+  /// Access an object value by name, create a null member if it does not exist.
+  /// \param key may contain embedded nulls.
+  Value& operator[](const JSONCPP_STRING& key);
+  /// Access an object value by name, returns null if there is no member with
+  /// that name.
+  /// \param key may contain embedded nulls.
+  const Value& operator[](const JSONCPP_STRING& key) const;
+  /** \brief Access an object value by name, create a null member if it does not
+   exist.
+
+   * If the object has no entry for that name, then the member name used to store
+   * the new entry is not duplicated.
+   * Example of use:
+   * \code
+   * Json::Value object;
+   * static const StaticString code("code");
+   * object[code] = 1234;
+   * \endcode
+   */
+  Value& operator[](const StaticString& key);
+#ifdef JSON_USE_CPPTL
+  /// Access an object value by name, create a null member if it does not exist.
+  Value& operator[](const CppTL::ConstString& key);
+  /// Access an object value by name, returns null if there is no member with
+  /// that name.
+  const Value& operator[](const CppTL::ConstString& key) const;
+#endif
+  /// Return the member named key if it exist, defaultValue otherwise.
+  /// \note deep copy
+  Value get(const char* key, const Value& defaultValue) const;
+  /// Return the member named key if it exist, defaultValue otherwise.
+  /// \note deep copy
+  /// \note key may contain embedded nulls.
+  Value get(const char* begin, const char* end, const Value& defaultValue) const;
+  /// Return the member named key if it exist, defaultValue otherwise.
+  /// \note deep copy
+  /// \param key may contain embedded nulls.
+  Value get(const JSONCPP_STRING& key, const Value& defaultValue) const;
+#ifdef JSON_USE_CPPTL
+  /// Return the member named key if it exist, defaultValue otherwise.
+  /// \note deep copy
+  Value get(const CppTL::ConstString& key, const Value& defaultValue) const;
+#endif
+  /// Most general and efficient version of isMember()const, get()const,
+  /// and operator[]const
+  /// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
+  Value const* find(char const* begin, char const* end) const;
+  /// Most general and efficient version of object-mutators.
+  /// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
+  /// \return non-zero, but JSON_ASSERT if this is neither object nor nullValue.
+  Value const* demand(char const* begin, char const* end);
+  /// \brief Remove and return the named member.
+  ///
+  /// Do nothing if it did not exist.
+  /// \return the removed Value, or null.
+  /// \pre type() is objectValue or nullValue
+  /// \post type() is unchanged
+  /// \deprecated
+  Value removeMember(const char* key);
+  /// Same as removeMember(const char*)
+  /// \param key may contain embedded nulls.
+  /// \deprecated
+  Value removeMember(const JSONCPP_STRING& key);
+  /// Same as removeMember(const char* begin, const char* end, Value* removed),
+  /// but 'key' is null-terminated.
+  bool removeMember(const char* key, Value* removed);
+  /** \brief Remove the named map member.
+
+      Update 'removed' iff removed.
+      \param key may contain embedded nulls.
+      \return true iff removed (no exceptions)
+  */
+  bool removeMember(JSONCPP_STRING const& key, Value* removed);
+  /// Same as removeMember(JSONCPP_STRING const& key, Value* removed)
+  bool removeMember(const char* begin, const char* end, Value* removed);
+  /** \brief Remove the indexed array element.
+
+      O(n) expensive operations.
+      Update 'removed' iff removed.
+      \return true iff removed (no exceptions)
+  */
+  bool removeIndex(ArrayIndex i, Value* removed);
+
+  /// Return true if the object has a member named key.
+  /// \note 'key' must be null-terminated.
+  bool isMember(const char* key) const;
+  /// Return true if the object has a member named key.
+  /// \param key may contain embedded nulls.
+  bool isMember(const JSONCPP_STRING& key) const;
+  /// Same as isMember(JSONCPP_STRING const& key)const
+  bool isMember(const char* begin, const char* end) const;
+#ifdef JSON_USE_CPPTL
+  /// Return true if the object has a member named key.
+  bool isMember(const CppTL::ConstString& key) const;
+#endif
+
+  /// \brief Return a list of the member names.
+  ///
+  /// If null, return an empty list.
+  /// \pre type() is objectValue or nullValue
+  /// \post if type() was nullValue, it remains nullValue
+  Members getMemberNames() const;
+
+  //# ifdef JSON_USE_CPPTL
+  //      EnumMemberNames enumMemberNames() const;
+  //      EnumValues enumValues() const;
+  //# endif
+
+  /// \deprecated Always pass len.
+  JSONCPP_DEPRECATED("Use setComment(JSONCPP_STRING const&) instead.")
+  void setComment(const char* comment, CommentPlacement placement);
+  /// Comments must be //... or /* ... */
+  void setComment(const char* comment, size_t len, CommentPlacement placement);
+  /// Comments must be //... or /* ... */
+  void setComment(const JSONCPP_STRING& comment, CommentPlacement placement);
+  bool hasComment(CommentPlacement placement) const;
+  /// Include delimiters and embedded newlines.
+  JSONCPP_STRING getComment(CommentPlacement placement) const;
+
+  JSONCPP_STRING toStyledString() const;
+
+  const_iterator begin() const;
+  const_iterator end() const;
+
+  iterator begin();
+  iterator end();
+
+  // Accessors for the [start, limit) range of bytes within the JSON text from
+  // which this value was parsed, if any.
+  void setOffsetStart(ptrdiff_t start);
+  void setOffsetLimit(ptrdiff_t limit);
+  ptrdiff_t getOffsetStart() const;
+  ptrdiff_t getOffsetLimit() const;
+
+private:
+  void initBasic(ValueType type, bool allocated = false);
+
+  Value& resolveReference(const char* key);
+  Value& resolveReference(const char* key, const char* end);
+
+  struct CommentInfo {
+    CommentInfo();
+    ~CommentInfo();
+
+    void setComment(const char* text, size_t len);
+
+    char* comment_;
+  };
+
+  // struct MemberNamesTransform
+  //{
+  //   typedef const char *result_type;
+  //   const char *operator()( const CZString &name ) const
+  //   {
+  //      return name.c_str();
+  //   }
+  //};
+
+  union ValueHolder {
+    LargestInt int_;
+    LargestUInt uint_;
+    double real_;
+    bool bool_;
+    char* string_;  // actually ptr to unsigned, followed by str, unless !allocated_
+    ObjectValues* map_;
+  } value_;
+  ValueType type_ : 8;
+  unsigned int allocated_ : 1; // Notes: if declared as bool, bitfield is useless.
+                               // If not allocated_, string_ must be null-terminated.
+  CommentInfo* comments_;
+
+  // [start, limit) byte offsets in the source JSON text from which this Value
+  // was extracted.
+  ptrdiff_t start_;
+  ptrdiff_t limit_;
+};
+
+/** \brief Experimental and untested: represents an element of the "path" to
+ * access a node.
+ */
+class JSON_API PathArgument {
+public:
+  friend class Path;
+
+  PathArgument();
+  PathArgument(ArrayIndex index);
+  PathArgument(const char* key);
+  PathArgument(const JSONCPP_STRING& key);
+
+private:
+  enum Kind {
+    kindNone = 0,
+    kindIndex,
+    kindKey
+  };
+  JSONCPP_STRING key_;
+  ArrayIndex index_;
+  Kind kind_;
+};
+
+/** \brief Experimental and untested: represents a "path" to access a node.
+ *
+ * Syntax:
+ * - "." => root node
+ * - ".[n]" => elements at index 'n' of root node (an array value)
+ * - ".name" => member named 'name' of root node (an object value)
+ * - ".name1.name2.name3"
+ * - ".[0][1][2].name1[3]"
+ * - ".%" => member name is provided as parameter
+ * - ".[%]" => index is provied as parameter
+ */
+class JSON_API Path {
+public:
+  Path(const JSONCPP_STRING& path,
+       const PathArgument& a1 = PathArgument(),
+       const PathArgument& a2 = PathArgument(),
+       const PathArgument& a3 = PathArgument(),
+       const PathArgument& a4 = PathArgument(),
+       const PathArgument& a5 = PathArgument());
+
+  const Value& resolve(const Value& root) const;
+  Value resolve(const Value& root, const Value& defaultValue) const;
+  /// Creates the "path" to access the specified node and returns a reference on
+  /// the node.
+  Value& make(Value& root) const;
+
+private:
+  typedef std::vector<const PathArgument*> InArgs;
+  typedef std::vector<PathArgument> Args;
+
+  void makePath(const JSONCPP_STRING& path, const InArgs& in);
+  void addPathInArg(const JSONCPP_STRING& path,
+                    const InArgs& in,
+                    InArgs::const_iterator& itInArg,
+                    PathArgument::Kind kind);
+  void invalidPath(const JSONCPP_STRING& path, int location);
+
+  Args args_;
+};
+
+/** \brief base class for Value iterators.
+ *
+ */
+class JSON_API ValueIteratorBase {
+public:
+  typedef std::bidirectional_iterator_tag iterator_category;
+  typedef unsigned int size_t;
+  typedef int difference_type;
+  typedef ValueIteratorBase SelfType;
+
+  bool operator==(const SelfType& other) const { return isEqual(other); }
+
+  bool operator!=(const SelfType& other) const { return !isEqual(other); }
+
+  difference_type operator-(const SelfType& other) const {
+    return other.computeDistance(*this);
+  }
+
+  /// Return either the index or the member name of the referenced value as a
+  /// Value.
+  Value key() const;
+
+  /// Return the index of the referenced Value, or -1 if it is not an arrayValue.
+  UInt index() const;
+
+  /// Return the member name of the referenced Value, or "" if it is not an
+  /// objectValue.
+  /// \note Avoid `c_str()` on result, as embedded zeroes are possible.
+  JSONCPP_STRING name() const;
+
+  /// Return the member name of the referenced Value. "" if it is not an
+  /// objectValue.
+  /// \deprecated This cannot be used for UTF-8 strings, since there can be embedded nulls.
+  JSONCPP_DEPRECATED("Use `key = name();` instead.")
+  char const* memberName() const;
+  /// Return the member name of the referenced Value, or NULL if it is not an
+  /// objectValue.
+  /// \note Better version than memberName(). Allows embedded nulls.
+  char const* memberName(char const** end) const;
+
+protected:
+  Value& deref() const;
+
+  void increment();
+
+  void decrement();
+
+  difference_type computeDistance(const SelfType& other) const;
+
+  bool isEqual(const SelfType& other) const;
+
+  void copy(const SelfType& other);
+
+private:
+  Value::ObjectValues::iterator current_;
+  // Indicates that iterator is for a null value.
+  bool isNull_;
+
+public:
+  // For some reason, BORLAND needs these at the end, rather
+  // than earlier. No idea why.
+  ValueIteratorBase();
+  explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);
+};
+
+/** \brief const iterator for object and array value.
+ *
+ */
+class JSON_API ValueConstIterator : public ValueIteratorBase {
+  friend class Value;
+
+public:
+  typedef const Value value_type;
+  //typedef unsigned int size_t;
+  //typedef int difference_type;
+  typedef const Value& reference;
+  typedef const Value* pointer;
+  typedef ValueConstIterator SelfType;
+
+  ValueConstIterator();
+  ValueConstIterator(ValueIterator const& other);
+
+private:
+/*! \internal Use by Value to create an iterator.
+ */
+  explicit ValueConstIterator(const Value::ObjectValues::iterator& current);
+public:
+  SelfType& operator=(const ValueIteratorBase& other);
+
+  SelfType operator++(int) {
+    SelfType temp(*this);
+    ++*this;
+    return temp;
+  }
+
+  SelfType operator--(int) {
+    SelfType temp(*this);
+    --*this;
+    return temp;
+  }
+
+  SelfType& operator--() {
+    decrement();
+    return *this;
+  }
+
+  SelfType& operator++() {
+    increment();
+    return *this;
+  }
+
+  reference operator*() const { return deref(); }
+
+  pointer operator->() const { return &deref(); }
+};
+
+/** \brief Iterator for object and array value.
+ */
+class JSON_API ValueIterator : public ValueIteratorBase {
+  friend class Value;
+
+public:
+  typedef Value value_type;
+  typedef unsigned int size_t;
+  typedef int difference_type;
+  typedef Value& reference;
+  typedef Value* pointer;
+  typedef ValueIterator SelfType;
+
+  ValueIterator();
+  explicit ValueIterator(const ValueConstIterator& other);
+  ValueIterator(const ValueIterator& other);
+
+private:
+/*! \internal Use by Value to create an iterator.
+ */
+  explicit ValueIterator(const Value::ObjectValues::iterator& current);
+public:
+  SelfType& operator=(const SelfType& other);
+
+  SelfType operator++(int) {
+    SelfType temp(*this);
+    ++*this;
+    return temp;
+  }
+
+  SelfType operator--(int) {
+    SelfType temp(*this);
+    --*this;
+    return temp;
+  }
+
+  SelfType& operator--() {
+    decrement();
+    return *this;
+  }
+
+  SelfType& operator++() {
+    increment();
+    return *this;
+  }
+
+  reference operator*() const { return deref(); }
+
+  pointer operator->() const { return &deref(); }
+};
+
+} // namespace Json
+
+
+namespace std {
+/// Specialize std::swap() for Json::Value.
+template<>
+inline void swap(Json::Value& a, Json::Value& b) { a.swap(b); }
+}
+
+
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(pop)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+#endif // CPPTL_JSON_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/version.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/version.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/version.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/version.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,20 @@
+// DO NOT EDIT. This file (and "version") is generated by CMake.
+// Run CMake configure step to update it.
+#ifndef JSON_VERSION_H_INCLUDED
+# define JSON_VERSION_H_INCLUDED
+
+# define JSONCPP_VERSION_STRING "1.7.7"
+# define JSONCPP_VERSION_MAJOR 1
+# define JSONCPP_VERSION_MINOR 7
+# define JSONCPP_VERSION_PATCH 7
+# define JSONCPP_VERSION_QUALIFIER
+# define JSONCPP_VERSION_HEXA ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) | (JSONCPP_VERSION_PATCH << 8))
+
+#ifdef JSONCPP_USING_SECURE_MEMORY
+#undef JSONCPP_USING_SECURE_MEMORY
+#endif
+#define JSONCPP_USING_SECURE_MEMORY 0
+// If non-zero, the library zeroes any memory that it has allocated before
+// it frees its memory.
+
+#endif // JSON_VERSION_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/writer.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/writer.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/writer.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/include/json/writer.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,331 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSON_WRITER_H_INCLUDED
+#define JSON_WRITER_H_INCLUDED
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include "value.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <vector>
+#include <string>
+#include <ostream>
+
+// Disable warning C4251: <data member>: <type> needs to have dll-interface to
+// be used by...
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(push)
+#pragma warning(disable : 4251)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+namespace Json {
+
+class Value;
+
+/**
+
+Usage:
+\code
+  using namespace Json;
+  void writeToStdout(StreamWriter::Factory const& factory, Value const& value) {
+    std::unique_ptr<StreamWriter> const writer(
+      factory.newStreamWriter());
+    writer->write(value, &std::cout);
+    std::cout << std::endl;  // add lf and flush
+  }
+\endcode
+*/
+class JSON_API StreamWriter {
+protected:
+  JSONCPP_OSTREAM* sout_;  // not owned; will not delete
+public:
+  StreamWriter();
+  virtual ~StreamWriter();
+  /** Write Value into document as configured in sub-class.
+      Do not take ownership of sout, but maintain a reference during function.
+      \pre sout != NULL
+      \return zero on success (For now, we always return zero, so check the stream instead.)
+      \throw std::exception possibly, depending on configuration
+   */
+  virtual int write(Value const& root, JSONCPP_OSTREAM* sout) = 0;
+
+  /** \brief A simple abstract factory.
+   */
+  class JSON_API Factory {
+  public:
+    virtual ~Factory();
+    /** \brief Allocate a CharReader via operator new().
+     * \throw std::exception if something goes wrong (e.g. invalid settings)
+     */
+    virtual StreamWriter* newStreamWriter() const = 0;
+  };  // Factory
+};  // StreamWriter
+
+/** \brief Write into stringstream, then return string, for convenience.
+ * A StreamWriter will be created from the factory, used, and then deleted.
+ */
+JSONCPP_STRING JSON_API writeString(StreamWriter::Factory const& factory, Value const& root);
+
+
+/** \brief Build a StreamWriter implementation.
+
+Usage:
+\code
+  using namespace Json;
+  Value value = ...;
+  StreamWriterBuilder builder;
+  builder["commentStyle"] = "None";
+  builder["indentation"] = "   ";  // or whatever you like
+  std::unique_ptr<Json::StreamWriter> writer(
+      builder.newStreamWriter());
+  writer->write(value, &std::cout);
+  std::cout << std::endl;  // add lf and flush
+\endcode
+*/
+class JSON_API StreamWriterBuilder : public StreamWriter::Factory {
+public:
+  // Note: We use a Json::Value so that we can add data-members to this class
+  // without a major version bump.
+  /** Configuration of this builder.
+    Available settings (case-sensitive):
+    - "commentStyle": "None" or "All"
+    - "indentation":  "<anything>"
+    - "enableYAMLCompatibility": false or true
+      - slightly change the whitespace around colons
+    - "dropNullPlaceholders": false or true
+      - Drop the "null" string from the writer's output for nullValues.
+        Strictly speaking, this is not valid JSON. But when the output is being
+        fed to a browser's Javascript, it makes for smaller output and the
+        browser can handle the output just fine.
+    - "useSpecialFloats": false or true
+      - If true, outputs non-finite floating point values in the following way:
+        NaN values as "NaN", positive infinity as "Infinity", and negative infinity
+        as "-Infinity".
+
+    You can examine 'settings_` yourself
+    to see the defaults. You can also write and read them just like any
+    JSON Value.
+    \sa setDefaults()
+    */
+  Json::Value settings_;
+
+  StreamWriterBuilder();
+  ~StreamWriterBuilder() JSONCPP_OVERRIDE;
+
+  /**
+   * \throw std::exception if something goes wrong (e.g. invalid settings)
+   */
+  StreamWriter* newStreamWriter() const JSONCPP_OVERRIDE;
+
+  /** \return true if 'settings' are legal and consistent;
+   *   otherwise, indicate bad settings via 'invalid'.
+   */
+  bool validate(Json::Value* invalid) const;
+  /** A simple way to update a specific setting.
+   */
+  Value& operator[](JSONCPP_STRING key);
+
+  /** Called by ctor, but you can use this to reset settings_.
+   * \pre 'settings' != NULL (but Json::null is fine)
+   * \remark Defaults:
+   * \snippet src/lib_json/json_writer.cpp StreamWriterBuilderDefaults
+   */
+  static void setDefaults(Json::Value* settings);
+};
+
+/** \brief Abstract class for writers.
+ * \deprecated Use StreamWriter. (And really, this is an implementation detail.)
+ */
+class JSON_API Writer {
+public:
+  virtual ~Writer();
+
+  virtual JSONCPP_STRING write(const Value& root) = 0;
+};
+
+/** \brief Outputs a Value in <a HREF="http://www.json.org">JSON</a> format
+ *without formatting (not human friendly).
+ *
+ * The JSON document is written in a single line. It is not intended for 'human'
+ *consumption,
+ * but may be usefull to support feature such as RPC where bandwith is limited.
+ * \sa Reader, Value
+ * \deprecated Use StreamWriterBuilder.
+ */
+class JSON_API FastWriter : public Writer {
+
+public:
+  FastWriter();
+  ~FastWriter() JSONCPP_OVERRIDE {}
+
+  void enableYAMLCompatibility();
+
+  /** \brief Drop the "null" string from the writer's output for nullValues.
+   * Strictly speaking, this is not valid JSON. But when the output is being
+   * fed to a browser's Javascript, it makes for smaller output and the
+   * browser can handle the output just fine.
+   */
+  void dropNullPlaceholders();
+
+  void omitEndingLineFeed();
+
+public: // overridden from Writer
+  JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;
+
+private:
+  void writeValue(const Value& value);
+
+  JSONCPP_STRING document_;
+  bool yamlCompatiblityEnabled_;
+  bool dropNullPlaceholders_;
+  bool omitEndingLineFeed_;
+};
+
+/** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
+ *human friendly way.
+ *
+ * The rules for line break and indent are as follow:
+ * - Object value:
+ *     - if empty then print {} without indent and line break
+ *     - if not empty the print '{', line break & indent, print one value per
+ *line
+ *       and then unindent and line break and print '}'.
+ * - Array value:
+ *     - if empty then print [] without indent and line break
+ *     - if the array contains no object value, empty array or some other value
+ *types,
+ *       and all the values fit on one lines, then print the array on a single
+ *line.
+ *     - otherwise, it the values do not fit on one line, or the array contains
+ *       object or non empty array, then print one value per line.
+ *
+ * If the Value have comments then they are outputed according to their
+ *#CommentPlacement.
+ *
+ * \sa Reader, Value, Value::setComment()
+ * \deprecated Use StreamWriterBuilder.
+ */
+class JSON_API StyledWriter : public Writer {
+public:
+  StyledWriter();
+  ~StyledWriter() JSONCPP_OVERRIDE {}
+
+public: // overridden from Writer
+  /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
+   * \param root Value to serialize.
+   * \return String containing the JSON document that represents the root value.
+   */
+  JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;
+
+private:
+  void writeValue(const Value& value);
+  void writeArrayValue(const Value& value);
+  bool isMultineArray(const Value& value);
+  void pushValue(const JSONCPP_STRING& value);
+  void writeIndent();
+  void writeWithIndent(const JSONCPP_STRING& value);
+  void indent();
+  void unindent();
+  void writeCommentBeforeValue(const Value& root);
+  void writeCommentAfterValueOnSameLine(const Value& root);
+  bool hasCommentForValue(const Value& value);
+  static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);
+
+  typedef std::vector<JSONCPP_STRING> ChildValues;
+
+  ChildValues childValues_;
+  JSONCPP_STRING document_;
+  JSONCPP_STRING indentString_;
+  unsigned int rightMargin_;
+  unsigned int indentSize_;
+  bool addChildValues_;
+};
+
+/** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
+ human friendly way,
+     to a stream rather than to a string.
+ *
+ * The rules for line break and indent are as follow:
+ * - Object value:
+ *     - if empty then print {} without indent and line break
+ *     - if not empty the print '{', line break & indent, print one value per
+ line
+ *       and then unindent and line break and print '}'.
+ * - Array value:
+ *     - if empty then print [] without indent and line break
+ *     - if the array contains no object value, empty array or some other value
+ types,
+ *       and all the values fit on one lines, then print the array on a single
+ line.
+ *     - otherwise, it the values do not fit on one line, or the array contains
+ *       object or non empty array, then print one value per line.
+ *
+ * If the Value have comments then they are outputed according to their
+ #CommentPlacement.
+ *
+ * \param indentation Each level will be indented by this amount extra.
+ * \sa Reader, Value, Value::setComment()
+ * \deprecated Use StreamWriterBuilder.
+ */
+class JSON_API StyledStreamWriter {
+public:
+  StyledStreamWriter(JSONCPP_STRING indentation = "\t");
+  ~StyledStreamWriter() {}
+
+public:
+  /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
+   * \param out Stream to write to. (Can be ostringstream, e.g.)
+   * \param root Value to serialize.
+   * \note There is no point in deriving from Writer, since write() should not
+   * return a value.
+   */
+  void write(JSONCPP_OSTREAM& out, const Value& root);
+
+private:
+  void writeValue(const Value& value);
+  void writeArrayValue(const Value& value);
+  bool isMultineArray(const Value& value);
+  void pushValue(const JSONCPP_STRING& value);
+  void writeIndent();
+  void writeWithIndent(const JSONCPP_STRING& value);
+  void indent();
+  void unindent();
+  void writeCommentBeforeValue(const Value& root);
+  void writeCommentAfterValueOnSameLine(const Value& root);
+  bool hasCommentForValue(const Value& value);
+  static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);
+
+  typedef std::vector<JSONCPP_STRING> ChildValues;
+
+  ChildValues childValues_;
+  JSONCPP_OSTREAM* document_;
+  JSONCPP_STRING indentString_;
+  unsigned int rightMargin_;
+  JSONCPP_STRING indentation_;
+  bool addChildValues_ : 1;
+  bool indented_ : 1;
+};
+
+#if defined(JSON_HAS_INT64)
+JSONCPP_STRING JSON_API valueToString(Int value);
+JSONCPP_STRING JSON_API valueToString(UInt value);
+#endif // if defined(JSON_HAS_INT64)
+JSONCPP_STRING JSON_API valueToString(LargestInt value);
+JSONCPP_STRING JSON_API valueToString(LargestUInt value);
+JSONCPP_STRING JSON_API valueToString(double value);
+JSONCPP_STRING JSON_API valueToString(bool value);
+JSONCPP_STRING JSON_API valueToQuotedString(const char* value);
+
+/// \brief Output using the StyledStreamWriter.
+/// \see Json::operator>>()
+JSON_API JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM&, const Value& root);
+
+} // namespace Json
+
+#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+#pragma warning(pop)
+#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
+
+#endif // JSON_WRITER_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/LICENSE polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/LICENSE
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/LICENSE	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/LICENSE	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,55 @@
+The JsonCpp library's source code, including accompanying documentation, 
+tests and demonstration applications, are licensed under the following
+conditions...
+
+The author (Baptiste Lepilleur) explicitly disclaims copyright in all 
+jurisdictions which recognize such a disclaimer. In such jurisdictions, 
+this software is released into the Public Domain.
+
+In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
+2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is
+released under the terms of the MIT License (see below).
+
+In jurisdictions which recognize Public Domain property, the user of this 
+software may choose to accept it either as 1) Public Domain, 2) under the 
+conditions of the MIT License (see below), or 3) under the terms of dual 
+Public Domain/MIT License conditions described here, as they choose.
+
+The MIT License is about as close to Public Domain as a license can get, and is
+described in clear, concise terms at:
+
+   http://en.wikipedia.org/wiki/MIT_License
+   
+The full text of the MIT License follows:
+
+========================================================================
+Copyright (c) 2007-2010 Baptiste Lepilleur
+
+Permission is hereby granted, free of charge, to any person
+obtaining a copy of this software and associated documentation
+files (the "Software"), to deal in the Software without
+restriction, including without limitation the rights to use, copy,
+modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+========================================================================
+(END LICENSE TEXT)
+
+The MIT license is compatible with both the GPL and commercial
+software, affording one all of the rights of Public Domain with the
+minor nuisance of being required to keep the above copyright notice
+and license text in the source code. Note also that by accepting the
+Public Domain "license" you can re-license your copy using whatever
+license you like.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/jsontest.vcproj polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/jsontest.vcproj
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/jsontest.vcproj	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/jsontest.vcproj	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,119 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="jsontest"
+	ProjectGUID="{25AF2DD2-D396-4668-B188-488C33B8E620}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../build/vs71/debug/jsontest"
+			IntermediateDirectory="../../build/vs71/debug/jsontest"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/jsontest.exe"
+				LinkIncremental="2"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/jsontest.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../build/vs71/release/jsontest"
+			IntermediateDirectory="../../build/vs71/release/jsontest"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/jsontest.exe"
+				LinkIncremental="1"
+				GenerateDebugInformation="TRUE"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\src\jsontestrunner\main.cpp">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/lib_json.vcproj polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/lib_json.vcproj
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/lib_json.vcproj	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/lib_json.vcproj	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,205 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="lib_json"
+	ProjectGUID="{B84F7231-16CE-41D8-8C08-7B523FF4225B}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../build/vs71/debug/lib_json"
+			IntermediateDirectory="../../build/vs71/debug/lib_json"
+			ConfigurationType="4"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				StringPooling="TRUE"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				EnableFunctionLevelLinking="TRUE"
+				DisableLanguageExtensions="TRUE"
+				ForceConformanceInForLoopScope="FALSE"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="$(OutDir)/json_vc71_libmtd.lib"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../build/vs71/release/lib_json"
+			IntermediateDirectory="../../build/vs71/release/lib_json"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="TRUE">
+			<Tool
+				Name="VCCLCompilerTool"
+				GlobalOptimizations="TRUE"
+				EnableIntrinsicFunctions="TRUE"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				DisableLanguageExtensions="TRUE"
+				ForceConformanceInForLoopScope="FALSE"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				AssemblerOutput="4"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="$(OutDir)/json_vc71_libmt.lib"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="dummy|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			WholeProgramOptimization="TRUE">
+			<Tool
+				Name="VCCLCompilerTool"
+				GlobalOptimizations="TRUE"
+				EnableIntrinsicFunctions="TRUE"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="4"
+				EnableFunctionLevelLinking="TRUE"
+				DisableLanguageExtensions="TRUE"
+				ForceConformanceInForLoopScope="FALSE"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				AssemblerOutput="4"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\include\json\autolink.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\config.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\features.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\forwards.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\json.h">
+		</File>
+		<File
+			RelativePath="..\..\src\lib_json\json_reader.cpp">
+		</File>
+		<File
+			RelativePath="..\..\src\lib_json\json_value.cpp">
+		</File>
+		<File
+			RelativePath="..\..\src\lib_json\json_valueiterator.inl">
+		</File>
+		<File
+			RelativePath="..\..\src\lib_json\json_writer.cpp">
+		</File>
+		<File
+			RelativePath="..\..\include\json\reader.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\value.h">
+		</File>
+		<File
+			RelativePath="..\..\include\json\writer.h">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/test_lib_json.vcproj polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/test_lib_json.vcproj
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/test_lib_json.vcproj	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makefiles/vs71/test_lib_json.vcproj	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="test_lib_json"
+	ProjectGUID="{B7A96B78-2782-40D2-8F37-A2DEF2B9C26D}"
+	RootNamespace="test_lib_json"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../build/vs71/debug/test_lib_json"
+			IntermediateDirectory="../../build/vs71/debug/test_lib_json"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/test_lib_json.exe"
+				LinkIncremental="2"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/test_lib_json.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				Description="Running all unit tests"
+				CommandLine="$(TargetPath)"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../build/vs71/release/test_lib_json"
+			IntermediateDirectory="../../build/vs71/release/test_lib_json"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/test_lib_json.exe"
+				LinkIncremental="1"
+				GenerateDebugInformation="TRUE"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				Description="Running all unit tests"
+				CommandLine="$(TargetPath)"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\src\test_lib_json\jsontest.cpp">
+		</File>
+		<File
+			RelativePath="..\..\src\test_lib_json\jsontest.h">
+		</File>
+		<File
+			RelativePath="..\..\src\test_lib_json\main.cpp">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makerelease.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makerelease.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/makerelease.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/makerelease.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,390 @@
+# Copyright 2010 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+"""Tag the sandbox for release, make source and doc tarballs.
+
+Requires Python 2.6
+
+Example of invocation (use to test the script):
+python makerelease.py --platform=msvc6,msvc71,msvc80,msvc90,mingw -ublep 0.6.0 0.7.0-dev
+
+When testing this script:
+python makerelease.py --force --retag --platform=msvc6,msvc71,msvc80,mingw -ublep test-0.6.0 test-0.6.1-dev
+
+Example of invocation when doing a release:
+python makerelease.py 0.5.0 0.6.0-dev
+
+Note: This was for Subversion. Now that we are in GitHub, we do not
+need to build versioned tarballs anymore, so makerelease.py is defunct.
+"""
+
+from __future__ import print_function
+import os.path
+import subprocess
+import sys
+import doxybuild
+import subprocess
+import xml.etree.ElementTree as ElementTree
+import shutil
+import urllib2
+import tempfile
+import os
+import time
+from devtools import antglob, fixeol, tarball
+import amalgamate
+
+SVN_ROOT = 'https://jsoncpp.svn.sourceforge.net/svnroot/jsoncpp/'
+SVN_TAG_ROOT = SVN_ROOT + 'tags/jsoncpp'
+SCONS_LOCAL_URL = 'http://sourceforge.net/projects/scons/files/scons-local/1.2.0/scons-local-1.2.0.tar.gz/download'
+SOURCEFORGE_PROJECT = 'jsoncpp'
+
+def set_version(version):
+    with open('version','wb') as f:
+        f.write(version.strip())
+
+def rmdir_if_exist(dir_path):
+    if os.path.isdir(dir_path):
+        shutil.rmtree(dir_path)
+
+class SVNError(Exception):
+    pass
+
+def svn_command(command, *args):
+    cmd = ['svn', '--non-interactive', command] + list(args)
+    print('Running:', ' '.join(cmd))
+    process = subprocess.Popen(cmd,
+                                stdout=subprocess.PIPE,
+                                stderr=subprocess.STDOUT)
+    stdout = process.communicate()[0]
+    if process.returncode:
+        error = SVNError('SVN command failed:\n' + stdout)
+        error.returncode = process.returncode
+        raise error
+    return stdout
+
+def check_no_pending_commit():
+    """Checks that there is no pending commit in the sandbox."""
+    stdout = svn_command('status', '--xml')
+    etree = ElementTree.fromstring(stdout)
+    msg = []
+    for entry in etree.getiterator('entry'):
+        path = entry.get('path')
+        status = entry.find('wc-status').get('item')
+        if status != 'unversioned' and path != 'version':
+            msg.append('File "%s" has pending change (status="%s")' % (path, status))
+    if msg:
+        msg.insert(0, 'Pending change to commit found in sandbox. Commit them first!')
+    return '\n'.join(msg)
+
+def svn_join_url(base_url, suffix):
+    if not base_url.endswith('/'):
+        base_url += '/'
+    if suffix.startswith('/'):
+        suffix = suffix[1:]
+    return base_url + suffix
+
+def svn_check_if_tag_exist(tag_url):
+    """Checks if a tag exist.
+    Returns: True if the tag exist, False otherwise.
+    """
+    try:
+        list_stdout = svn_command('list', tag_url)
+    except SVNError as e:
+        if e.returncode != 1 or not str(e).find('tag_url'):
+            raise e
+        # otherwise ignore error, meaning tag does not exist
+        return False
+    return True
+
+def svn_commit(message):
+    """Commit the sandbox, providing the specified comment.
+    """
+    svn_command('ci', '-m', message)
+
+def svn_tag_sandbox(tag_url, message):
+    """Makes a tag based on the sandbox revisions.
+    """
+    svn_command('copy', '-m', message, '.', tag_url)
+
+def svn_remove_tag(tag_url, message):
+    """Removes an existing tag.
+    """
+    svn_command('delete', '-m', message, tag_url)
+
+def svn_export(tag_url, export_dir):
+    """Exports the tag_url revision to export_dir.
+       Target directory, including its parent is created if it does not exist.
+       If the directory export_dir exist, it is deleted before export proceed.
+    """
+    rmdir_if_exist(export_dir)
+    svn_command('export', tag_url, export_dir)
+
+def fix_sources_eol(dist_dir):
+    """Set file EOL for tarball distribution.
+    """
+    print('Preparing exported source file EOL for distribution...')
+    prune_dirs = antglob.prune_dirs + 'scons-local* ./build* ./libs ./dist'
+    win_sources = antglob.glob(dist_dir, 
+        includes = '**/*.sln **/*.vcproj',
+        prune_dirs = prune_dirs)
+    unix_sources = antglob.glob(dist_dir,
+        includes = '''**/*.h **/*.cpp **/*.inl **/*.txt **/*.dox **/*.py **/*.html **/*.in
+        sconscript *.json *.expected AUTHORS LICENSE''',
+        excludes = antglob.default_excludes + 'scons.py sconsign.py scons-*',
+        prune_dirs = prune_dirs)
+    for path in win_sources:
+        fixeol.fix_source_eol(path, is_dry_run = False, verbose = True, eol = '\r\n')
+    for path in unix_sources:
+        fixeol.fix_source_eol(path, is_dry_run = False, verbose = True, eol = '\n')
+
+def download(url, target_path):
+    """Download file represented by url to target_path.
+    """
+    f = urllib2.urlopen(url)
+    try:
+        data = f.read()
+    finally:
+        f.close()
+    fout = open(target_path, 'wb')
+    try:
+        fout.write(data)
+    finally:
+        fout.close()
+
+def check_compile(distcheck_top_dir, platform):
+    cmd = [sys.executable, 'scons.py', 'platform=%s' % platform, 'check']
+    print('Running:', ' '.join(cmd))
+    log_path = os.path.join(distcheck_top_dir, 'build-%s.log' % platform)
+    flog = open(log_path, 'wb')
+    try:
+        process = subprocess.Popen(cmd,
+                                    stdout=flog,
+                                    stderr=subprocess.STDOUT,
+                                    cwd=distcheck_top_dir)
+        stdout = process.communicate()[0]
+        status = (process.returncode == 0)
+    finally:
+        flog.close()
+    return (status, log_path)
+
+def write_tempfile(content, **kwargs):
+    fd, path = tempfile.mkstemp(**kwargs)
+    f = os.fdopen(fd, 'wt')
+    try:
+        f.write(content)
+    finally:
+        f.close()
+    return path
+
+class SFTPError(Exception):
+    pass
+
+def run_sftp_batch(userhost, sftp, batch, retry=0):
+    path = write_tempfile(batch, suffix='.sftp', text=True)
+    # psftp -agent -C blep,jsoncpp@web.sourceforge.net -batch -b batch.sftp -bc
+    cmd = [sftp, '-agent', '-C', '-batch', '-b', path, '-bc', userhost]
+    error = None
+    for retry_index in range(0, max(1,retry)):
+        heading = retry_index == 0 and 'Running:' or 'Retrying:'
+        print(heading, ' '.join(cmd))
+        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+        stdout = process.communicate()[0]
+        if process.returncode != 0:
+            error = SFTPError('SFTP batch failed:\n' + stdout)
+        else:
+            break
+    if error:
+        raise error
+    return stdout
+
+def sourceforge_web_synchro(sourceforge_project, doc_dir,
+                             user=None, sftp='sftp'):
+    """Notes: does not synchronize sub-directory of doc-dir.
+    """
+    userhost = '%s,%s@web.sourceforge.net' % (user, sourceforge_project)
+    stdout = run_sftp_batch(userhost, sftp, """
+cd htdocs
+dir
+exit
+""")
+    existing_paths = set()
+    collect = 0
+    for line in stdout.split('\n'):
+        line = line.strip()
+        if not collect and line.endswith('> dir'):
+            collect = True
+        elif collect and line.endswith('> exit'):
+            break
+        elif collect == 1:
+            collect = 2
+        elif collect == 2:
+            path = line.strip().split()[-1:]
+            if path and path[0] not in ('.', '..'):
+                existing_paths.add(path[0])
+    upload_paths = set([os.path.basename(p) for p in antglob.glob(doc_dir)])
+    paths_to_remove = existing_paths - upload_paths
+    if paths_to_remove:
+        print('Removing the following file from web:')
+        print('\n'.join(paths_to_remove))
+        stdout = run_sftp_batch(userhost, sftp, """cd htdocs
+rm %s
+exit""" % ' '.join(paths_to_remove))
+    print('Uploading %d files:' % len(upload_paths))
+    batch_size = 10
+    upload_paths = list(upload_paths)
+    start_time = time.time()
+    for index in range(0,len(upload_paths),batch_size):
+        paths = upload_paths[index:index+batch_size]
+        file_per_sec = (time.time() - start_time) / (index+1)
+        remaining_files = len(upload_paths) - index
+        remaining_sec = file_per_sec * remaining_files
+        print('%d/%d, ETA=%.1fs' % (index+1, len(upload_paths), remaining_sec))
+        run_sftp_batch(userhost, sftp, """cd htdocs
+lcd %s
+mput %s
+exit""" % (doc_dir, ' '.join(paths)), retry=3)
+
+def sourceforge_release_tarball(sourceforge_project, paths, user=None, sftp='sftp'):
+    userhost = '%s,%s@frs.sourceforge.net' % (user, sourceforge_project)
+    run_sftp_batch(userhost, sftp, """
+mput %s
+exit
+""" % (' '.join(paths),))
+
+
+def main():
+    usage = """%prog release_version next_dev_version
+Update 'version' file to release_version and commit.
+Generates the document tarball.
+Tags the sandbox revision with release_version.
+Update 'version' file to next_dev_version and commit.
+
+Performs an svn export of tag release version, and build a source tarball.    
+
+Must be started in the project top directory.
+
+Warning: --force should only be used when developping/testing the release script.
+"""
+    from optparse import OptionParser
+    parser = OptionParser(usage=usage)
+    parser.allow_interspersed_args = False
+    parser.add_option('--dot', dest="dot_path", action='store', default=doxybuild.find_program('dot'),
+        help="""Path to GraphViz dot tool. Must be full qualified path. [Default: %default]""")
+    parser.add_option('--doxygen', dest="doxygen_path", action='store', default=doxybuild.find_program('doxygen'),
+        help="""Path to Doxygen tool. [Default: %default]""")
+    parser.add_option('--force', dest="ignore_pending_commit", action='store_true', default=False,
+        help="""Ignore pending commit. [Default: %default]""")
+    parser.add_option('--retag', dest="retag_release", action='store_true', default=False,
+        help="""Overwrite release existing tag if it exist. [Default: %default]""")
+    parser.add_option('-p', '--platforms', dest="platforms", action='store', default='',
+        help="""Comma separated list of platform passed to scons for build check.""")
+    parser.add_option('--no-test', dest="no_test", action='store_true', default=False,
+        help="""Skips build check.""")
+    parser.add_option('--no-web', dest="no_web", action='store_true', default=False,
+        help="""Do not update web site.""")
+    parser.add_option('-u', '--upload-user', dest="user", action='store',
+                      help="""Sourceforge user for SFTP documentation upload.""")
+    parser.add_option('--sftp', dest='sftp', action='store', default=doxybuild.find_program('psftp', 'sftp'),
+                      help="""Path of the SFTP compatible binary used to upload the documentation.""")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+
+    if len(args) != 2:
+        parser.error('release_version missing on command-line.')
+    release_version = args[0]
+    next_version = args[1]
+
+    if not options.platforms and not options.no_test:
+        parser.error('You must specify either --platform or --no-test option.')
+
+    if options.ignore_pending_commit:
+        msg = ''
+    else:
+        msg = check_no_pending_commit()
+    if not msg:
+        print('Setting version to', release_version)
+        set_version(release_version)
+        svn_commit('Release ' + release_version)
+        tag_url = svn_join_url(SVN_TAG_ROOT, release_version)
+        if svn_check_if_tag_exist(tag_url):
+            if options.retag_release:
+                svn_remove_tag(tag_url, 'Overwriting previous tag')
+            else:
+                print('Aborting, tag %s already exist. Use --retag to overwrite it!' % tag_url)
+                sys.exit(1)
+        svn_tag_sandbox(tag_url, 'Release ' + release_version)
+
+        print('Generated doxygen document...')
+##        doc_dirname = r'jsoncpp-api-html-0.5.0'
+##        doc_tarball_path = r'e:\prg\vc\Lib\jsoncpp-trunk\dist\jsoncpp-api-html-0.5.0.tar.gz'
+        doc_tarball_path, doc_dirname = doxybuild.build_doc(options, make_release=True)
+        doc_distcheck_dir = 'dist/doccheck'
+        tarball.decompress(doc_tarball_path, doc_distcheck_dir)
+        doc_distcheck_top_dir = os.path.join(doc_distcheck_dir, doc_dirname)
+        
+        export_dir = 'dist/export'
+        svn_export(tag_url, export_dir)
+        fix_sources_eol(export_dir)
+        
+        source_dir = 'jsoncpp-src-' + release_version
+        source_tarball_path = 'dist/%s.tar.gz' % source_dir
+        print('Generating source tarball to', source_tarball_path)
+        tarball.make_tarball(source_tarball_path, [export_dir], export_dir, prefix_dir=source_dir)
+
+        amalgamation_tarball_path = 'dist/%s-amalgamation.tar.gz' % source_dir
+        print('Generating amalgamation source tarball to', amalgamation_tarball_path)
+        amalgamation_dir = 'dist/amalgamation'
+        amalgamate.amalgamate_source(export_dir, '%s/jsoncpp.cpp' % amalgamation_dir, 'json/json.h')
+        amalgamation_source_dir = 'jsoncpp-src-amalgamation' + release_version
+        tarball.make_tarball(amalgamation_tarball_path, [amalgamation_dir],
+                              amalgamation_dir, prefix_dir=amalgamation_source_dir)
+
+        # Decompress source tarball, download and install scons-local
+        distcheck_dir = 'dist/distcheck'
+        distcheck_top_dir = distcheck_dir + '/' + source_dir
+        print('Decompressing source tarball to', distcheck_dir)
+        rmdir_if_exist(distcheck_dir)
+        tarball.decompress(source_tarball_path, distcheck_dir)
+        scons_local_path = 'dist/scons-local.tar.gz'
+        print('Downloading scons-local to', scons_local_path)
+        download(SCONS_LOCAL_URL, scons_local_path)
+        print('Decompressing scons-local to', distcheck_top_dir)
+        tarball.decompress(scons_local_path, distcheck_top_dir)
+
+        # Run compilation
+        print('Compiling decompressed tarball')
+        all_build_status = True
+        for platform in options.platforms.split(','):
+            print('Testing platform:', platform)
+            build_status, log_path = check_compile(distcheck_top_dir, platform)
+            print('see build log:', log_path)
+            print(build_status and '=> ok' or '=> FAILED')
+            all_build_status = all_build_status and build_status
+        if not build_status:
+            print('Testing failed on at least one platform, aborting...')
+            svn_remove_tag(tag_url, 'Removing tag due to failed testing')
+            sys.exit(1)
+        if options.user:
+            if not options.no_web:
+                print('Uploading documentation using user', options.user)
+                sourceforge_web_synchro(SOURCEFORGE_PROJECT, doc_distcheck_top_dir, user=options.user, sftp=options.sftp)
+                print('Completed documentation upload')
+            print('Uploading source and documentation tarballs for release using user', options.user)
+            sourceforge_release_tarball(SOURCEFORGE_PROJECT,
+                                         [source_tarball_path, doc_tarball_path],
+                                         user=options.user, sftp=options.sftp)
+            print('Source and doc release tarballs uploaded')
+        else:
+            print('No upload user specified. Web site and download tarbal were not uploaded.')
+            print('Tarball can be found at:', doc_tarball_path)
+
+        # Set next version number and commit            
+        set_version(next_version)
+        svn_commit('Released ' + release_version)
+    else:
+        sys.stderr.write(msg + '\n')
+ 
+if __name__ == '__main__':
+    main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/NEWS.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/NEWS.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/NEWS.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/NEWS.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,175 @@
+New in SVN
+----------
+
+ *  Updated the type system's behavior, in order to better support backwards
+    compatibility with code that was written before 64-bit integer support was
+    introduced. Here's how it works now:
+
+     *  isInt, isInt64, isUInt, and isUInt64 return true if and only if the
+        value can be exactly represented as that type. In particular, a value
+        constructed with a double like 17.0 will now return true for all of
+        these methods.
+
+     *  isDouble and isFloat now return true for all numeric values, since all
+        numeric values can be converted to a double or float without
+        truncation. Note however that the conversion may not be exact -- for
+        example, doubles cannot exactly represent all integers above 2^53 + 1.
+
+     *  isBool, isNull, isString, isArray, and isObject now return true if and
+        only if the value is of that type.
+
+     *  isConvertibleTo(fooValue) indicates that it is safe to call asFoo.
+        (For each type foo, isFoo always implies isConvertibleTo(fooValue).)
+        asFoo returns an approximate or exact representation as appropriate.
+        For example, a double value may be truncated when asInt is called.
+
+     *  For backwards compatibility with old code, isConvertibleTo(intValue)
+        may return false even if type() == intValue. This is because the value
+        may have been constructed with a 64-bit integer larger than maxInt,
+        and calling asInt() would cause an exception. If you're writing new
+        code, use isInt64 to find out whether the value is exactly
+        representable using an Int64, or asDouble() combined with minInt64 and
+        maxInt64 to figure out whether it is approximately representable.
+
+* Value
+  - Patch #10: BOOST_FOREACH compatibility. Made Json::iterator more 
+    standard compliant, added missing iterator_category and value_type 
+	typedefs (contribued by Robert A. Iannucci).
+		
+* Compilation
+
+  - New CMake based build system. Based in part on contribution from
+    Igor Okulist and Damien Buhl (Patch #14).
+    
+  - New header json/version.h now contains version number macros
+    (JSONCPP_VERSION_MAJOR, JSONCPP_VERSION_MINOR, JSONCPP_VERSION_PATCH
+    and JSONCPP_VERSION_HEXA).
+
+  - Patch #11: added missing JSON_API on some classes causing link issues
+    when building as a dynamic library on Windows 
+	(contributed by Francis Bolduc).
+    
+  - Visual Studio DLL: suppressed warning "C4251: <data member>: <type> 
+    needs to have dll-interface to be used by..." via pragma push/pop
+    in json-cpp headers.
+    
+  - Added Travis CI intregration: https://travis-ci.org/blep/jsoncpp-mirror
+		
+* Bug fixes
+  - Patch #15: Copy constructor does not initialize allocated_ for stringValue
+    (contributed by rmongia).
+
+  - Patch #16: Missing field copy in Json::Value::iterator causing infinite 
+    loop when using experimental internal map (#define JSON_VALUE_USE_INTERNAL_MAP)
+	(contributed by Ming-Lin Kao).
+		
+
+  New in JsonCpp 0.6.0:
+  ---------------------
+
+* Compilation
+
+  - LD_LIBRARY_PATH and LIBRARY_PATH environment variables are now 
+    propagated to the build environment as this is required for some 
+    compiler installation.
+
+  - Added support for Microsoft Visual Studio 2008 (bug #2930462): 
+    The platform "msvc90" has been added.
+
+    Notes: you need to setup the environment by running vcvars32.bat 
+    (e.g. MSVC 2008 command prompt in start menu) before running scons.
+    
+  - Added support for amalgamated source and header generation (a la sqlite).
+    Refer to README.md section "Generating amalgamated source and header"
+    for detail.
+    
+* Value
+
+  - Removed experimental ValueAllocator, it caused static 
+    initialization/destruction order issues (bug #2934500). 
+    The DefaultValueAllocator has been inlined in code.
+    
+  - Added support for 64 bits integer:
+  
+    Types Json::Int64 and Json::UInt64 have been added. They are aliased
+	to 64 bits integers on system that support them (based on __int64 on 
+	Microsoft Visual Studio platform, and long long on other platforms).
+	
+	Types Json::LargestInt and Json::LargestUInt have been added. They are
+	aliased to the largest integer type supported: 
+	either Json::Int/Json::UInt or Json::Int64/Json::UInt64 respectively.
+	
+	Json::Value::asInt() and Json::Value::asUInt() still returns plain
+	"int" based types, but asserts if an attempt is made to retrieve
+	a 64 bits value that can not represented as the return type.
+	
+	Json::Value::asInt64() and Json::Value::asUInt64() have been added
+	to obtain the 64 bits integer value.
+	
+	Json::Value::asLargestInt() and Json::Value::asLargestUInt() returns
+	the integer as a LargestInt/LargestUInt respectively. Those functions
+	functions are typically used when implementing writer.
+	
+	The reader attempts to read number as 64 bits integer, and fall back
+	to reading a double if the number is not in the range of 64 bits 
+	integer.
+    
+    Warning: Json::Value::asInt() and Json::Value::asUInt() now returns
+    long long. This changes break code that was passing the return value
+    to *printf() function.
+  
+    Support for 64 bits integer can be disabled by defining the macro 
+	JSON_NO_INT64 (uncomment it in json/config.h for example), though
+	it should have no impact on existing usage.
+    
+  - The type Json::ArrayIndex is used for indexes of a JSON value array. It
+    is an unsigned int (typically 32 bits).
+	
+  - Array index can be passed as int to operator[], allowing use of literal:
+    Json::Value array;
+	array.append( 1234 );
+	int value = array[0].asInt();  // did not compile previously
+
+  - Added float Json::Value::asFloat() to obtain a floating point value as a
+    float (avoid lost of precision warning caused by used of asDouble() 
+    to initialize a float).
+
+* Reader
+
+  - Renamed Reader::getFormatedErrorMessages() to getFormattedErrorMessages.
+    Bug #3023708 (Formatted has 2 't'). The old member function is deprecated
+    but still present for backward compatibility.
+    
+* Tests
+
+  - Added test to ensure that the escape sequence "\/" is corrected handled 
+    by the parser.
+
+* Bug fixes
+
+  - Bug #3139677: JSON [1 2 3] was incorrectly parsed as [1, 3]. Error is now 
+    correctly detected.
+    
+  - Bug #3139678: stack buffer overflow when parsing a double with a
+    length of 32 characters.
+	
+  - Fixed Value::operator <= implementation (had the semantic of operator >=).
+    Found when adding unit tests for comparison operators.
+    
+  - Value::compare() is now const and has an actual implementation with
+    unit tests.
+
+  - Bug #2407932: strpbrk() can fail for NULL pointer.
+
+  - Bug #3306345: Fixed minor typo in Path::resolve().
+
+  - Bug #3314841/#3306896: errors in amalgamate.py
+
+  - Fixed some Coverity warnings and line-endings.
+    
+* License
+  
+  - See file LICENSE for details. Basically JsonCpp is now licensed under 
+    MIT license, or public domain if desired and recognized in your jurisdiction.
+    Thanks to Stephan G. Beal [http://wanderinghorse.net/home/stephan/]) who
+	helped figuring out the solution to the public domain issue.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/pkg-config/jsoncpp.pc.in polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/pkg-config/jsoncpp.pc.in
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/pkg-config/jsoncpp.pc.in	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/pkg-config/jsoncpp.pc.in	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,11 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=${prefix}
+libdir=${exec_prefix}/@LIBRARY_INSTALL_DIR@
+includedir=${prefix}/@INCLUDE_INSTALL_DIR@
+
+Name: jsoncpp
+Description: A C++ library for interacting with JSON
+Version: @JSONCPP_VERSION@
+URL: https://github.com/open-source-parsers/jsoncpp
+Libs: -L${libdir} -ljsoncpp
+Cflags: -I${includedir}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/README.md polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/README.md
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/README.md	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/README.md	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,214 @@
+Introduction
+------------
+
+[JSON][json-org] is a lightweight data-interchange format. It can represent
+numbers, strings, ordered sequences of values, and collections of name/value
+pairs.
+
+[json-org]: http://json.org/
+
+[JsonCpp][] is a C++ library that allows manipulating JSON values, including
+serialization and deserialization to and from strings. It can also preserve
+existing comment in unserialization/serialization steps, making it a convenient
+format to store user input files.
+
+[JsonCpp]: http://open-source-parsers.github.io/jsoncpp-docs/doxygen/index.html
+
+## A note on backward-compatibility
+* `1.y.z` is built with C++11.
+* `0.y.z` can be used with older compilers.
+* Major versions maintain binary-compatibility.
+
+# Using JsonCpp in your project
+-----------------------------
+The recommended approach to integrating JsonCpp in your project is to include
+the [amalgamated source](#generating-amalgamated-source-and-header) (a single 
+`.cpp` file and two `.h` files) in your project, and compile and build as you 
+would any other source file. This ensures consistency of compilation flags and
+ABI compatibility, issues which arise when building shared or static 
+libraries. See the next section for instructions.
+  
+The `include/` should be added to your compiler include path. Jsoncpp headers
+should be included as follow:
+
+    #include <json/json.h>
+
+If JsonCpp was built as a dynamic library on Windows, then your project needs to
+define the macro `JSON_DLL`.
+
+Generating amalgamated source and header
+----------------------------------------
+JsonCpp is provided with a script to generate a single header and a single
+source file to ease inclusion into an existing project. The amalgamated source
+can be generated at any time by running the following command from the
+top-directory (this requires Python 2.6):
+
+    python amalgamate.py
+
+It is possible to specify header name. See the `-h` option for detail.
+
+By default, the following files are generated:
+* `dist/jsoncpp.cpp`: source file that needs to be added to your project.
+* `dist/json/json.h`: corresponding header file for use in your project. It is
+  equivalent to including `json/json.h` in non-amalgamated source. This header
+  only depends on standard headers.
+* `dist/json/json-forwards.h`: header that provides forward declaration of all
+  JsonCpp types.
+
+The amalgamated sources are generated by concatenating JsonCpp source in the
+correct order and defining the macro `JSON_IS_AMALGAMATION` to prevent inclusion
+of other headers.
+
+# Contributing to JsonCpp
+
+Building and testing with CMake
+-------------------------------
+[CMake][] is a C++ Makefiles/Solution generator. It is usually available on most
+Linux system as package. On Ubuntu:
+
+    sudo apt-get install cmake
+
+[CMake]: http://www.cmake.org
+
+Note that Python is also required to run the JSON reader/writer tests. If
+missing, the build will skip running those tests.
+
+When running CMake, a few parameters are required:
+
+* a build directory where the makefiles/solution are generated. It is also used
+  to store objects, libraries and executables files.
+* the generator to use: makefiles or Visual Studio solution? What version or
+  Visual Studio, 32 or 64 bits solution? 
+
+Steps for generating solution/makefiles using `cmake-gui`:
+
+* Make "source code" point to the source directory.
+* Make "where to build the binary" point to the directory to use for the build.
+* Click on the "Grouped" check box.
+* Review JsonCpp build options (tick `BUILD_SHARED_LIBS` to build as a
+  dynamic library).
+* Click the configure button at the bottom, then the generate button.
+* The generated solution/makefiles can be found in the binary directory.
+
+Alternatively, from the command-line on Unix in the source directory:
+
+    mkdir -p build/debug
+    cd build/debug
+    cmake -DCMAKE_BUILD_TYPE=debug -DBUILD_STATIC_LIBS=ON -DBUILD_SHARED_LIBS=OFF -DARCHIVE_INSTALL_DIR=. -G "Unix Makefiles" ../..
+    make
+
+Running `cmake -h` will display the list of available generators (passed using
+the `-G` option).
+
+By default CMake hides compilation commands. This can be modified by specifying
+`-DCMAKE_VERBOSE_MAKEFILE=true` when generating makefiles.
+
+Building and testing with SCons
+-------------------------------
+**Note:** The SCons-based build system is deprecated. Please use CMake; see the
+section above.
+
+JsonCpp can use [Scons][] as a build system. Note that SCons requires Python to
+be installed.
+
+[SCons]: http://www.scons.org/
+
+Invoke SCons as follows:
+
+    scons platform=$PLATFORM [TARGET]
+
+where `$PLATFORM` may be one of:
+
+* `suncc`: Sun C++ (Solaris)
+* `vacpp`: Visual Age C++ (AIX)
+* `mingw`
+* `msvc6`: Microsoft Visual Studio 6 service pack 5-6
+* `msvc70`: Microsoft Visual Studio 2002
+* `msvc71`: Microsoft Visual Studio 2003
+* `msvc80`: Microsoft Visual Studio 2005
+* `msvc90`: Microsoft Visual Studio 2008
+* `linux-gcc`: Gnu C++ (linux, also reported to work for Mac OS X)
+
+If you are building with Microsoft Visual Studio 2008, you need to set up the
+environment by running `vcvars32.bat` (e.g. MSVC 2008 command prompt) before
+running SCons.
+
+## Running the tests manually
+You need to run tests manually only if you are troubleshooting an issue.
+
+In the instructions below, replace `path/to/jsontest` with the path of the
+`jsontest` executable that was compiled on your platform.
+
+    cd test
+    # This will run the Reader/Writer tests
+    python runjsontests.py path/to/jsontest
+    
+    # This will run the Reader/Writer tests, using JSONChecker test suite
+    # (http://www.json.org/JSON_checker/).
+    # Notes: not all tests pass: JsonCpp is too lenient (for example,
+    # it allows an integer to start with '0'). The goal is to improve
+    # strict mode parsing to get all tests to pass.
+    python runjsontests.py --with-json-checker path/to/jsontest
+    
+    # This will run the unit tests (mostly Value)
+    python rununittests.py path/to/test_lib_json
+    
+    # You can run the tests using valgrind:
+    python rununittests.py --valgrind path/to/test_lib_json
+
+## Running the tests using scons
+Note that tests can be run using SCons using the `check` target:
+
+    scons platform=$PLATFORM check
+
+Building the documentation
+--------------------------
+Run the Python script `doxybuild.py` from the top directory:
+
+    python doxybuild.py --doxygen=$(which doxygen) --open --with-dot
+
+See `doxybuild.py --help` for options.
+
+Adding a reader/writer test
+---------------------------
+To add a test, you need to create two files in test/data:
+
+* a `TESTNAME.json` file, that contains the input document in JSON format.
+* a `TESTNAME.expected` file, that contains a flatened representation of the
+  input document.
+
+The `TESTNAME.expected` file format is as follows:
+
+* each line represents a JSON element of the element tree represented by the
+  input document.
+* each line has two parts: the path to access the element separated from the
+  element value by `=`. Array and object values are always empty (i.e.
+  represented by either `[]` or `{}`).
+* element path: `.` represents the root element, and is used to separate object
+  members. `[N]` is used to specify the value of an array element at index `N`.
+
+See the examples `test_complex_01.json` and `test_complex_01.expected` to better
+understand element paths.
+
+Understanding reader/writer test output
+---------------------------------------
+When a test is run, output files are generated beside the input test files.
+Below is a short description of the content of each file:
+
+* `test_complex_01.json`: input JSON document.
+* `test_complex_01.expected`: flattened JSON element tree used to check if
+  parsing was corrected.
+* `test_complex_01.actual`: flattened JSON element tree produced by `jsontest`
+  from reading `test_complex_01.json`.
+* `test_complex_01.rewrite`: JSON document written by `jsontest` using the
+  `Json::Value` parsed from `test_complex_01.json` and serialized using
+  `Json::StyledWritter`.
+* `test_complex_01.actual-rewrite`: flattened JSON element tree produced by
+  `jsontest` from reading `test_complex_01.rewrite`.
+* `test_complex_01.process-output`: `jsontest` output, typically useful for
+  understanding parsing errors.
+
+License
+-------
+See the `LICENSE` file for details. In summary, JsonCpp is licensed under the
+MIT license, or public domain if desired and recognized in your jurisdiction.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/globtool.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/globtool.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/globtool.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/globtool.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,58 @@
+# Copyright 2009 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+import fnmatch
+import os
+
+def generate(env): 
+   def Glob(env, includes = None, excludes = None, dir = '.'):
+      """Adds Glob(includes = Split('*'), excludes = None, dir = '.')
+       helper function to environment.
+
+       Glob both the file-system files.
+
+       includes: list of file name pattern included in the return list when matched.
+       excludes: list of file name pattern exluced from the return list.
+
+       Example:
+       sources = env.Glob(("*.cpp", '*.h'), "~*.cpp", "#src")
+      """
+      def filterFilename(path):
+         abs_path = os.path.join(dir, path)
+         if not os.path.isfile(abs_path):
+            return 0
+         fn = os.path.basename(path)
+         match = 0
+         for include in includes:
+            if fnmatch.fnmatchcase(fn, include):
+               match = 1
+               break
+         if match == 1 and not excludes is None:
+            for exclude in excludes:
+               if fnmatch.fnmatchcase(fn, exclude):
+                  match = 0
+                  break
+         return match
+      if includes is None:
+         includes = ('*',)
+      elif type(includes) in (type(''), type(u'')):
+         includes = (includes,)
+      if type(excludes) in (type(''), type(u'')):
+         excludes = (excludes,)
+      dir = env.Dir(dir).abspath
+      paths = os.listdir(dir)
+      def makeAbsFileNode(path):
+         return env.File(os.path.join(dir, path))
+      nodes = filter(filterFilename, paths)
+      return map(makeAbsFileNode, nodes)
+
+   from SCons.Script import Environment
+   Environment.Glob = Glob
+
+def exists(env):
+    """
+    Tool always exists.
+    """
+    return True
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/srcdist.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/srcdist.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/srcdist.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/srcdist.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,183 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+import os
+import os.path
+from fnmatch import fnmatch
+import targz
+
+##def DoxyfileParse(file_contents):
+##   """
+##   Parse a Doxygen source file and return a dictionary of all the values.
+##   Values will be strings and lists of strings.
+##   """
+##   data = {}
+##
+##   import shlex
+##   lex = shlex.shlex(instream = file_contents, posix = True)
+##   lex.wordchars += "*+./-:"
+##   lex.whitespace = lex.whitespace.replace("\n", "")
+##   lex.escape = ""
+##
+##   lineno = lex.lineno
+##   last_backslash_lineno = lineno
+##   token = lex.get_token()
+##   key = token   # the first token should be a key
+##   last_token = ""
+##   key_token = False
+##   next_key = False
+##   new_data = True
+##
+##   def append_data(data, key, new_data, token):
+##      if new_data or len(data[key]) == 0:
+##         data[key].append(token)
+##      else:
+##         data[key][-1] += token
+##
+##   while token:
+##      if token in ['\n']:
+##         if last_token not in ['\\']:
+##            key_token = True
+##      elif token in ['\\']:
+##         pass
+##      elif key_token:
+##         key = token
+##         key_token = False
+##      else:
+##         if token == "+=":
+##            if not data.has_key(key):
+##               data[key] = list()
+##         elif token == "=":
+##            data[key] = list()
+##         else:
+##            append_data(data, key, new_data, token)
+##            new_data = True
+##
+##      last_token = token
+##      token = lex.get_token()
+##      
+##      if last_token == '\\' and token != '\n':
+##         new_data = False
+##         append_data(data, key, new_data, '\\')
+##
+##   # compress lists of len 1 into single strings
+##   for (k, v) in data.items():
+##      if len(v) == 0:
+##         data.pop(k)
+##
+##      # items in the following list will be kept as lists and not converted to strings
+##      if k in ["INPUT", "FILE_PATTERNS", "EXCLUDE_PATTERNS"]:
+##         continue
+##
+##      if len(v) == 1:
+##         data[k] = v[0]
+##
+##   return data
+##
+##def DoxySourceScan(node, env, path):
+##   """
+##   Doxygen Doxyfile source scanner.  This should scan the Doxygen file and add
+##   any files used to generate docs to the list of source files.
+##   """
+##   default_file_patterns = [
+##      '*.c', '*.cc', '*.cxx', '*.cpp', '*.c++', '*.java', '*.ii', '*.ixx',
+##      '*.ipp', '*.i++', '*.inl', '*.h', '*.hh ', '*.hxx', '*.hpp', '*.h++',
+##      '*.idl', '*.odl', '*.cs', '*.php', '*.php3', '*.inc', '*.m', '*.mm',
+##      '*.py',
+##   ]
+##
+##   default_exclude_patterns = [
+##      '*~',
+##   ]
+##
+##   sources = []
+##
+##   data = DoxyfileParse(node.get_contents())
+##
+##   if data.get("RECURSIVE", "NO") == "YES":
+##      recursive = True
+##   else:
+##      recursive = False
+##
+##   file_patterns = data.get("FILE_PATTERNS", default_file_patterns)
+##   exclude_patterns = data.get("EXCLUDE_PATTERNS", default_exclude_patterns)
+##
+##   for node in data.get("INPUT", []):
+##      if os.path.isfile(node):
+##         sources.add(node)
+##      elif os.path.isdir(node):
+##         if recursive:
+##            for root, dirs, files in os.walk(node):
+##               for f in files:
+##                  filename = os.path.join(root, f)
+##
+##                  pattern_check = reduce(lambda x, y: x or bool(fnmatch(filename, y)), file_patterns, False)
+##                  exclude_check = reduce(lambda x, y: x and fnmatch(filename, y), exclude_patterns, True)
+##
+##                  if pattern_check and not exclude_check:
+##                     sources.append(filename)
+##         else:
+##            for pattern in file_patterns:
+##               sources.extend(glob.glob("/".join([node, pattern])))
+##   sources = map(lambda path: env.File(path), sources)
+##   return sources
+##
+##
+##def DoxySourceScanCheck(node, env):
+##   """Check if we should scan this file"""
+##   return os.path.isfile(node.path)
+
+def srcDistEmitter(source, target, env):
+##   """Doxygen Doxyfile emitter"""
+##   # possible output formats and their default values and output locations
+##   output_formats = {
+##      "HTML": ("YES", "html"),
+##      "LATEX": ("YES", "latex"),
+##      "RTF": ("NO", "rtf"),
+##      "MAN": ("YES", "man"),
+##      "XML": ("NO", "xml"),
+##   }
+##
+##   data = DoxyfileParse(source[0].get_contents())
+##
+##   targets = []
+##   out_dir = data.get("OUTPUT_DIRECTORY", ".")
+##
+##   # add our output locations
+##   for (k, v) in output_formats.items():
+##      if data.get("GENERATE_" + k, v[0]) == "YES":
+##         targets.append(env.Dir(os.path.join(out_dir, data.get(k + "_OUTPUT", v[1]))))
+##
+##   # don't clobber targets
+##   for node in targets:
+##      env.Precious(node)
+##
+##   # set up cleaning stuff
+##   for node in targets:
+##      env.Clean(node, node)
+##
+##   return (targets, source)
+   return (target,source)
+
+def generate(env):
+   """
+   Add builders and construction variables for the
+   SrcDist tool.
+   """
+##   doxyfile_scanner = env.Scanner(##      DoxySourceScan,
+##      "DoxySourceScan",
+##      scan_check = DoxySourceScanCheck,
+##)
+
+   if targz.exists(env):
+      srcdist_builder = targz.makeBuilder(srcDistEmitter)
+
+      env['BUILDERS']['SrcDist'] = srcdist_builder
+
+def exists(env):
+   """
+   Make sure srcdist exists.
+   """
+   return targz.exists(env)
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/substinfile.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/substinfile.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/substinfile.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/substinfile.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,85 @@
+# Copyright 2010 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+import re
+from SCons.Script import *  # the usual scons stuff you get in a SConscript
+import collections
+
+def generate(env):
+    """
+    Add builders and construction variables for the
+    SubstInFile tool.
+
+    Adds SubstInFile builder, which substitutes the keys->values of SUBST_DICT
+    from the source to the target.
+    The values of SUBST_DICT first have any construction variables expanded
+    (its keys are not expanded).
+    If a value of SUBST_DICT is a python callable function, it is called and
+    the result is expanded as the value.
+    If there's more than one source and more than one target, each target gets
+    substituted from the corresponding source.
+    """
+    def do_subst_in_file(targetfile, sourcefile, dict):
+        """Replace all instances of the keys of dict with their values.
+        For example, if dict is {'%VERSION%': '1.2345', '%BASE%': 'MyProg'},
+        then all instances of %VERSION% in the file will be replaced with 1.2345 etc.
+        """
+        try:
+            f = open(sourcefile, 'rb')
+            contents = f.read()
+            f.close()
+        except:
+            raise SCons.Errors.UserError("Can't read source file %s"%sourcefile)
+        for (k,v) in list(dict.items()):
+            contents = re.sub(k, v, contents)
+        try:
+            f = open(targetfile, 'wb')
+            f.write(contents)
+            f.close()
+        except:
+            raise SCons.Errors.UserError("Can't write target file %s"%targetfile)
+        return 0 # success
+
+    def subst_in_file(target, source, env):
+        if 'SUBST_DICT' not in env:
+            raise SCons.Errors.UserError("SubstInFile requires SUBST_DICT to be set.")
+        d = dict(env['SUBST_DICT']) # copy it
+        for (k,v) in list(d.items()):
+            if isinstance(v, collections.Callable):
+                d[k] = env.subst(v()).replace('\\','\\\\')
+            elif SCons.Util.is_String(v):
+                d[k] = env.subst(v).replace('\\','\\\\')
+            else:
+                raise SCons.Errors.UserError("SubstInFile: key %s: %s must be a string or callable"%(k, repr(v)))
+        for (t,s) in zip(target, source):
+            return do_subst_in_file(str(t), str(s), d)
+
+    def subst_in_file_string(target, source, env):
+        """This is what gets printed on the console."""
+        return '\n'.join(['Substituting vars from %s into %s'%(str(s), str(t))
+                          for (t,s) in zip(target, source)])
+
+    def subst_emitter(target, source, env):
+        """Add dependency from substituted SUBST_DICT to target.
+        Returns original target, source tuple unchanged.
+        """
+        d = env['SUBST_DICT'].copy() # copy it
+        for (k,v) in list(d.items()):
+            if isinstance(v, collections.Callable):
+                d[k] = env.subst(v())
+            elif SCons.Util.is_String(v):
+                d[k]=env.subst(v)
+        Depends(target, SCons.Node.Python.Value(d))
+        return target, source
+
+##    env.Append(TOOLS = 'substinfile')       # this should be automaticaly done by Scons ?!?
+    subst_action = SCons.Action.Action(subst_in_file, subst_in_file_string)
+    env['BUILDERS']['SubstInFile'] = Builder(action=subst_action, emitter=subst_emitter)
+
+def exists(env):
+    """
+    Make sure tool exists.
+    """
+    return True
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/targz.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/targz.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/targz.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/scons-tools/targz.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,87 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+"""tarball
+
+Tool-specific initialization for tarball.
+
+"""
+
+## Commands to tackle a command based implementation:
+##to unpack on the fly...
+##gunzip < FILE.tar.gz | tar xvf -
+##to pack on the fly...
+##tar cvf - FILE-LIST | gzip -c > FILE.tar.gz 
+
+import os.path
+
+import SCons.Builder
+import SCons.Node.FS
+import SCons.Util
+
+try:
+    import gzip
+    import tarfile
+    internal_targz = 1
+except ImportError:
+    internal_targz = 0
+
+TARGZ_DEFAULT_COMPRESSION_LEVEL = 9
+
+if internal_targz:
+    def targz(target, source, env):
+        def archive_name(path):
+            path = os.path.normpath(os.path.abspath(path))
+            common_path = os.path.commonprefix((base_dir, path))
+            archive_name = path[len(common_path):]
+            return archive_name
+            
+        def visit(tar, dirname, names):
+            for name in names:
+                path = os.path.join(dirname, name)
+                if os.path.isfile(path):
+                    tar.add(path, archive_name(path))
+        compression = env.get('TARGZ_COMPRESSION_LEVEL',TARGZ_DEFAULT_COMPRESSION_LEVEL)
+        base_dir = os.path.normpath(env.get('TARGZ_BASEDIR', env.Dir('.')).abspath)
+        target_path = str(target[0])
+        fileobj = gzip.GzipFile(target_path, 'wb', compression)
+        tar = tarfile.TarFile(os.path.splitext(target_path)[0], 'w', fileobj)
+        for source in source:
+            source_path = str(source)
+            if source.isdir():
+                os.path.walk(source_path, visit, tar)
+            else:
+                tar.add(source_path, archive_name(source_path))      # filename, arcname
+        tar.close()
+
+    targzAction = SCons.Action.Action(targz, varlist=['TARGZ_COMPRESSION_LEVEL','TARGZ_BASEDIR'])
+
+    def makeBuilder(emitter = None):
+        return SCons.Builder.Builder(action = SCons.Action.Action('$TARGZ_COM', '$TARGZ_COMSTR'),
+                                     source_factory = SCons.Node.FS.Entry,
+                                     source_scanner = SCons.Defaults.DirScanner,
+                                     suffix = '$TARGZ_SUFFIX',
+                                     multi = 1)
+    TarGzBuilder = makeBuilder()
+
+    def generate(env):
+        """Add Builders and construction variables for zip to an Environment.
+           The following environnement variables may be set:
+           TARGZ_COMPRESSION_LEVEL: integer, [0-9]. 0: no compression, 9: best compression (same as gzip compression level).
+           TARGZ_BASEDIR: base-directory used to determine archive name (this allow archive name to be relative
+                          to something other than top-dir).
+        """
+        env['BUILDERS']['TarGz'] = TarGzBuilder
+        env['TARGZ_COM'] = targzAction
+        env['TARGZ_COMPRESSION_LEVEL'] = TARGZ_DEFAULT_COMPRESSION_LEVEL # range 0-9
+        env['TARGZ_SUFFIX']  = '.tar.gz'
+        env['TARGZ_BASEDIR'] = env.Dir('.')     # Sources archive name are made relative to that directory.
+else:
+    def generate(env):
+        pass
+
+
+def exists(env):
+    return internal_targz
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/SConstruct polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/SConstruct
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/SConstruct	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/SConstruct	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,248 @@
+"""
+Notes: 
+- shared library support is buggy: it assumes that a static and dynamic library can be build from the same object files. This is not true on many platforms. For this reason it is only enabled on linux-gcc at the current time.
+
+To add a platform:
+- add its name in options allowed_values below
+- add tool initialization for this platform. Search for "if platform == 'suncc'" as an example.
+"""
+
+import os
+import os.path
+import sys
+
+JSONCPP_VERSION = open(File('#version').abspath,'rt').read().strip()
+DIST_DIR = '#dist'
+
+options = Variables()
+options.Add( EnumVariable('platform',
+                        'Platform (compiler/stl) used to build the project',
+                        'msvc71',
+                        allowed_values='suncc vacpp mingw msvc6 msvc7 msvc71 msvc80 msvc90 linux-gcc'.split(),
+                        ignorecase=2) )
+
+try:
+    platform = ARGUMENTS['platform']
+    if platform == 'linux-gcc':
+        CXX = 'g++' # not quite right, but env is not yet available.
+        import commands
+        version = commands.getoutput('%s -dumpversion' %CXX)
+        platform = 'linux-gcc-%s' %version
+        print "Using platform '%s'" %platform
+        LD_LIBRARY_PATH = os.environ.get('LD_LIBRARY_PATH', '')
+        LD_LIBRARY_PATH = "%s:libs/%s" %(LD_LIBRARY_PATH, platform)
+        os.environ['LD_LIBRARY_PATH'] = LD_LIBRARY_PATH
+        print "LD_LIBRARY_PATH =", LD_LIBRARY_PATH
+except KeyError:
+    print 'You must specify a "platform"'
+    sys.exit(2)
+
+print "Building using PLATFORM =", platform
+
+rootbuild_dir = Dir('#buildscons')
+build_dir = os.path.join( '#buildscons', platform )
+bin_dir = os.path.join( '#bin', platform )
+lib_dir = os.path.join( '#libs', platform )
+sconsign_dir_path = Dir(build_dir).abspath
+sconsign_path = os.path.join( sconsign_dir_path, '.sconsign.dbm' )
+
+# Ensure build directory exist (SConsignFile fail otherwise!)
+if not os.path.exists( sconsign_dir_path ):
+    os.makedirs( sconsign_dir_path )
+
+# Store all dependencies signature in a database
+SConsignFile( sconsign_path )
+
+def make_environ_vars():
+	"""Returns a dictionnary with environment variable to use when compiling."""
+	# PATH is required to find the compiler
+	# TEMP is required for at least mingw
+    # LD_LIBRARY_PATH & co is required on some system for the compiler
+	vars = {}
+	for name in ('PATH', 'TEMP', 'TMP', 'LD_LIBRARY_PATH', 'LIBRARY_PATH'):
+		if name in os.environ:
+			vars[name] = os.environ[name]
+	return vars
+	
+
+env = Environment( ENV = make_environ_vars(),
+                   toolpath = ['scons-tools'],
+                   tools=[] ) #, tools=['default'] )
+
+if platform == 'suncc':
+    env.Tool( 'sunc++' )
+    env.Tool( 'sunlink' )
+    env.Tool( 'sunar' )
+    env.Append( CCFLAGS = ['-mt'] )
+elif platform == 'vacpp':
+    env.Tool( 'default' )
+    env.Tool( 'aixcc' )
+    env['CXX'] = 'xlC_r'   #scons does not pick-up the correct one !
+    # using xlC_r ensure multi-threading is enabled:
+    # http://publib.boulder.ibm.com/infocenter/pseries/index.jsp?topic=/com.ibm.vacpp7a.doc/compiler/ref/cuselect.htm
+    env.Append( CCFLAGS = '-qrtti=all',
+                LINKFLAGS='-bh:5' )  # -bh:5 remove duplicate symbol warning
+elif platform == 'msvc6':
+    env['MSVS_VERSION']='6.0'
+    for tool in ['msvc', 'msvs', 'mslink', 'masm', 'mslib']:
+        env.Tool( tool )
+    env['CXXFLAGS']='-GR -GX /nologo /MT'
+elif platform == 'msvc70':
+    env['MSVS_VERSION']='7.0'
+    for tool in ['msvc', 'msvs', 'mslink', 'masm', 'mslib']:
+        env.Tool( tool )
+    env['CXXFLAGS']='-GR -GX /nologo /MT'
+elif platform == 'msvc71':
+    env['MSVS_VERSION']='7.1'
+    for tool in ['msvc', 'msvs', 'mslink', 'masm', 'mslib']:
+        env.Tool( tool )
+    env['CXXFLAGS']='-GR -GX /nologo /MT'
+elif platform == 'msvc80':
+    env['MSVS_VERSION']='8.0'
+    for tool in ['msvc', 'msvs', 'mslink', 'masm', 'mslib']:
+        env.Tool( tool )
+    env['CXXFLAGS']='-GR -EHsc /nologo /MT'
+elif platform == 'msvc90':
+    env['MSVS_VERSION']='9.0'
+    # Scons 1.2 fails to detect the correct location of the platform SDK.
+    # So we propagate those from the environment. This requires that the
+    # user run vcvars32.bat before compiling.
+    if 'INCLUDE' in os.environ:
+        env['ENV']['INCLUDE'] = os.environ['INCLUDE']
+    if 'LIB' in os.environ:
+        env['ENV']['LIB'] = os.environ['LIB']
+    for tool in ['msvc', 'msvs', 'mslink', 'masm', 'mslib']:
+        env.Tool( tool )
+    env['CXXFLAGS']='-GR -EHsc /nologo /MT'
+elif platform == 'mingw':
+    env.Tool( 'mingw' )
+    env.Append( CPPDEFINES=[ "WIN32", "NDEBUG", "_MT" ] )
+elif platform.startswith('linux-gcc'):
+    env.Tool( 'default' )
+    env.Append( LIBS = ['pthread'], CCFLAGS = os.environ.get("CXXFLAGS", "-Wall"), LINKFLAGS=os.environ.get("LDFLAGS", "") )
+    env['SHARED_LIB_ENABLED'] = True
+else:
+    print "UNSUPPORTED PLATFORM."
+    env.Exit(1)
+
+env.Tool('targz')
+env.Tool('srcdist')
+env.Tool('globtool')
+
+env.Append( CPPPATH = ['#include'],
+            LIBPATH = lib_dir )
+short_platform = platform
+if short_platform.startswith('msvc'):
+    short_platform = short_platform[2:]
+# Notes: on Windows you need to rebuild the source for each variant
+# Build script does not support that yet so we only build static libraries.
+# This also fails on AIX because both dynamic and static library ends with
+# extension .a.
+env['SHARED_LIB_ENABLED'] = env.get('SHARED_LIB_ENABLED', False)
+env['LIB_PLATFORM'] = short_platform
+env['LIB_LINK_TYPE'] = 'lib'    # static
+env['LIB_CRUNTIME'] = 'mt'
+env['LIB_NAME_SUFFIX'] = '${LIB_PLATFORM}_${LIB_LINK_TYPE}${LIB_CRUNTIME}'  # must match autolink naming convention
+env['JSONCPP_VERSION'] = JSONCPP_VERSION
+env['BUILD_DIR'] = env.Dir(build_dir)
+env['ROOTBUILD_DIR'] = env.Dir(rootbuild_dir)
+env['DIST_DIR'] = DIST_DIR
+if 'TarGz' in env['BUILDERS']:
+	class SrcDistAdder:
+		def __init__( self, env ):
+			self.env = env
+		def __call__( self, *args, **kw ):
+			apply( self.env.SrcDist, (self.env['SRCDIST_TARGET'],) + args, kw )
+	env['SRCDIST_BUILDER'] = env.TarGz
+else: # If tarfile module is missing
+	class SrcDistAdder:
+		def __init__( self, env ):
+			pass
+		def __call__( self, *args, **kw ):
+			pass
+env['SRCDIST_ADD'] = SrcDistAdder( env )
+env['SRCDIST_TARGET'] = os.path.join( DIST_DIR, 'jsoncpp-src-%s.tar.gz' % env['JSONCPP_VERSION'] )
+                      
+env_testing = env.Clone( )
+env_testing.Append( LIBS = ['json_${LIB_NAME_SUFFIX}'] )
+
+def buildJSONExample( env, target_sources, target_name ):
+    env = env.Clone()
+    env.Append( CPPPATH = ['#'] )
+    exe = env.Program( target=target_name,
+                       source=target_sources )
+    env['SRCDIST_ADD']( source=[target_sources] )
+    global bin_dir
+    return env.Install( bin_dir, exe )
+
+def buildJSONTests( env, target_sources, target_name ):
+    jsontests_node = buildJSONExample( env, target_sources, target_name )
+    check_alias_target = env.Alias( 'check', jsontests_node, RunJSONTests( jsontests_node, jsontests_node ) )
+    env.AlwaysBuild( check_alias_target )
+
+def buildUnitTests( env, target_sources, target_name ):
+    jsontests_node = buildJSONExample( env, target_sources, target_name )
+    check_alias_target = env.Alias( 'check', jsontests_node, 
+                                    RunUnitTests( jsontests_node, jsontests_node ) )
+    env.AlwaysBuild( check_alias_target )
+
+def buildLibrary( env, target_sources, target_name ):
+    static_lib = env.StaticLibrary( target=target_name + '_${LIB_NAME_SUFFIX}',
+                                    source=target_sources )
+    global lib_dir
+    env.Install( lib_dir, static_lib )
+    if env['SHARED_LIB_ENABLED']:
+        shared_lib = env.SharedLibrary( target=target_name + '_${LIB_NAME_SUFFIX}',
+                                        source=target_sources )
+        env.Install( lib_dir, shared_lib )
+    env['SRCDIST_ADD']( source=[target_sources] )
+
+Export( 'env env_testing buildJSONExample buildLibrary buildJSONTests buildUnitTests' )
+
+def buildProjectInDirectory( target_directory ):
+    global build_dir
+    target_build_dir = os.path.join( build_dir, target_directory )
+    target = os.path.join( target_directory, 'sconscript' )
+    SConscript( target, build_dir=target_build_dir, duplicate=0 )
+    env['SRCDIST_ADD']( source=[target] )
+
+
+def runJSONTests_action( target, source = None, env = None ):
+    # Add test scripts to python path
+    jsontest_path = Dir( '#test' ).abspath
+    sys.path.insert( 0, jsontest_path )
+    data_path = os.path.join( jsontest_path, 'data' )
+    import runjsontests
+    return runjsontests.runAllTests( os.path.abspath(source[0].path), data_path )
+
+def runJSONTests_string( target, source = None, env = None ):
+    return 'RunJSONTests("%s")' % source[0]
+
+import SCons.Action
+ActionFactory = SCons.Action.ActionFactory
+RunJSONTests = ActionFactory(runJSONTests_action, runJSONTests_string )
+
+def runUnitTests_action( target, source = None, env = None ):
+    # Add test scripts to python path
+    jsontest_path = Dir( '#test' ).abspath
+    sys.path.insert( 0, jsontest_path )
+    import rununittests
+    return rununittests.runAllTests( os.path.abspath(source[0].path) )
+
+def runUnitTests_string( target, source = None, env = None ):
+    return 'RunUnitTests("%s")' % source[0]
+
+RunUnitTests = ActionFactory(runUnitTests_action, runUnitTests_string )
+
+env.Alias( 'check' )
+
+srcdist_cmd = env['SRCDIST_ADD']( source = """
+    AUTHORS README.md SConstruct
+    """.split() )
+env.Alias( 'src-dist', srcdist_cmd )
+
+buildProjectInDirectory( 'src/jsontestrunner' )
+buildProjectInDirectory( 'src/lib_json' )
+buildProjectInDirectory( 'src/test_lib_json' )
+#print env.Dump()
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,5 @@
+ADD_SUBDIRECTORY(lib_json)
+IF(JSONCPP_WITH_TESTS)
+    ADD_SUBDIRECTORY(jsontestrunner)
+    ADD_SUBDIRECTORY(test_lib_json)
+ENDIF()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,25 @@
+FIND_PACKAGE(PythonInterp 2.6)
+
+ADD_EXECUTABLE(jsontestrunner_exe
+               main.cpp
+               )
+
+IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS( -DJSON_DLL )
+    TARGET_LINK_LIBRARIES(jsontestrunner_exe jsoncpp_lib)
+ELSE(BUILD_SHARED_LIBS)
+    TARGET_LINK_LIBRARIES(jsontestrunner_exe jsoncpp_lib_static)
+ENDIF()
+
+SET_TARGET_PROPERTIES(jsontestrunner_exe PROPERTIES OUTPUT_NAME jsontestrunner_exe)
+
+IF(PYTHONINTERP_FOUND)
+    # Run end to end parser/writer tests
+    SET(TEST_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../test)
+    SET(RUNJSONTESTS_PATH ${TEST_DIR}/runjsontests.py)
+    ADD_CUSTOM_TARGET(jsoncpp_readerwriter_tests
+                      "${PYTHON_EXECUTABLE}" -B "${RUNJSONTESTS_PATH}" $<TARGET_FILE:jsontestrunner_exe> "${TEST_DIR}/data"
+                      DEPENDS jsontestrunner_exe jsoncpp_test
+                      )
+    ADD_CUSTOM_TARGET(jsoncpp_check DEPENDS jsoncpp_readerwriter_tests)
+ENDIF()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/main.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/main.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/main.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/main.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,326 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+/* This executable is used for testing parser/writer using real JSON files.
+ */
+
+#include <json/json.h>
+#include <algorithm> // sort
+#include <sstream>
+#include <stdio.h>
+
+#if defined(_MSC_VER) && _MSC_VER >= 1310
+#pragma warning(disable : 4996) // disable fopen deprecation warning
+#endif
+
+struct Options
+{
+  JSONCPP_STRING path;
+  Json::Features features;
+  bool parseOnly;
+  typedef JSONCPP_STRING (*writeFuncType)(Json::Value const&);
+  writeFuncType write;
+};
+
+static JSONCPP_STRING normalizeFloatingPointStr(double value) {
+  char buffer[32];
+#if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__)
+  sprintf_s(buffer, sizeof(buffer), "%.16g", value);
+#else
+  snprintf(buffer, sizeof(buffer), "%.16g", value);
+#endif
+  buffer[sizeof(buffer) - 1] = 0;
+  JSONCPP_STRING s(buffer);
+  JSONCPP_STRING::size_type index = s.find_last_of("eE");
+  if (index != JSONCPP_STRING::npos) {
+    JSONCPP_STRING::size_type hasSign =
+        (s[index + 1] == '+' || s[index + 1] == '-') ? 1 : 0;
+    JSONCPP_STRING::size_type exponentStartIndex = index + 1 + hasSign;
+    JSONCPP_STRING normalized = s.substr(0, exponentStartIndex);
+    JSONCPP_STRING::size_type indexDigit =
+        s.find_first_not_of('0', exponentStartIndex);
+    JSONCPP_STRING exponent = "0";
+    if (indexDigit !=
+        JSONCPP_STRING::npos) // There is an exponent different from 0
+    {
+      exponent = s.substr(indexDigit);
+    }
+    return normalized + exponent;
+  }
+  return s;
+}
+
+static JSONCPP_STRING readInputTestFile(const char* path) {
+  FILE* file = fopen(path, "rb");
+  if (!file)
+    return JSONCPP_STRING("");
+  fseek(file, 0, SEEK_END);
+  long const size = ftell(file);
+  unsigned long const usize = static_cast<unsigned long>(size);
+  fseek(file, 0, SEEK_SET);
+  JSONCPP_STRING text;
+  char* buffer = new char[size + 1];
+  buffer[size] = 0;
+  if (fread(buffer, 1, usize, file) == usize)
+    text = buffer;
+  fclose(file);
+  delete[] buffer;
+  return text;
+}
+
+static void
+printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".") {
+  if (value.hasComment(Json::commentBefore)) {
+    fprintf(fout, "%s\n", value.getComment(Json::commentBefore).c_str());
+  }
+  switch (value.type()) {
+  case Json::nullValue:
+    fprintf(fout, "%s=null\n", path.c_str());
+    break;
+  case Json::intValue:
+    fprintf(fout,
+            "%s=%s\n",
+            path.c_str(),
+            Json::valueToString(value.asLargestInt()).c_str());
+    break;
+  case Json::uintValue:
+    fprintf(fout,
+            "%s=%s\n",
+            path.c_str(),
+            Json::valueToString(value.asLargestUInt()).c_str());
+    break;
+  case Json::realValue:
+    fprintf(fout,
+            "%s=%s\n",
+            path.c_str(),
+            normalizeFloatingPointStr(value.asDouble()).c_str());
+    break;
+  case Json::stringValue:
+    fprintf(fout, "%s=\"%s\"\n", path.c_str(), value.asString().c_str());
+    break;
+  case Json::booleanValue:
+    fprintf(fout, "%s=%s\n", path.c_str(), value.asBool() ? "true" : "false");
+    break;
+  case Json::arrayValue: {
+    fprintf(fout, "%s=[]\n", path.c_str());
+    Json::ArrayIndex size = value.size();
+    for (Json::ArrayIndex index = 0; index < size; ++index) {
+      static char buffer[16];
+#if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__)
+      sprintf_s(buffer, sizeof(buffer), "[%d]", index);
+#else
+      snprintf(buffer, sizeof(buffer), "[%d]", index);
+#endif
+      printValueTree(fout, value[index], path + buffer);
+    }
+  } break;
+  case Json::objectValue: {
+    fprintf(fout, "%s={}\n", path.c_str());
+    Json::Value::Members members(value.getMemberNames());
+    std::sort(members.begin(), members.end());
+    JSONCPP_STRING suffix = *(path.end() - 1) == '.' ? "" : ".";
+    for (Json::Value::Members::iterator it = members.begin();
+         it != members.end();
+         ++it) {
+      const JSONCPP_STRING name = *it;
+      printValueTree(fout, value[name], path + suffix + name);
+    }
+  } break;
+  default:
+    break;
+  }
+
+  if (value.hasComment(Json::commentAfter)) {
+    fprintf(fout, "%s\n", value.getComment(Json::commentAfter).c_str());
+  }
+}
+
+static int parseAndSaveValueTree(const JSONCPP_STRING& input,
+                                 const JSONCPP_STRING& actual,
+                                 const JSONCPP_STRING& kind,
+                                 const Json::Features& features,
+                                 bool parseOnly,
+                                 Json::Value* root)
+{
+  Json::Reader reader(features);
+  bool parsingSuccessful = reader.parse(input.data(), input.data() + input.size(), *root);
+  if (!parsingSuccessful) {
+    printf("Failed to parse %s file: \n%s\n",
+           kind.c_str(),
+           reader.getFormattedErrorMessages().c_str());
+    return 1;
+  }
+  if (!parseOnly) {
+    FILE* factual = fopen(actual.c_str(), "wt");
+    if (!factual) {
+      printf("Failed to create %s actual file.\n", kind.c_str());
+      return 2;
+    }
+    printValueTree(factual, *root);
+    fclose(factual);
+  }
+  return 0;
+}
+// static JSONCPP_STRING useFastWriter(Json::Value const& root) {
+//   Json::FastWriter writer;
+//   writer.enableYAMLCompatibility();
+//   return writer.write(root);
+// }
+static JSONCPP_STRING useStyledWriter(
+    Json::Value const& root)
+{
+  Json::StyledWriter writer;
+  return writer.write(root);
+}
+static JSONCPP_STRING useStyledStreamWriter(
+    Json::Value const& root)
+{
+  Json::StyledStreamWriter writer;
+  JSONCPP_OSTRINGSTREAM sout;
+  writer.write(sout, root);
+  return sout.str();
+}
+static JSONCPP_STRING useBuiltStyledStreamWriter(
+    Json::Value const& root)
+{
+  Json::StreamWriterBuilder builder;
+  return Json::writeString(builder, root);
+}
+static int rewriteValueTree(
+    const JSONCPP_STRING& rewritePath,
+    const Json::Value& root,
+    Options::writeFuncType write,
+    JSONCPP_STRING* rewrite)
+{
+  *rewrite = write(root);
+  FILE* fout = fopen(rewritePath.c_str(), "wt");
+  if (!fout) {
+    printf("Failed to create rewrite file: %s\n", rewritePath.c_str());
+    return 2;
+  }
+  fprintf(fout, "%s\n", rewrite->c_str());
+  fclose(fout);
+  return 0;
+}
+
+static JSONCPP_STRING removeSuffix(const JSONCPP_STRING& path,
+                                const JSONCPP_STRING& extension) {
+  if (extension.length() >= path.length())
+    return JSONCPP_STRING("");
+  JSONCPP_STRING suffix = path.substr(path.length() - extension.length());
+  if (suffix != extension)
+    return JSONCPP_STRING("");
+  return path.substr(0, path.length() - extension.length());
+}
+
+static void printConfig() {
+// Print the configuration used to compile JsonCpp
+#if defined(JSON_NO_INT64)
+  printf("JSON_NO_INT64=1\n");
+#else
+  printf("JSON_NO_INT64=0\n");
+#endif
+}
+
+static int printUsage(const char* argv[]) {
+  printf("Usage: %s [--strict] input-json-file", argv[0]);
+  return 3;
+}
+
+static int parseCommandLine(
+    int argc, const char* argv[], Options* opts)
+{
+  opts->parseOnly = false;
+  opts->write = &useStyledWriter;
+  if (argc < 2) {
+    return printUsage(argv);
+  }
+  int index = 1;
+  if (JSONCPP_STRING(argv[index]) == "--json-checker") {
+    opts->features = Json::Features::strictMode();
+    opts->parseOnly = true;
+    ++index;
+  }
+  if (JSONCPP_STRING(argv[index]) == "--json-config") {
+    printConfig();
+    return 3;
+  }
+  if (JSONCPP_STRING(argv[index]) == "--json-writer") {
+    ++index;
+    JSONCPP_STRING const writerName(argv[index++]);
+    if (writerName == "StyledWriter") {
+      opts->write = &useStyledWriter;
+    } else if (writerName == "StyledStreamWriter") {
+      opts->write = &useStyledStreamWriter;
+    } else if (writerName == "BuiltStyledStreamWriter") {
+      opts->write = &useBuiltStyledStreamWriter;
+    } else {
+      printf("Unknown '--json-writer %s'\n", writerName.c_str());
+      return 4;
+    }
+  }
+  if (index == argc || index + 1 < argc) {
+    return printUsage(argv);
+  }
+  opts->path = argv[index];
+  return 0;
+}
+static int runTest(Options const& opts)
+{
+  int exitCode = 0;
+
+  JSONCPP_STRING input = readInputTestFile(opts.path.c_str());
+  if (input.empty()) {
+    printf("Failed to read input or empty input: %s\n", opts.path.c_str());
+    return 3;
+  }
+
+  JSONCPP_STRING basePath = removeSuffix(opts.path, ".json");
+  if (!opts.parseOnly && basePath.empty()) {
+    printf("Bad input path. Path does not end with '.expected':\n%s\n",
+            opts.path.c_str());
+    return 3;
+  }
+
+  JSONCPP_STRING const actualPath = basePath + ".actual";
+  JSONCPP_STRING const rewritePath = basePath + ".rewrite";
+  JSONCPP_STRING const rewriteActualPath = basePath + ".actual-rewrite";
+
+  Json::Value root;
+  exitCode = parseAndSaveValueTree(
+      input, actualPath, "input",
+      opts.features, opts.parseOnly, &root);
+  if (exitCode || opts.parseOnly) {
+    return exitCode;
+  }
+  JSONCPP_STRING rewrite;
+  exitCode = rewriteValueTree(rewritePath, root, opts.write, &rewrite);
+  if (exitCode) {
+    return exitCode;
+  }
+  Json::Value rewriteRoot;
+  exitCode = parseAndSaveValueTree(
+      rewrite, rewriteActualPath, "rewrite",
+      opts.features, opts.parseOnly, &rewriteRoot);
+  if (exitCode) {
+    return exitCode;
+  }
+  return 0;
+}
+int main(int argc, const char* argv[]) {
+  Options opts;
+  try {
+  int exitCode = parseCommandLine(argc, argv, &opts);
+  if (exitCode != 0) {
+    printf("Failed to parse command-line.");
+    return exitCode;
+  }
+    return runTest(opts);
+  }
+  catch (const std::exception& e) {
+    printf("Unhandled exception:\n%s\n", e.what());
+    return 1;
+  }
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/sconscript polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/sconscript
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/sconscript	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/jsontestrunner/sconscript	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,9 @@
+Import( 'env_testing buildJSONTests' )
+
+buildJSONTests( env_testing, Split( """
+    main.cpp
+     """ ),
+    'jsontestrunner' )
+
+# For 'check' to work, 'libs' must be built first.
+env_testing.Depends('jsontestrunner', '#libs')
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,85 @@
+if( CMAKE_COMPILER_IS_GNUCXX )
+  #Get compiler version.
+  execute_process( COMMAND ${CMAKE_CXX_COMPILER} -dumpversion
+                   OUTPUT_VARIABLE GNUCXX_VERSION )
+
+  #-Werror=* was introduced -after- GCC 4.1.2
+  if( GNUCXX_VERSION VERSION_GREATER 4.1.2 )
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=strict-aliasing")
+  endif()
+endif( CMAKE_COMPILER_IS_GNUCXX )
+
+SET( JSONCPP_INCLUDE_DIR ../../include )
+
+SET( PUBLIC_HEADERS
+    ${JSONCPP_INCLUDE_DIR}/json/config.h
+    ${JSONCPP_INCLUDE_DIR}/json/forwards.h
+    ${JSONCPP_INCLUDE_DIR}/json/features.h
+    ${JSONCPP_INCLUDE_DIR}/json/value.h
+    ${JSONCPP_INCLUDE_DIR}/json/reader.h
+    ${JSONCPP_INCLUDE_DIR}/json/writer.h
+    ${JSONCPP_INCLUDE_DIR}/json/assertions.h
+    ${JSONCPP_INCLUDE_DIR}/json/version.h
+    )
+
+SOURCE_GROUP( "Public API" FILES ${PUBLIC_HEADERS} )
+
+SET(jsoncpp_sources
+                json_tool.h
+                json_reader.cpp
+                json_valueiterator.inl
+                json_value.cpp
+                json_writer.cpp
+                version.h.in)
+
+# Install instructions for this target
+IF(JSONCPP_WITH_CMAKE_PACKAGE)
+    SET(INSTALL_EXPORT EXPORT jsoncpp)
+ELSE(JSONCPP_WITH_CMAKE_PACKAGE)
+    SET(INSTALL_EXPORT)
+ENDIF()
+
+IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS( -DJSON_DLL_BUILD )
+    ADD_LIBRARY(jsoncpp_lib SHARED ${PUBLIC_HEADERS} ${jsoncpp_sources})
+    SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES VERSION ${JSONCPP_VERSION} SOVERSION ${JSONCPP_SOVERSION})
+    SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES OUTPUT_NAME jsoncpp
+                           DEBUG_OUTPUT_NAME jsoncpp${DEBUG_LIBNAME_SUFFIX} )
+
+    # Set library's runtime search path on OSX
+    IF(APPLE)
+        SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES INSTALL_RPATH "@loader_path/." )
+    ENDIF()
+
+    INSTALL( TARGETS jsoncpp_lib ${INSTALL_EXPORT}
+         RUNTIME DESTINATION ${RUNTIME_INSTALL_DIR}
+         LIBRARY DESTINATION ${LIBRARY_INSTALL_DIR}
+         ARCHIVE DESTINATION ${ARCHIVE_INSTALL_DIR})
+
+    IF(NOT CMAKE_VERSION VERSION_LESS 2.8.11)
+        TARGET_INCLUDE_DIRECTORIES( jsoncpp_lib PUBLIC
+                                   $<INSTALL_INTERFACE:${INCLUDE_INSTALL_DIR}>
+                                   $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/${JSONCPP_INCLUDE_DIR}>)
+    ENDIF()
+
+ENDIF()
+
+IF(BUILD_STATIC_LIBS)
+    ADD_LIBRARY(jsoncpp_lib_static STATIC ${PUBLIC_HEADERS} ${jsoncpp_sources})
+    SET_TARGET_PROPERTIES( jsoncpp_lib_static PROPERTIES VERSION ${JSONCPP_VERSION} SOVERSION ${JSONCPP_SOVERSION})
+    SET_TARGET_PROPERTIES( jsoncpp_lib_static PROPERTIES OUTPUT_NAME jsoncpp
+                           DEBUG_OUTPUT_NAME jsoncpp${DEBUG_LIBNAME_SUFFIX} )
+
+    INSTALL( TARGETS jsoncpp_lib_static ${INSTALL_EXPORT}
+         RUNTIME DESTINATION ${RUNTIME_INSTALL_DIR}
+         LIBRARY DESTINATION ${LIBRARY_INSTALL_DIR}
+             ARCHIVE DESTINATION ${ARCHIVE_INSTALL_DIR})
+
+    IF(NOT CMAKE_VERSION VERSION_LESS 2.8.11)
+        TARGET_INCLUDE_DIRECTORIES( jsoncpp_lib_static PUBLIC
+                                $<INSTALL_INTERFACE:${INCLUDE_INSTALL_DIR}>
+                                $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/${JSONCPP_INCLUDE_DIR}>
+                                )
+     ENDIF()
+
+ENDIF()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_reader.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_reader.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_reader.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_reader.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2040 @@
+// Copyright 2007-2011 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include <json/assertions.h>
+#include <json/reader.h>
+#include <json/value.h>
+#include "json_tool.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <utility>
+#include <cstdio>
+#include <cassert>
+#include <cstring>
+#include <istream>
+#include <sstream>
+#include <memory>
+#include <set>
+#include <limits>
+
+#if defined(_MSC_VER)
+#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above 
+#define snprintf sprintf_s
+#elif _MSC_VER >= 1900 // VC++ 14.0 and above
+#define snprintf std::snprintf
+#else
+#define snprintf _snprintf
+#endif
+#elif defined(__ANDROID__) || defined(__QNXNTO__)
+#define snprintf snprintf
+#elif __cplusplus >= 201103L
+#if !defined(__MINGW32__) && !defined(__CYGWIN__)
+#define snprintf std::snprintf
+#endif
+#endif
+
+#if defined(__QNXNTO__)
+#define sscanf std::sscanf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
+// Disable warning about strdup being deprecated.
+#pragma warning(disable : 4996)
+#endif
+
+static int const stackLimit_g = 1000;
+static int       stackDepth_g = 0;  // see readValue()
+
+namespace Json {
+
+#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
+typedef std::unique_ptr<CharReader> CharReaderPtr;
+#else
+typedef std::auto_ptr<CharReader>   CharReaderPtr;
+#endif
+
+// Implementation of class Features
+// ////////////////////////////////
+
+Features::Features()
+    : allowComments_(true), strictRoot_(false),
+      allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}
+
+Features Features::all() { return Features(); }
+
+Features Features::strictMode() {
+  Features features;
+  features.allowComments_ = false;
+  features.strictRoot_ = true;
+  features.allowDroppedNullPlaceholders_ = false;
+  features.allowNumericKeys_ = false;
+  return features;
+}
+
+// Implementation of class Reader
+// ////////////////////////////////
+
+static bool containsNewLine(Reader::Location begin, Reader::Location end) {
+  for (; begin < end; ++begin)
+    if (*begin == '\n' || *begin == '\r')
+      return true;
+  return false;
+}
+
+// Class Reader
+// //////////////////////////////////////////////////////////////////
+
+Reader::Reader()
+    : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
+      lastValue_(), commentsBefore_(), features_(Features::all()),
+      collectComments_() {}
+
+Reader::Reader(const Features& features)
+    : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
+      lastValue_(), commentsBefore_(), features_(features), collectComments_() {
+}
+
+bool
+Reader::parse(const std::string& document, Value& root, bool collectComments) {
+  JSONCPP_STRING documentCopy(document.data(), document.data() + document.capacity());
+  std::swap(documentCopy, document_);
+  const char* begin = document_.c_str();
+  const char* end = begin + document_.length();
+  return parse(begin, end, root, collectComments);
+}
+
+bool Reader::parse(std::istream& sin, Value& root, bool collectComments) {
+  // std::istream_iterator<char> begin(sin);
+  // std::istream_iterator<char> end;
+  // Those would allow streamed input from a file, if parse() were a
+  // template function.
+
+  // Since JSONCPP_STRING is reference-counted, this at least does not
+  // create an extra copy.
+  JSONCPP_STRING doc;
+  std::getline(sin, doc, (char)EOF);
+  return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
+}
+
+bool Reader::parse(const char* beginDoc,
+                   const char* endDoc,
+                   Value& root,
+                   bool collectComments) {
+  if (!features_.allowComments_) {
+    collectComments = false;
+  }
+
+  begin_ = beginDoc;
+  end_ = endDoc;
+  collectComments_ = collectComments;
+  current_ = begin_;
+  lastValueEnd_ = 0;
+  lastValue_ = 0;
+  commentsBefore_ = "";
+  errors_.clear();
+  while (!nodes_.empty())
+    nodes_.pop();
+  nodes_.push(&root);
+
+  stackDepth_g = 0;  // Yes, this is bad coding, but options are limited.
+  bool successful = readValue();
+  Token token;
+  skipCommentTokens(token);
+  if (collectComments_ && !commentsBefore_.empty())
+    root.setComment(commentsBefore_, commentAfter);
+  if (features_.strictRoot_) {
+    if (!root.isArray() && !root.isObject()) {
+      // Set error location to start of doc, ideally should be first token found
+      // in doc
+      token.type_ = tokenError;
+      token.start_ = beginDoc;
+      token.end_ = endDoc;
+      addError(
+          "A valid JSON document must be either an array or an object value.",
+          token);
+      return false;
+    }
+  }
+  return successful;
+}
+
+bool Reader::readValue() {
+  // This is a non-reentrant way to support a stackLimit. Terrible!
+  // But this deprecated class has a security problem: Bad input can
+  // cause a seg-fault. This seems like a fair, binary-compatible way
+  // to prevent the problem.
+  if (stackDepth_g >= stackLimit_g) throwRuntimeError("Exceeded stackLimit in readValue().");
+  ++stackDepth_g;
+
+  Token token;
+  skipCommentTokens(token);
+  bool successful = true;
+
+  if (collectComments_ && !commentsBefore_.empty()) {
+    currentValue().setComment(commentsBefore_, commentBefore);
+    commentsBefore_ = "";
+  }
+
+  switch (token.type_) {
+  case tokenObjectBegin:
+    successful = readObject(token);
+    currentValue().setOffsetLimit(current_ - begin_);
+    break;
+  case tokenArrayBegin:
+    successful = readArray(token);
+    currentValue().setOffsetLimit(current_ - begin_);
+    break;
+  case tokenNumber:
+    successful = decodeNumber(token);
+    break;
+  case tokenString:
+    successful = decodeString(token);
+    break;
+  case tokenTrue:
+    {
+    Value v(true);
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenFalse:
+    {
+    Value v(false);
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenNull:
+    {
+    Value v;
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenArraySeparator:
+  case tokenObjectEnd:
+  case tokenArrayEnd:
+    if (features_.allowDroppedNullPlaceholders_) {
+      // "Un-read" the current token and mark the current value as a null
+      // token.
+      current_--;
+      Value v;
+      currentValue().swapPayload(v);
+      currentValue().setOffsetStart(current_ - begin_ - 1);
+      currentValue().setOffsetLimit(current_ - begin_);
+      break;
+    } // Else, fall through...
+  default:
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    return addError("Syntax error: value, object or array expected.", token);
+  }
+
+  if (collectComments_) {
+    lastValueEnd_ = current_;
+    lastValue_ = &currentValue();
+  }
+
+  --stackDepth_g;
+  return successful;
+}
+
+void Reader::skipCommentTokens(Token& token) {
+  if (features_.allowComments_) {
+    do {
+      readToken(token);
+    } while (token.type_ == tokenComment);
+  } else {
+    readToken(token);
+  }
+}
+
+bool Reader::readToken(Token& token) {
+  skipSpaces();
+  token.start_ = current_;
+  Char c = getNextChar();
+  bool ok = true;
+  switch (c) {
+  case '{':
+    token.type_ = tokenObjectBegin;
+    break;
+  case '}':
+    token.type_ = tokenObjectEnd;
+    break;
+  case '[':
+    token.type_ = tokenArrayBegin;
+    break;
+  case ']':
+    token.type_ = tokenArrayEnd;
+    break;
+  case '"':
+    token.type_ = tokenString;
+    ok = readString();
+    break;
+  case '/':
+    token.type_ = tokenComment;
+    ok = readComment();
+    break;
+  case '0':
+  case '1':
+  case '2':
+  case '3':
+  case '4':
+  case '5':
+  case '6':
+  case '7':
+  case '8':
+  case '9':
+  case '-':
+    token.type_ = tokenNumber;
+    readNumber();
+    break;
+  case 't':
+    token.type_ = tokenTrue;
+    ok = match("rue", 3);
+    break;
+  case 'f':
+    token.type_ = tokenFalse;
+    ok = match("alse", 4);
+    break;
+  case 'n':
+    token.type_ = tokenNull;
+    ok = match("ull", 3);
+    break;
+  case ',':
+    token.type_ = tokenArraySeparator;
+    break;
+  case ':':
+    token.type_ = tokenMemberSeparator;
+    break;
+  case 0:
+    token.type_ = tokenEndOfStream;
+    break;
+  default:
+    ok = false;
+    break;
+  }
+  if (!ok)
+    token.type_ = tokenError;
+  token.end_ = current_;
+  return true;
+}
+
+void Reader::skipSpaces() {
+  while (current_ != end_) {
+    Char c = *current_;
+    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
+      ++current_;
+    else
+      break;
+  }
+}
+
+bool Reader::match(Location pattern, int patternLength) {
+  if (end_ - current_ < patternLength)
+    return false;
+  int index = patternLength;
+  while (index--)
+    if (current_[index] != pattern[index])
+      return false;
+  current_ += patternLength;
+  return true;
+}
+
+bool Reader::readComment() {
+  Location commentBegin = current_ - 1;
+  Char c = getNextChar();
+  bool successful = false;
+  if (c == '*')
+    successful = readCStyleComment();
+  else if (c == '/')
+    successful = readCppStyleComment();
+  if (!successful)
+    return false;
+
+  if (collectComments_) {
+    CommentPlacement placement = commentBefore;
+    if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
+      if (c != '*' || !containsNewLine(commentBegin, current_))
+        placement = commentAfterOnSameLine;
+    }
+
+    addComment(commentBegin, current_, placement);
+  }
+  return true;
+}
+
+static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
+  JSONCPP_STRING normalized;
+  normalized.reserve(static_cast<size_t>(end - begin));
+  Reader::Location current = begin;
+  while (current != end) {
+    char c = *current++;
+    if (c == '\r') {
+      if (current != end && *current == '\n')
+         // convert dos EOL
+         ++current;
+      // convert Mac EOL
+      normalized += '\n';
+    } else {
+      normalized += c;
+    }
+  }
+  return normalized;
+}
+
+void
+Reader::addComment(Location begin, Location end, CommentPlacement placement) {
+  assert(collectComments_);
+  const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
+  if (placement == commentAfterOnSameLine) {
+    assert(lastValue_ != 0);
+    lastValue_->setComment(normalized, placement);
+  } else {
+    commentsBefore_ += normalized;
+  }
+}
+
+bool Reader::readCStyleComment() {
+  while ((current_ + 1) < end_) {
+    Char c = getNextChar();
+    if (c == '*' && *current_ == '/')
+      break;
+  }
+  return getNextChar() == '/';
+}
+
+bool Reader::readCppStyleComment() {
+  while (current_ != end_) {
+    Char c = getNextChar();
+    if (c == '\n')
+      break;
+    if (c == '\r') {
+      // Consume DOS EOL. It will be normalized in addComment.
+      if (current_ != end_ && *current_ == '\n')
+        getNextChar();
+      // Break on Moc OS 9 EOL.
+      break;
+    }
+  }
+  return true;
+}
+
+void Reader::readNumber() {
+  const char *p = current_;
+  char c = '0'; // stopgap for already consumed character
+  // integral part
+  while (c >= '0' && c <= '9')
+    c = (current_ = p) < end_ ? *p++ : '\0';
+  // fractional part
+  if (c == '.') {
+    c = (current_ = p) < end_ ? *p++ : '\0';
+    while (c >= '0' && c <= '9')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+  }
+  // exponential part
+  if (c == 'e' || c == 'E') {
+    c = (current_ = p) < end_ ? *p++ : '\0';
+    if (c == '+' || c == '-')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+    while (c >= '0' && c <= '9')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+  }
+}
+
+bool Reader::readString() {
+  Char c = '\0';
+  while (current_ != end_) {
+    c = getNextChar();
+    if (c == '\\')
+      getNextChar();
+    else if (c == '"')
+      break;
+  }
+  return c == '"';
+}
+
+bool Reader::readObject(Token& tokenStart) {
+  Token tokenName;
+  JSONCPP_STRING name;
+  Value init(objectValue);
+  currentValue().swapPayload(init);
+  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  while (readToken(tokenName)) {
+    bool initialTokenOk = true;
+    while (tokenName.type_ == tokenComment && initialTokenOk)
+      initialTokenOk = readToken(tokenName);
+    if (!initialTokenOk)
+      break;
+    if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
+      return true;
+    name = "";
+    if (tokenName.type_ == tokenString) {
+      if (!decodeString(tokenName, name))
+        return recoverFromError(tokenObjectEnd);
+    } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
+      Value numberName;
+      if (!decodeNumber(tokenName, numberName))
+        return recoverFromError(tokenObjectEnd);
+      name = JSONCPP_STRING(numberName.asCString());
+    } else {
+      break;
+    }
+
+    Token colon;
+    if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
+      return addErrorAndRecover(
+          "Missing ':' after object member name", colon, tokenObjectEnd);
+    }
+    Value& value = currentValue()[name];
+    nodes_.push(&value);
+    bool ok = readValue();
+    nodes_.pop();
+    if (!ok) // error already set
+      return recoverFromError(tokenObjectEnd);
+
+    Token comma;
+    if (!readToken(comma) ||
+        (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
+         comma.type_ != tokenComment)) {
+      return addErrorAndRecover(
+          "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
+    }
+    bool finalizeTokenOk = true;
+    while (comma.type_ == tokenComment && finalizeTokenOk)
+      finalizeTokenOk = readToken(comma);
+    if (comma.type_ == tokenObjectEnd)
+      return true;
+  }
+  return addErrorAndRecover(
+      "Missing '}' or object member name", tokenName, tokenObjectEnd);
+}
+
+bool Reader::readArray(Token& tokenStart) {
+  Value init(arrayValue);
+  currentValue().swapPayload(init);
+  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  skipSpaces();
+  if (current_ != end_ && *current_ == ']') // empty array
+  {
+    Token endArray;
+    readToken(endArray);
+    return true;
+  }
+  int index = 0;
+  for (;;) {
+    Value& value = currentValue()[index++];
+    nodes_.push(&value);
+    bool ok = readValue();
+    nodes_.pop();
+    if (!ok) // error already set
+      return recoverFromError(tokenArrayEnd);
+
+    Token token;
+    // Accept Comment after last item in the array.
+    ok = readToken(token);
+    while (token.type_ == tokenComment && ok) {
+      ok = readToken(token);
+    }
+    bool badTokenType =
+        (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
+    if (!ok || badTokenType) {
+      return addErrorAndRecover(
+          "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
+    }
+    if (token.type_ == tokenArrayEnd)
+      break;
+  }
+  return true;
+}
+
+bool Reader::decodeNumber(Token& token) {
+  Value decoded;
+  if (!decodeNumber(token, decoded))
+    return false;
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool Reader::decodeNumber(Token& token, Value& decoded) {
+  // Attempts to parse the number as an integer. If the number is
+  // larger than the maximum supported value of an integer then
+  // we decode the number as a double.
+  Location current = token.start_;
+  bool isNegative = *current == '-';
+  if (isNegative)
+    ++current;
+  // TODO: Help the compiler do the div and mod at compile time or get rid of them.
+  Value::LargestUInt maxIntegerValue =
+      isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
+                 : Value::maxLargestUInt;
+  Value::LargestUInt threshold = maxIntegerValue / 10;
+  Value::LargestUInt value = 0;
+  while (current < token.end_) {
+    Char c = *current++;
+    if (c < '0' || c > '9')
+      return decodeDouble(token, decoded);
+    Value::UInt digit(static_cast<Value::UInt>(c - '0'));
+    if (value >= threshold) {
+      // We've hit or exceeded the max value divided by 10 (rounded down). If
+      // a) we've only just touched the limit, b) this is the last digit, and
+      // c) it's small enough to fit in that rounding delta, we're okay.
+      // Otherwise treat this number as a double to avoid overflow.
+      if (value > threshold || current != token.end_ ||
+          digit > maxIntegerValue % 10) {
+        return decodeDouble(token, decoded);
+      }
+    }
+    value = value * 10 + digit;
+  }
+  if (isNegative && value == maxIntegerValue)
+    decoded = Value::minLargestInt;
+  else if (isNegative)
+    decoded = -Value::LargestInt(value);
+  else if (value <= Value::LargestUInt(Value::maxInt))
+    decoded = Value::LargestInt(value);
+  else
+    decoded = value;
+  return true;
+}
+
+bool Reader::decodeDouble(Token& token) {
+  Value decoded;
+  if (!decodeDouble(token, decoded))
+    return false;
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool Reader::decodeDouble(Token& token, Value& decoded) {
+  double value = 0;
+  JSONCPP_STRING buffer(token.start_, token.end_);
+  JSONCPP_ISTRINGSTREAM is(buffer);
+  if (!(is >> value))
+    return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
+                        "' is not a number.",
+                    token);
+  decoded = value;
+  return true;
+}
+
+bool Reader::decodeString(Token& token) {
+  JSONCPP_STRING decoded_string;
+  if (!decodeString(token, decoded_string))
+    return false;
+  Value decoded(decoded_string);
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
+  decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
+  Location current = token.start_ + 1; // skip '"'
+  Location end = token.end_ - 1;       // do not include '"'
+  while (current != end) {
+    Char c = *current++;
+    if (c == '"')
+      break;
+    else if (c == '\\') {
+      if (current == end)
+        return addError("Empty escape sequence in string", token, current);
+      Char escape = *current++;
+      switch (escape) {
+      case '"':
+        decoded += '"';
+        break;
+      case '/':
+        decoded += '/';
+        break;
+      case '\\':
+        decoded += '\\';
+        break;
+      case 'b':
+        decoded += '\b';
+        break;
+      case 'f':
+        decoded += '\f';
+        break;
+      case 'n':
+        decoded += '\n';
+        break;
+      case 'r':
+        decoded += '\r';
+        break;
+      case 't':
+        decoded += '\t';
+        break;
+      case 'u': {
+        unsigned int unicode;
+        if (!decodeUnicodeCodePoint(token, current, end, unicode))
+          return false;
+        decoded += codePointToUTF8(unicode);
+      } break;
+      default:
+        return addError("Bad escape sequence in string", token, current);
+      }
+    } else {
+      decoded += c;
+    }
+  }
+  return true;
+}
+
+bool Reader::decodeUnicodeCodePoint(Token& token,
+                                    Location& current,
+                                    Location end,
+                                    unsigned int& unicode) {
+
+  if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
+    return false;
+  if (unicode >= 0xD800 && unicode <= 0xDBFF) {
+    // surrogate pairs
+    if (end - current < 6)
+      return addError(
+          "additional six characters expected to parse unicode surrogate pair.",
+          token,
+          current);
+    unsigned int surrogatePair;
+    if (*(current++) == '\\' && *(current++) == 'u') {
+      if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
+        unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
+      } else
+        return false;
+    } else
+      return addError("expecting another \\u token to begin the second half of "
+                      "a unicode surrogate pair",
+                      token,
+                      current);
+  }
+  return true;
+}
+
+bool Reader::decodeUnicodeEscapeSequence(Token& token,
+                                         Location& current,
+                                         Location end,
+                                         unsigned int& ret_unicode) {
+  if (end - current < 4)
+    return addError(
+        "Bad unicode escape sequence in string: four digits expected.",
+        token,
+        current);
+  int unicode = 0;
+  for (int index = 0; index < 4; ++index) {
+    Char c = *current++;
+    unicode *= 16;
+    if (c >= '0' && c <= '9')
+      unicode += c - '0';
+    else if (c >= 'a' && c <= 'f')
+      unicode += c - 'a' + 10;
+    else if (c >= 'A' && c <= 'F')
+      unicode += c - 'A' + 10;
+    else
+      return addError(
+          "Bad unicode escape sequence in string: hexadecimal digit expected.",
+          token,
+          current);
+  }
+  ret_unicode = static_cast<unsigned int>(unicode);
+  return true;
+}
+
+bool
+Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = extra;
+  errors_.push_back(info);
+  return false;
+}
+
+bool Reader::recoverFromError(TokenType skipUntilToken) {
+  size_t const errorCount = errors_.size();
+  Token skip;
+  for (;;) {
+    if (!readToken(skip))
+      errors_.resize(errorCount); // discard errors caused by recovery
+    if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
+      break;
+  }
+  errors_.resize(errorCount);
+  return false;
+}
+
+bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
+                                Token& token,
+                                TokenType skipUntilToken) {
+  addError(message, token);
+  return recoverFromError(skipUntilToken);
+}
+
+Value& Reader::currentValue() { return *(nodes_.top()); }
+
+Reader::Char Reader::getNextChar() {
+  if (current_ == end_)
+    return 0;
+  return *current_++;
+}
+
+void Reader::getLocationLineAndColumn(Location location,
+                                      int& line,
+                                      int& column) const {
+  Location current = begin_;
+  Location lastLineStart = current;
+  line = 0;
+  while (current < location && current != end_) {
+    Char c = *current++;
+    if (c == '\r') {
+      if (*current == '\n')
+        ++current;
+      lastLineStart = current;
+      ++line;
+    } else if (c == '\n') {
+      lastLineStart = current;
+      ++line;
+    }
+  }
+  // column & line start at 1
+  column = int(location - lastLineStart) + 1;
+  ++line;
+}
+
+JSONCPP_STRING Reader::getLocationLineAndColumn(Location location) const {
+  int line, column;
+  getLocationLineAndColumn(location, line, column);
+  char buffer[18 + 16 + 16 + 1];
+  snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
+  return buffer;
+}
+
+// Deprecated. Preserved for backward compatibility
+JSONCPP_STRING Reader::getFormatedErrorMessages() const {
+  return getFormattedErrorMessages();
+}
+
+JSONCPP_STRING Reader::getFormattedErrorMessages() const {
+  JSONCPP_STRING formattedMessage;
+  for (Errors::const_iterator itError = errors_.begin();
+       itError != errors_.end();
+       ++itError) {
+    const ErrorInfo& error = *itError;
+    formattedMessage +=
+        "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
+    formattedMessage += "  " + error.message_ + "\n";
+    if (error.extra_)
+      formattedMessage +=
+          "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
+  }
+  return formattedMessage;
+}
+
+std::vector<Reader::StructuredError> Reader::getStructuredErrors() const {
+  std::vector<Reader::StructuredError> allErrors;
+  for (Errors::const_iterator itError = errors_.begin();
+       itError != errors_.end();
+       ++itError) {
+    const ErrorInfo& error = *itError;
+    Reader::StructuredError structured;
+    structured.offset_start = error.token_.start_ - begin_;
+    structured.offset_limit = error.token_.end_ - begin_;
+    structured.message = error.message_;
+    allErrors.push_back(structured);
+  }
+  return allErrors;
+}
+
+bool Reader::pushError(const Value& value, const JSONCPP_STRING& message) {
+  ptrdiff_t const length = end_ - begin_;
+  if(value.getOffsetStart() > length
+    || value.getOffsetLimit() > length)
+    return false;
+  Token token;
+  token.type_ = tokenError;
+  token.start_ = begin_ + value.getOffsetStart();
+  token.end_ = end_ + value.getOffsetLimit();
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = 0;
+  errors_.push_back(info);
+  return true;
+}
+
+bool Reader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
+  ptrdiff_t const length = end_ - begin_;
+  if(value.getOffsetStart() > length
+    || value.getOffsetLimit() > length
+    || extra.getOffsetLimit() > length)
+    return false;
+  Token token;
+  token.type_ = tokenError;
+  token.start_ = begin_ + value.getOffsetStart();
+  token.end_ = begin_ + value.getOffsetLimit();
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = begin_ + extra.getOffsetStart();
+  errors_.push_back(info);
+  return true;
+}
+
+bool Reader::good() const {
+  return !errors_.size();
+}
+
+// exact copy of Features
+class OurFeatures {
+public:
+  static OurFeatures all();
+  bool allowComments_;
+  bool strictRoot_;
+  bool allowDroppedNullPlaceholders_;
+  bool allowNumericKeys_;
+  bool allowSingleQuotes_;
+  bool failIfExtra_;
+  bool rejectDupKeys_;
+  bool allowSpecialFloats_;
+  int stackLimit_;
+};  // OurFeatures
+
+// exact copy of Implementation of class Features
+// ////////////////////////////////
+
+OurFeatures OurFeatures::all() { return OurFeatures(); }
+
+// Implementation of class Reader
+// ////////////////////////////////
+
+// exact copy of Reader, renamed to OurReader
+class OurReader {
+public:
+  typedef char Char;
+  typedef const Char* Location;
+  struct StructuredError {
+    ptrdiff_t offset_start;
+    ptrdiff_t offset_limit;
+    JSONCPP_STRING message;
+  };
+
+  OurReader(OurFeatures const& features);
+  bool parse(const char* beginDoc,
+             const char* endDoc,
+             Value& root,
+             bool collectComments = true);
+  JSONCPP_STRING getFormattedErrorMessages() const;
+  std::vector<StructuredError> getStructuredErrors() const;
+  bool pushError(const Value& value, const JSONCPP_STRING& message);
+  bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
+  bool good() const;
+
+private:
+  OurReader(OurReader const&);  // no impl
+  void operator=(OurReader const&);  // no impl
+
+  enum TokenType {
+    tokenEndOfStream = 0,
+    tokenObjectBegin,
+    tokenObjectEnd,
+    tokenArrayBegin,
+    tokenArrayEnd,
+    tokenString,
+    tokenNumber,
+    tokenTrue,
+    tokenFalse,
+    tokenNull,
+    tokenNaN,
+    tokenPosInf,
+    tokenNegInf,
+    tokenArraySeparator,
+    tokenMemberSeparator,
+    tokenComment,
+    tokenError
+  };
+
+  class Token {
+  public:
+    TokenType type_;
+    Location start_;
+    Location end_;
+  };
+
+  class ErrorInfo {
+  public:
+    Token token_;
+    JSONCPP_STRING message_;
+    Location extra_;
+  };
+
+  typedef std::deque<ErrorInfo> Errors;
+
+  bool readToken(Token& token);
+  void skipSpaces();
+  bool match(Location pattern, int patternLength);
+  bool readComment();
+  bool readCStyleComment();
+  bool readCppStyleComment();
+  bool readString();
+  bool readStringSingleQuote();
+  bool readNumber(bool checkInf);
+  bool readValue();
+  bool readObject(Token& token);
+  bool readArray(Token& token);
+  bool decodeNumber(Token& token);
+  bool decodeNumber(Token& token, Value& decoded);
+  bool decodeString(Token& token);
+  bool decodeString(Token& token, JSONCPP_STRING& decoded);
+  bool decodeDouble(Token& token);
+  bool decodeDouble(Token& token, Value& decoded);
+  bool decodeUnicodeCodePoint(Token& token,
+                              Location& current,
+                              Location end,
+                              unsigned int& unicode);
+  bool decodeUnicodeEscapeSequence(Token& token,
+                                   Location& current,
+                                   Location end,
+                                   unsigned int& unicode);
+  bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
+  bool recoverFromError(TokenType skipUntilToken);
+  bool addErrorAndRecover(const JSONCPP_STRING& message,
+                          Token& token,
+                          TokenType skipUntilToken);
+  void skipUntilSpace();
+  Value& currentValue();
+  Char getNextChar();
+  void
+  getLocationLineAndColumn(Location location, int& line, int& column) const;
+  JSONCPP_STRING getLocationLineAndColumn(Location location) const;
+  void addComment(Location begin, Location end, CommentPlacement placement);
+  void skipCommentTokens(Token& token);
+
+  typedef std::stack<Value*> Nodes;
+  Nodes nodes_;
+  Errors errors_;
+  JSONCPP_STRING document_;
+  Location begin_;
+  Location end_;
+  Location current_;
+  Location lastValueEnd_;
+  Value* lastValue_;
+  JSONCPP_STRING commentsBefore_;
+  int stackDepth_;
+
+  OurFeatures const features_;
+  bool collectComments_;
+};  // OurReader
+
+// complete copy of Read impl, for OurReader
+
+OurReader::OurReader(OurFeatures const& features)
+    : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
+      lastValue_(), commentsBefore_(),
+      stackDepth_(0),
+      features_(features), collectComments_() {
+}
+
+bool OurReader::parse(const char* beginDoc,
+                   const char* endDoc,
+                   Value& root,
+                   bool collectComments) {
+  if (!features_.allowComments_) {
+    collectComments = false;
+  }
+
+  begin_ = beginDoc;
+  end_ = endDoc;
+  collectComments_ = collectComments;
+  current_ = begin_;
+  lastValueEnd_ = 0;
+  lastValue_ = 0;
+  commentsBefore_ = "";
+  errors_.clear();
+  while (!nodes_.empty())
+    nodes_.pop();
+  nodes_.push(&root);
+
+  stackDepth_ = 0;
+  bool successful = readValue();
+  Token token;
+  skipCommentTokens(token);
+  if (features_.failIfExtra_) {
+    if ((features_.strictRoot_ || token.type_ != tokenError) && token.type_ != tokenEndOfStream) {
+      addError("Extra non-whitespace after JSON value.", token);
+      return false;
+    }
+  }
+  if (collectComments_ && !commentsBefore_.empty())
+    root.setComment(commentsBefore_, commentAfter);
+  if (features_.strictRoot_) {
+    if (!root.isArray() && !root.isObject()) {
+      // Set error location to start of doc, ideally should be first token found
+      // in doc
+      token.type_ = tokenError;
+      token.start_ = beginDoc;
+      token.end_ = endDoc;
+      addError(
+          "A valid JSON document must be either an array or an object value.",
+          token);
+      return false;
+    }
+  }
+  return successful;
+}
+
+bool OurReader::readValue() {
+  if (stackDepth_ >= features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");
+  ++stackDepth_;
+  Token token;
+  skipCommentTokens(token);
+  bool successful = true;
+
+  if (collectComments_ && !commentsBefore_.empty()) {
+    currentValue().setComment(commentsBefore_, commentBefore);
+    commentsBefore_ = "";
+  }
+
+  switch (token.type_) {
+  case tokenObjectBegin:
+    successful = readObject(token);
+    currentValue().setOffsetLimit(current_ - begin_);
+    break;
+  case tokenArrayBegin:
+    successful = readArray(token);
+    currentValue().setOffsetLimit(current_ - begin_);
+    break;
+  case tokenNumber:
+    successful = decodeNumber(token);
+    break;
+  case tokenString:
+    successful = decodeString(token);
+    break;
+  case tokenTrue:
+    {
+    Value v(true);
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenFalse:
+    {
+    Value v(false);
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenNull:
+    {
+    Value v;
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenNaN:
+    {
+    Value v(std::numeric_limits<double>::quiet_NaN());
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenPosInf:
+    {
+    Value v(std::numeric_limits<double>::infinity());
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenNegInf:
+    {
+    Value v(-std::numeric_limits<double>::infinity());
+    currentValue().swapPayload(v);
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    }
+    break;
+  case tokenArraySeparator:
+  case tokenObjectEnd:
+  case tokenArrayEnd:
+    if (features_.allowDroppedNullPlaceholders_) {
+      // "Un-read" the current token and mark the current value as a null
+      // token.
+      current_--;
+      Value v;
+      currentValue().swapPayload(v);
+      currentValue().setOffsetStart(current_ - begin_ - 1);
+      currentValue().setOffsetLimit(current_ - begin_);
+      break;
+    } // else, fall through ...
+  default:
+    currentValue().setOffsetStart(token.start_ - begin_);
+    currentValue().setOffsetLimit(token.end_ - begin_);
+    return addError("Syntax error: value, object or array expected.", token);
+  }
+
+  if (collectComments_) {
+    lastValueEnd_ = current_;
+    lastValue_ = &currentValue();
+  }
+
+  --stackDepth_;
+  return successful;
+}
+
+void OurReader::skipCommentTokens(Token& token) {
+  if (features_.allowComments_) {
+    do {
+      readToken(token);
+    } while (token.type_ == tokenComment);
+  } else {
+    readToken(token);
+  }
+}
+
+bool OurReader::readToken(Token& token) {
+  skipSpaces();
+  token.start_ = current_;
+  Char c = getNextChar();
+  bool ok = true;
+  switch (c) {
+  case '{':
+    token.type_ = tokenObjectBegin;
+    break;
+  case '}':
+    token.type_ = tokenObjectEnd;
+    break;
+  case '[':
+    token.type_ = tokenArrayBegin;
+    break;
+  case ']':
+    token.type_ = tokenArrayEnd;
+    break;
+  case '"':
+    token.type_ = tokenString;
+    ok = readString();
+    break;
+  case '\'':
+    if (features_.allowSingleQuotes_) {
+    token.type_ = tokenString;
+    ok = readStringSingleQuote();
+    break;
+    } // else continue
+    // FALLTHRU
+  case '/':
+    token.type_ = tokenComment;
+    ok = readComment();
+    break;
+  case '0':
+  case '1':
+  case '2':
+  case '3':
+  case '4':
+  case '5':
+  case '6':
+  case '7':
+  case '8':
+  case '9':
+    token.type_ = tokenNumber;
+    readNumber(false);
+    break;
+  case '-':
+    if (readNumber(true)) {
+      token.type_ = tokenNumber;
+    } else {
+      token.type_ = tokenNegInf;
+      ok = features_.allowSpecialFloats_ && match("nfinity", 7);
+    }
+    break;
+  case 't':
+    token.type_ = tokenTrue;
+    ok = match("rue", 3);
+    break;
+  case 'f':
+    token.type_ = tokenFalse;
+    ok = match("alse", 4);
+    break;
+  case 'n':
+    token.type_ = tokenNull;
+    ok = match("ull", 3);
+    break;
+  case 'N':
+    if (features_.allowSpecialFloats_) {
+      token.type_ = tokenNaN;
+      ok = match("aN", 2);
+    } else {
+      ok = false;
+    }
+    break;
+  case 'I':
+    if (features_.allowSpecialFloats_) {
+      token.type_ = tokenPosInf;
+      ok = match("nfinity", 7);
+    } else {
+      ok = false;
+    }
+    break;
+  case ',':
+    token.type_ = tokenArraySeparator;
+    break;
+  case ':':
+    token.type_ = tokenMemberSeparator;
+    break;
+  case 0:
+    token.type_ = tokenEndOfStream;
+    break;
+  default:
+    ok = false;
+    break;
+  }
+  if (!ok)
+    token.type_ = tokenError;
+  token.end_ = current_;
+  return true;
+}
+
+void OurReader::skipSpaces() {
+  while (current_ != end_) {
+    Char c = *current_;
+    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
+      ++current_;
+    else
+      break;
+  }
+}
+
+bool OurReader::match(Location pattern, int patternLength) {
+  if (end_ - current_ < patternLength)
+    return false;
+  int index = patternLength;
+  while (index--)
+    if (current_[index] != pattern[index])
+      return false;
+  current_ += patternLength;
+  return true;
+}
+
+bool OurReader::readComment() {
+  Location commentBegin = current_ - 1;
+  Char c = getNextChar();
+  bool successful = false;
+  if (c == '*')
+    successful = readCStyleComment();
+  else if (c == '/')
+    successful = readCppStyleComment();
+  if (!successful)
+    return false;
+
+  if (collectComments_) {
+    CommentPlacement placement = commentBefore;
+    if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
+      if (c != '*' || !containsNewLine(commentBegin, current_))
+        placement = commentAfterOnSameLine;
+    }
+
+    addComment(commentBegin, current_, placement);
+  }
+  return true;
+}
+
+void
+OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
+  assert(collectComments_);
+  const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
+  if (placement == commentAfterOnSameLine) {
+    assert(lastValue_ != 0);
+    lastValue_->setComment(normalized, placement);
+  } else {
+    commentsBefore_ += normalized;
+  }
+}
+
+bool OurReader::readCStyleComment() {
+  while ((current_ + 1) < end_) {
+    Char c = getNextChar();
+    if (c == '*' && *current_ == '/')
+      break;
+  }
+  return getNextChar() == '/';
+}
+
+bool OurReader::readCppStyleComment() {
+  while (current_ != end_) {
+    Char c = getNextChar();
+    if (c == '\n')
+      break;
+    if (c == '\r') {
+      // Consume DOS EOL. It will be normalized in addComment.
+      if (current_ != end_ && *current_ == '\n')
+        getNextChar();
+      // Break on Moc OS 9 EOL.
+      break;
+    }
+  }
+  return true;
+}
+
+bool OurReader::readNumber(bool checkInf) {
+  const char *p = current_;
+  if (checkInf && p != end_ && *p == 'I') {
+    current_ = ++p;
+    return false;
+  }
+  char c = '0'; // stopgap for already consumed character
+  // integral part
+  while (c >= '0' && c <= '9')
+    c = (current_ = p) < end_ ? *p++ : '\0';
+  // fractional part
+  if (c == '.') {
+    c = (current_ = p) < end_ ? *p++ : '\0';
+    while (c >= '0' && c <= '9')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+  }
+  // exponential part
+  if (c == 'e' || c == 'E') {
+    c = (current_ = p) < end_ ? *p++ : '\0';
+    if (c == '+' || c == '-')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+    while (c >= '0' && c <= '9')
+      c = (current_ = p) < end_ ? *p++ : '\0';
+  }
+  return true;
+}
+bool OurReader::readString() {
+  Char c = 0;
+  while (current_ != end_) {
+    c = getNextChar();
+    if (c == '\\')
+      getNextChar();
+    else if (c == '"')
+      break;
+  }
+  return c == '"';
+}
+
+
+bool OurReader::readStringSingleQuote() {
+  Char c = 0;
+  while (current_ != end_) {
+    c = getNextChar();
+    if (c == '\\')
+      getNextChar();
+    else if (c == '\'')
+      break;
+  }
+  return c == '\'';
+}
+
+bool OurReader::readObject(Token& tokenStart) {
+  Token tokenName;
+  JSONCPP_STRING name;
+  Value init(objectValue);
+  currentValue().swapPayload(init);
+  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  while (readToken(tokenName)) {
+    bool initialTokenOk = true;
+    while (tokenName.type_ == tokenComment && initialTokenOk)
+      initialTokenOk = readToken(tokenName);
+    if (!initialTokenOk)
+      break;
+    if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
+      return true;
+    name = "";
+    if (tokenName.type_ == tokenString) {
+      if (!decodeString(tokenName, name))
+        return recoverFromError(tokenObjectEnd);
+    } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
+      Value numberName;
+      if (!decodeNumber(tokenName, numberName))
+        return recoverFromError(tokenObjectEnd);
+      name = numberName.asString();
+    } else {
+      break;
+    }
+
+    Token colon;
+    if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
+      return addErrorAndRecover(
+          "Missing ':' after object member name", colon, tokenObjectEnd);
+    }
+    if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
+    if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
+      JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
+      return addErrorAndRecover(
+          msg, tokenName, tokenObjectEnd);
+    }
+    Value& value = currentValue()[name];
+    nodes_.push(&value);
+    bool ok = readValue();
+    nodes_.pop();
+    if (!ok) // error already set
+      return recoverFromError(tokenObjectEnd);
+
+    Token comma;
+    if (!readToken(comma) ||
+        (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
+         comma.type_ != tokenComment)) {
+      return addErrorAndRecover(
+          "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
+    }
+    bool finalizeTokenOk = true;
+    while (comma.type_ == tokenComment && finalizeTokenOk)
+      finalizeTokenOk = readToken(comma);
+    if (comma.type_ == tokenObjectEnd)
+      return true;
+  }
+  return addErrorAndRecover(
+      "Missing '}' or object member name", tokenName, tokenObjectEnd);
+}
+
+bool OurReader::readArray(Token& tokenStart) {
+  Value init(arrayValue);
+  currentValue().swapPayload(init);
+  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  skipSpaces();
+  if (current_ != end_ && *current_ == ']') // empty array
+  {
+    Token endArray;
+    readToken(endArray);
+    return true;
+  }
+  int index = 0;
+  for (;;) {
+    Value& value = currentValue()[index++];
+    nodes_.push(&value);
+    bool ok = readValue();
+    nodes_.pop();
+    if (!ok) // error already set
+      return recoverFromError(tokenArrayEnd);
+
+    Token token;
+    // Accept Comment after last item in the array.
+    ok = readToken(token);
+    while (token.type_ == tokenComment && ok) {
+      ok = readToken(token);
+    }
+    bool badTokenType =
+        (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
+    if (!ok || badTokenType) {
+      return addErrorAndRecover(
+          "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
+    }
+    if (token.type_ == tokenArrayEnd)
+      break;
+  }
+  return true;
+}
+
+bool OurReader::decodeNumber(Token& token) {
+  Value decoded;
+  if (!decodeNumber(token, decoded))
+    return false;
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool OurReader::decodeNumber(Token& token, Value& decoded) {
+  // Attempts to parse the number as an integer. If the number is
+  // larger than the maximum supported value of an integer then
+  // we decode the number as a double.
+  Location current = token.start_;
+  bool isNegative = *current == '-';
+  if (isNegative)
+    ++current;
+  // TODO: Help the compiler do the div and mod at compile time or get rid of them.
+  Value::LargestUInt maxIntegerValue =
+      isNegative ? Value::LargestUInt(-Value::minLargestInt)
+                 : Value::maxLargestUInt;
+  Value::LargestUInt threshold = maxIntegerValue / 10;
+  Value::LargestUInt value = 0;
+  while (current < token.end_) {
+    Char c = *current++;
+    if (c < '0' || c > '9')
+      return decodeDouble(token, decoded);
+    Value::UInt digit(static_cast<Value::UInt>(c - '0'));
+    if (value >= threshold) {
+      // We've hit or exceeded the max value divided by 10 (rounded down). If
+      // a) we've only just touched the limit, b) this is the last digit, and
+      // c) it's small enough to fit in that rounding delta, we're okay.
+      // Otherwise treat this number as a double to avoid overflow.
+      if (value > threshold || current != token.end_ ||
+          digit > maxIntegerValue % 10) {
+        return decodeDouble(token, decoded);
+      }
+    }
+    value = value * 10 + digit;
+  }
+  if (isNegative)
+    decoded = -Value::LargestInt(value);
+  else if (value <= Value::LargestUInt(Value::maxInt))
+    decoded = Value::LargestInt(value);
+  else
+    decoded = value;
+  return true;
+}
+
+bool OurReader::decodeDouble(Token& token) {
+  Value decoded;
+  if (!decodeDouble(token, decoded))
+    return false;
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool OurReader::decodeDouble(Token& token, Value& decoded) {
+  double value = 0;
+  const int bufferSize = 32;
+  int count;
+  ptrdiff_t const length = token.end_ - token.start_;
+
+  // Sanity check to avoid buffer overflow exploits.
+  if (length < 0) {
+    return addError("Unable to parse token length", token);
+  }
+  size_t const ulength = static_cast<size_t>(length);
+
+  // Avoid using a string constant for the format control string given to
+  // sscanf, as this can cause hard to debug crashes on OS X. See here for more
+  // info:
+  //
+  //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
+  char format[] = "%lf";
+
+  if (length <= bufferSize) {
+    Char buffer[bufferSize + 1];
+    memcpy(buffer, token.start_, ulength);
+    buffer[length] = 0;
+    fixNumericLocaleInput(buffer, buffer + length);
+    count = sscanf(buffer, format, &value);
+  } else {
+    JSONCPP_STRING buffer(token.start_, token.end_);
+    count = sscanf(buffer.c_str(), format, &value);
+  }
+
+  if (count != 1)
+    return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
+                        "' is not a number.",
+                    token);
+  decoded = value;
+  return true;
+}
+
+bool OurReader::decodeString(Token& token) {
+  JSONCPP_STRING decoded_string;
+  if (!decodeString(token, decoded_string))
+    return false;
+  Value decoded(decoded_string);
+  currentValue().swapPayload(decoded);
+  currentValue().setOffsetStart(token.start_ - begin_);
+  currentValue().setOffsetLimit(token.end_ - begin_);
+  return true;
+}
+
+bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
+  decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
+  Location current = token.start_ + 1; // skip '"'
+  Location end = token.end_ - 1;       // do not include '"'
+  while (current != end) {
+    Char c = *current++;
+    if (c == '"')
+      break;
+    else if (c == '\\') {
+      if (current == end)
+        return addError("Empty escape sequence in string", token, current);
+      Char escape = *current++;
+      switch (escape) {
+      case '"':
+        decoded += '"';
+        break;
+      case '/':
+        decoded += '/';
+        break;
+      case '\\':
+        decoded += '\\';
+        break;
+      case 'b':
+        decoded += '\b';
+        break;
+      case 'f':
+        decoded += '\f';
+        break;
+      case 'n':
+        decoded += '\n';
+        break;
+      case 'r':
+        decoded += '\r';
+        break;
+      case 't':
+        decoded += '\t';
+        break;
+      case 'u': {
+        unsigned int unicode;
+        if (!decodeUnicodeCodePoint(token, current, end, unicode))
+          return false;
+        decoded += codePointToUTF8(unicode);
+      } break;
+      default:
+        return addError("Bad escape sequence in string", token, current);
+      }
+    } else {
+      decoded += c;
+    }
+  }
+  return true;
+}
+
+bool OurReader::decodeUnicodeCodePoint(Token& token,
+                                    Location& current,
+                                    Location end,
+                                    unsigned int& unicode) {
+
+  if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
+    return false;
+  if (unicode >= 0xD800 && unicode <= 0xDBFF) {
+    // surrogate pairs
+    if (end - current < 6)
+      return addError(
+          "additional six characters expected to parse unicode surrogate pair.",
+          token,
+          current);
+    unsigned int surrogatePair;
+    if (*(current++) == '\\' && *(current++) == 'u') {
+      if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
+        unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
+      } else
+        return false;
+    } else
+      return addError("expecting another \\u token to begin the second half of "
+                      "a unicode surrogate pair",
+                      token,
+                      current);
+  }
+  return true;
+}
+
+bool OurReader::decodeUnicodeEscapeSequence(Token& token,
+                                         Location& current,
+                                         Location end,
+                                         unsigned int& ret_unicode) {
+  if (end - current < 4)
+    return addError(
+        "Bad unicode escape sequence in string: four digits expected.",
+        token,
+        current);
+  int unicode = 0;
+  for (int index = 0; index < 4; ++index) {
+    Char c = *current++;
+    unicode *= 16;
+    if (c >= '0' && c <= '9')
+      unicode += c - '0';
+    else if (c >= 'a' && c <= 'f')
+      unicode += c - 'a' + 10;
+    else if (c >= 'A' && c <= 'F')
+      unicode += c - 'A' + 10;
+    else
+      return addError(
+          "Bad unicode escape sequence in string: hexadecimal digit expected.",
+          token,
+          current);
+  }
+  ret_unicode = static_cast<unsigned int>(unicode);
+  return true;
+}
+
+bool
+OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = extra;
+  errors_.push_back(info);
+  return false;
+}
+
+bool OurReader::recoverFromError(TokenType skipUntilToken) {
+  size_t errorCount = errors_.size();
+  Token skip;
+  for (;;) {
+    if (!readToken(skip))
+      errors_.resize(errorCount); // discard errors caused by recovery
+    if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
+      break;
+  }
+  errors_.resize(errorCount);
+  return false;
+}
+
+bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
+                                Token& token,
+                                TokenType skipUntilToken) {
+  addError(message, token);
+  return recoverFromError(skipUntilToken);
+}
+
+Value& OurReader::currentValue() { return *(nodes_.top()); }
+
+OurReader::Char OurReader::getNextChar() {
+  if (current_ == end_)
+    return 0;
+  return *current_++;
+}
+
+void OurReader::getLocationLineAndColumn(Location location,
+                                      int& line,
+                                      int& column) const {
+  Location current = begin_;
+  Location lastLineStart = current;
+  line = 0;
+  while (current < location && current != end_) {
+    Char c = *current++;
+    if (c == '\r') {
+      if (*current == '\n')
+        ++current;
+      lastLineStart = current;
+      ++line;
+    } else if (c == '\n') {
+      lastLineStart = current;
+      ++line;
+    }
+  }
+  // column & line start at 1
+  column = int(location - lastLineStart) + 1;
+  ++line;
+}
+
+JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {
+  int line, column;
+  getLocationLineAndColumn(location, line, column);
+  char buffer[18 + 16 + 16 + 1];
+  snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
+  return buffer;
+}
+
+JSONCPP_STRING OurReader::getFormattedErrorMessages() const {
+  JSONCPP_STRING formattedMessage;
+  for (Errors::const_iterator itError = errors_.begin();
+       itError != errors_.end();
+       ++itError) {
+    const ErrorInfo& error = *itError;
+    formattedMessage +=
+        "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
+    formattedMessage += "  " + error.message_ + "\n";
+    if (error.extra_)
+      formattedMessage +=
+          "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
+  }
+  return formattedMessage;
+}
+
+std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
+  std::vector<OurReader::StructuredError> allErrors;
+  for (Errors::const_iterator itError = errors_.begin();
+       itError != errors_.end();
+       ++itError) {
+    const ErrorInfo& error = *itError;
+    OurReader::StructuredError structured;
+    structured.offset_start = error.token_.start_ - begin_;
+    structured.offset_limit = error.token_.end_ - begin_;
+    structured.message = error.message_;
+    allErrors.push_back(structured);
+  }
+  return allErrors;
+}
+
+bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message) {
+  ptrdiff_t length = end_ - begin_;
+  if(value.getOffsetStart() > length
+    || value.getOffsetLimit() > length)
+    return false;
+  Token token;
+  token.type_ = tokenError;
+  token.start_ = begin_ + value.getOffsetStart();
+  token.end_ = end_ + value.getOffsetLimit();
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = 0;
+  errors_.push_back(info);
+  return true;
+}
+
+bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
+  ptrdiff_t length = end_ - begin_;
+  if(value.getOffsetStart() > length
+    || value.getOffsetLimit() > length
+    || extra.getOffsetLimit() > length)
+    return false;
+  Token token;
+  token.type_ = tokenError;
+  token.start_ = begin_ + value.getOffsetStart();
+  token.end_ = begin_ + value.getOffsetLimit();
+  ErrorInfo info;
+  info.token_ = token;
+  info.message_ = message;
+  info.extra_ = begin_ + extra.getOffsetStart();
+  errors_.push_back(info);
+  return true;
+}
+
+bool OurReader::good() const {
+  return !errors_.size();
+}
+
+
+class OurCharReader : public CharReader {
+  bool const collectComments_;
+  OurReader reader_;
+public:
+  OurCharReader(
+    bool collectComments,
+    OurFeatures const& features)
+  : collectComments_(collectComments)
+  , reader_(features)
+  {}
+  bool parse(
+      char const* beginDoc, char const* endDoc,
+      Value* root, JSONCPP_STRING* errs) JSONCPP_OVERRIDE {
+    bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);
+    if (errs) {
+      *errs = reader_.getFormattedErrorMessages();
+    }
+    return ok;
+  }
+};
+
+CharReaderBuilder::CharReaderBuilder()
+{
+  setDefaults(&settings_);
+}
+CharReaderBuilder::~CharReaderBuilder()
+{}
+CharReader* CharReaderBuilder::newCharReader() const
+{
+  bool collectComments = settings_["collectComments"].asBool();
+  OurFeatures features = OurFeatures::all();
+  features.allowComments_ = settings_["allowComments"].asBool();
+  features.strictRoot_ = settings_["strictRoot"].asBool();
+  features.allowDroppedNullPlaceholders_ = settings_["allowDroppedNullPlaceholders"].asBool();
+  features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();
+  features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();
+  features.stackLimit_ = settings_["stackLimit"].asInt();
+  features.failIfExtra_ = settings_["failIfExtra"].asBool();
+  features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();
+  features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();
+  return new OurCharReader(collectComments, features);
+}
+static void getValidReaderKeys(std::set<JSONCPP_STRING>* valid_keys)
+{
+  valid_keys->clear();
+  valid_keys->insert("collectComments");
+  valid_keys->insert("allowComments");
+  valid_keys->insert("strictRoot");
+  valid_keys->insert("allowDroppedNullPlaceholders");
+  valid_keys->insert("allowNumericKeys");
+  valid_keys->insert("allowSingleQuotes");
+  valid_keys->insert("stackLimit");
+  valid_keys->insert("failIfExtra");
+  valid_keys->insert("rejectDupKeys");
+  valid_keys->insert("allowSpecialFloats");
+}
+bool CharReaderBuilder::validate(Json::Value* invalid) const
+{
+  Json::Value my_invalid;
+  if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
+  Json::Value& inv = *invalid;
+  std::set<JSONCPP_STRING> valid_keys;
+  getValidReaderKeys(&valid_keys);
+  Value::Members keys = settings_.getMemberNames();
+  size_t n = keys.size();
+  for (size_t i = 0; i < n; ++i) {
+    JSONCPP_STRING const& key = keys[i];
+    if (valid_keys.find(key) == valid_keys.end()) {
+      inv[key] = settings_[key];
+    }
+  }
+  return 0u == inv.size();
+}
+Value& CharReaderBuilder::operator[](JSONCPP_STRING key)
+{
+  return settings_[key];
+}
+// static
+void CharReaderBuilder::strictMode(Json::Value* settings)
+{
+//! [CharReaderBuilderStrictMode]
+  (*settings)["allowComments"] = false;
+  (*settings)["strictRoot"] = true;
+  (*settings)["allowDroppedNullPlaceholders"] = false;
+  (*settings)["allowNumericKeys"] = false;
+  (*settings)["allowSingleQuotes"] = false;
+  (*settings)["stackLimit"] = 1000;
+  (*settings)["failIfExtra"] = true;
+  (*settings)["rejectDupKeys"] = true;
+  (*settings)["allowSpecialFloats"] = false;
+//! [CharReaderBuilderStrictMode]
+}
+// static
+void CharReaderBuilder::setDefaults(Json::Value* settings)
+{
+//! [CharReaderBuilderDefaults]
+  (*settings)["collectComments"] = true;
+  (*settings)["allowComments"] = true;
+  (*settings)["strictRoot"] = false;
+  (*settings)["allowDroppedNullPlaceholders"] = false;
+  (*settings)["allowNumericKeys"] = false;
+  (*settings)["allowSingleQuotes"] = false;
+  (*settings)["stackLimit"] = 1000;
+  (*settings)["failIfExtra"] = false;
+  (*settings)["rejectDupKeys"] = false;
+  (*settings)["allowSpecialFloats"] = false;
+//! [CharReaderBuilderDefaults]
+}
+
+//////////////////////////////////
+// global functions
+
+bool parseFromStream(
+    CharReader::Factory const& fact, JSONCPP_ISTREAM& sin,
+    Value* root, JSONCPP_STRING* errs)
+{
+  JSONCPP_OSTRINGSTREAM ssin;
+  ssin << sin.rdbuf();
+  JSONCPP_STRING doc = ssin.str();
+  char const* begin = doc.data();
+  char const* end = begin + doc.size();
+  // Note that we do not actually need a null-terminator.
+  CharReaderPtr const reader(fact.newCharReader());
+  return reader->parse(begin, end, root, errs);
+}
+
+JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM& sin, Value& root) {
+  CharReaderBuilder b;
+  JSONCPP_STRING errs;
+  bool ok = parseFromStream(b, sin, &root, &errs);
+  if (!ok) {
+    fprintf(stderr,
+            "Error from reader: %s",
+            errs.c_str());
+
+    throwRuntimeError(errs);
+  }
+  return sin;
+}
+
+} // namespace Json
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_tool.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_tool.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_tool.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_tool.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,111 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED
+#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED
+
+#ifndef NO_LOCALE_SUPPORT
+#include <clocale>
+#endif
+
+/* This header provides common string manipulation support, such as UTF-8,
+ * portable conversion from/to string...
+ *
+ * It is an internal header that must not be exposed.
+ */
+
+namespace Json {
+static char getDecimalPoint() {
+#ifdef NO_LOCALE_SUPPORT
+  return '\0';
+#else
+  struct lconv* lc = localeconv();
+  return lc ? *(lc->decimal_point) : '\0';
+#endif
+}
+
+/// Converts a unicode code-point to UTF-8.
+static inline JSONCPP_STRING codePointToUTF8(unsigned int cp) {
+  JSONCPP_STRING result;
+
+  // based on description from http://en.wikipedia.org/wiki/UTF-8
+
+  if (cp <= 0x7f) {
+    result.resize(1);
+    result[0] = static_cast<char>(cp);
+  } else if (cp <= 0x7FF) {
+    result.resize(2);
+    result[1] = static_cast<char>(0x80 | (0x3f & cp));
+    result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));
+  } else if (cp <= 0xFFFF) {
+    result.resize(3);
+    result[2] = static_cast<char>(0x80 | (0x3f & cp));
+    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
+    result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));
+  } else if (cp <= 0x10FFFF) {
+    result.resize(4);
+    result[3] = static_cast<char>(0x80 | (0x3f & cp));
+    result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
+    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));
+    result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));
+  }
+
+  return result;
+}
+
+/// Returns true if ch is a control character (in range [1,31]).
+static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }
+
+enum {
+  /// Constant that specify the size of the buffer that must be passed to
+  /// uintToString.
+  uintToStringBufferSize = 3 * sizeof(LargestUInt) + 1
+};
+
+// Defines a char buffer for use with uintToString().
+typedef char UIntToStringBuffer[uintToStringBufferSize];
+
+/** Converts an unsigned integer to string.
+ * @param value Unsigned interger to convert to string
+ * @param current Input/Output string buffer.
+ *        Must have at least uintToStringBufferSize chars free.
+ */
+static inline void uintToString(LargestUInt value, char*& current) {
+  *--current = 0;
+  do {
+    *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));
+    value /= 10;
+  } while (value != 0);
+}
+
+/** Change ',' to '.' everywhere in buffer.
+ *
+ * We had a sophisticated way, but it did not work in WinCE.
+ * @see https://github.com/open-source-parsers/jsoncpp/pull/9
+ */
+static inline void fixNumericLocale(char* begin, char* end) {
+  while (begin < end) {
+    if (*begin == ',') {
+      *begin = '.';
+    }
+    ++begin;
+  }
+}
+
+static inline void fixNumericLocaleInput(char* begin, char* end) {
+  char decimalPoint = getDecimalPoint();
+  if (decimalPoint != '\0' && decimalPoint != '.') {
+    while (begin < end) {
+      if (*begin == '.') {
+        *begin = decimalPoint;
+      }
+      ++begin;
+    }
+  }
+}
+
+} // namespace Json {
+
+#endif // LIB_JSONCPP_JSON_TOOL_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_value.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_value.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_value.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_value.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,1604 @@
+// Copyright 2011 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include <json/assertions.h>
+#include <json/value.h>
+#include <json/writer.h>
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <math.h>
+#include <sstream>
+#include <utility>
+#include <cstring>
+#include <cassert>
+#ifdef JSON_USE_CPPTL
+#include <cpptl/conststring.h>
+#endif
+#include <cstddef> // size_t
+#include <algorithm> // min()
+
+#define JSON_ASSERT_UNREACHABLE assert(false)
+
+namespace Json {
+
+// This is a walkaround to avoid the static initialization of Value::null.
+// kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
+// 8 (instead of 4) as a bit of future-proofing.
+#if defined(__ARMEL__)
+#define ALIGNAS(byte_alignment) __attribute__((aligned(byte_alignment)))
+#else
+#define ALIGNAS(byte_alignment)
+#endif
+//static const unsigned char ALIGNAS(8) kNull[sizeof(Value)] = { 0 };
+//const unsigned char& kNullRef = kNull[0];
+//const Value& Value::null = reinterpret_cast<const Value&>(kNullRef);
+//const Value& Value::nullRef = null;
+
+// static
+Value const& Value::nullSingleton()
+{
+ static Value const nullStatic;
+ return nullStatic;
+}
+
+// for backwards compatibility, we'll leave these global references around, but DO NOT
+// use them in JSONCPP library code any more!
+Value const& Value::null = Value::nullSingleton();
+Value const& Value::nullRef = Value::nullSingleton();
+
+const Int Value::minInt = Int(~(UInt(-1) / 2));
+const Int Value::maxInt = Int(UInt(-1) / 2);
+const UInt Value::maxUInt = UInt(-1);
+#if defined(JSON_HAS_INT64)
+const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
+const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
+const UInt64 Value::maxUInt64 = UInt64(-1);
+// The constant is hard-coded because some compiler have trouble
+// converting Value::maxUInt64 to a double correctly (AIX/xlC).
+// Assumes that UInt64 is a 64 bits integer.
+static const double maxUInt64AsDouble = 18446744073709551615.0;
+#endif // defined(JSON_HAS_INT64)
+const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
+const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
+const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
+
+#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+template <typename T, typename U>
+static inline bool InRange(double d, T min, U max) {
+  // The casts can lose precision, but we are looking only for
+  // an approximate range. Might fail on edge cases though. ~cdunn
+  //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
+  return d >= min && d <= max;
+}
+#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+static inline double integerToDouble(Json::UInt64 value) {
+  return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
+}
+
+template <typename T> static inline double integerToDouble(T value) {
+  return static_cast<double>(value);
+}
+
+template <typename T, typename U>
+static inline bool InRange(double d, T min, U max) {
+  return d >= integerToDouble(min) && d <= integerToDouble(max);
+}
+#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+
+/** Duplicates the specified string value.
+ * @param value Pointer to the string to duplicate. Must be zero-terminated if
+ *              length is "unknown".
+ * @param length Length of the value. if equals to unknown, then it will be
+ *               computed using strlen(value).
+ * @return Pointer on the duplicate instance of string.
+ */
+static inline char* duplicateStringValue(const char* value,
+                                         size_t length)
+{
+  // Avoid an integer overflow in the call to malloc below by limiting length
+  // to a sane value.
+  if (length >= static_cast<size_t>(Value::maxInt))
+    length = Value::maxInt - 1;
+
+  char* newString = static_cast<char*>(malloc(length + 1));
+  if (newString == NULL) {
+    throwRuntimeError(
+        "in Json::Value::duplicateStringValue(): "
+        "Failed to allocate string value buffer");
+  }
+  memcpy(newString, value, length);
+  newString[length] = 0;
+  return newString;
+}
+
+/* Record the length as a prefix.
+ */
+static inline char* duplicateAndPrefixStringValue(
+    const char* value,
+    unsigned int length)
+{
+  // Avoid an integer overflow in the call to malloc below by limiting length
+  // to a sane value.
+  JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
+                      "in Json::Value::duplicateAndPrefixStringValue(): "
+                      "length too big for prefixing");
+  unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
+  char* newString = static_cast<char*>(malloc(actualLength));
+  if (newString == 0) {
+    throwRuntimeError(
+        "in Json::Value::duplicateAndPrefixStringValue(): "
+        "Failed to allocate string value buffer");
+  }
+  *reinterpret_cast<unsigned*>(newString) = length;
+  memcpy(newString + sizeof(unsigned), value, length);
+  newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
+  return newString;
+}
+inline static void decodePrefixedString(
+    bool isPrefixed, char const* prefixed,
+    unsigned* length, char const** value)
+{
+  if (!isPrefixed) {
+    *length = static_cast<unsigned>(strlen(prefixed));
+    *value = prefixed;
+  } else {
+    *length = *reinterpret_cast<unsigned const*>(prefixed);
+    *value = prefixed + sizeof(unsigned);
+  }
+}
+/** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
+ */
+#if JSONCPP_USING_SECURE_MEMORY
+static inline void releasePrefixedStringValue(char* value) {
+  unsigned length = 0;
+  char const* valueDecoded;
+  decodePrefixedString(true, value, &length, &valueDecoded);
+  size_t const size = sizeof(unsigned) + length + 1U;
+  memset(value, 0, size);
+  free(value);
+}
+static inline void releaseStringValue(char* value, unsigned length) {
+  // length==0 => we allocated the strings memory
+  size_t size = (length==0) ? strlen(value) : length;
+  memset(value, 0, size);
+  free(value);
+}
+#else // !JSONCPP_USING_SECURE_MEMORY
+static inline void releasePrefixedStringValue(char* value) {
+  free(value);
+}
+static inline void releaseStringValue(char* value, unsigned) {
+  free(value);
+}
+#endif // JSONCPP_USING_SECURE_MEMORY
+
+} // namespace Json
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// ValueInternals...
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+#if !defined(JSON_IS_AMALGAMATION)
+
+#include "json_valueiterator.inl"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+
+namespace Json {
+
+Exception::Exception(JSONCPP_STRING const& msg)
+  : msg_(msg)
+{}
+Exception::~Exception() throw()
+{}
+char const* Exception::what() const throw()
+{
+  return msg_.c_str();
+}
+RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
+  : Exception(msg)
+{}
+LogicError::LogicError(JSONCPP_STRING const& msg)
+  : Exception(msg)
+{}
+JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
+{
+  throw RuntimeError(msg);
+}
+JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
+{
+  throw LogicError(msg);
+}
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class Value::CommentInfo
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+Value::CommentInfo::CommentInfo() : comment_(0)
+{}
+
+Value::CommentInfo::~CommentInfo() {
+  if (comment_)
+    releaseStringValue(comment_, 0u);
+}
+
+void Value::CommentInfo::setComment(const char* text, size_t len) {
+  if (comment_) {
+    releaseStringValue(comment_, 0u);
+    comment_ = 0;
+  }
+  JSON_ASSERT(text != 0);
+  JSON_ASSERT_MESSAGE(
+      text[0] == '\0' || text[0] == '/',
+      "in Json::Value::setComment(): Comments must start with /");
+  // It seems that /**/ style comments are acceptable as well.
+  comment_ = duplicateStringValue(text, len);
+}
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class Value::CZString
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+// Notes: policy_ indicates if the string was allocated when
+// a string is stored.
+
+Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
+
+Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
+    : cstr_(str) {
+  // allocate != duplicate
+  storage_.policy_ = allocate & 0x3;
+  storage_.length_ = ulength & 0x3FFFFFFF;
+}
+
+Value::CZString::CZString(const CZString& other) {
+  cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
+				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
+				 : other.cstr_);
+  storage_.policy_ = static_cast<unsigned>(other.cstr_
+                 ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
+                     ? noDuplication : duplicate)
+                 : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
+  storage_.length_ = other.storage_.length_;
+}
+
+#if JSON_HAS_RVALUE_REFERENCES
+Value::CZString::CZString(CZString&& other)
+  : cstr_(other.cstr_), index_(other.index_) {
+  other.cstr_ = nullptr;
+}
+#endif
+
+Value::CZString::~CZString() {
+  if (cstr_ && storage_.policy_ == duplicate) {
+	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
+  }
+}
+
+void Value::CZString::swap(CZString& other) {
+  std::swap(cstr_, other.cstr_);
+  std::swap(index_, other.index_);
+}
+
+Value::CZString& Value::CZString::operator=(CZString other) {
+  swap(other);
+  return *this;
+}
+
+bool Value::CZString::operator<(const CZString& other) const {
+  if (!cstr_) return index_ < other.index_;
+  //return strcmp(cstr_, other.cstr_) < 0;
+  // Assume both are strings.
+  unsigned this_len = this->storage_.length_;
+  unsigned other_len = other.storage_.length_;
+  unsigned min_len = std::min(this_len, other_len);
+  JSON_ASSERT(this->cstr_ && other.cstr_);
+  int comp = memcmp(this->cstr_, other.cstr_, min_len);
+  if (comp < 0) return true;
+  if (comp > 0) return false;
+  return (this_len < other_len);
+}
+
+bool Value::CZString::operator==(const CZString& other) const {
+  if (!cstr_) return index_ == other.index_;
+  //return strcmp(cstr_, other.cstr_) == 0;
+  // Assume both are strings.
+  unsigned this_len = this->storage_.length_;
+  unsigned other_len = other.storage_.length_;
+  if (this_len != other_len) return false;
+  JSON_ASSERT(this->cstr_ && other.cstr_);
+  int comp = memcmp(this->cstr_, other.cstr_, this_len);
+  return comp == 0;
+}
+
+ArrayIndex Value::CZString::index() const { return index_; }
+
+//const char* Value::CZString::c_str() const { return cstr_; }
+const char* Value::CZString::data() const { return cstr_; }
+unsigned Value::CZString::length() const { return storage_.length_; }
+bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class Value::Value
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+/*! \internal Default constructor initialization must be equivalent to:
+ * memset( this, 0, sizeof(Value) )
+ * This optimization is used in ValueInternalMap fast allocator.
+ */
+Value::Value(ValueType vtype) {
+  static char const empty[] = "";
+  initBasic(vtype);
+  switch (vtype) {
+  case nullValue:
+    break;
+  case intValue:
+  case uintValue:
+    value_.int_ = 0;
+    break;
+  case realValue:
+    value_.real_ = 0.0;
+    break;
+  case stringValue:
+    // allocated_ == false, so this is safe.
+    value_.string_ = const_cast<char*>(static_cast<char const*>(empty));
+    break;
+  case arrayValue:
+  case objectValue:
+    value_.map_ = new ObjectValues();
+    break;
+  case booleanValue:
+    value_.bool_ = false;
+    break;
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+}
+
+Value::Value(Int value) {
+  initBasic(intValue);
+  value_.int_ = value;
+}
+
+Value::Value(UInt value) {
+  initBasic(uintValue);
+  value_.uint_ = value;
+}
+#if defined(JSON_HAS_INT64)
+Value::Value(Int64 value) {
+  initBasic(intValue);
+  value_.int_ = value;
+}
+Value::Value(UInt64 value) {
+  initBasic(uintValue);
+  value_.uint_ = value;
+}
+#endif // defined(JSON_HAS_INT64)
+
+Value::Value(double value) {
+  initBasic(realValue);
+  value_.real_ = value;
+}
+
+Value::Value(const char* value) {
+  initBasic(stringValue, true);
+  value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
+}
+
+Value::Value(const char* beginValue, const char* endValue) {
+  initBasic(stringValue, true);
+  value_.string_ =
+      duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
+}
+
+Value::Value(const JSONCPP_STRING& value) {
+  initBasic(stringValue, true);
+  value_.string_ =
+      duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
+}
+
+Value::Value(const StaticString& value) {
+  initBasic(stringValue);
+  value_.string_ = const_cast<char*>(value.c_str());
+}
+
+#ifdef JSON_USE_CPPTL
+Value::Value(const CppTL::ConstString& value) {
+  initBasic(stringValue, true);
+  value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
+}
+#endif
+
+Value::Value(bool value) {
+  initBasic(booleanValue);
+  value_.bool_ = value;
+}
+
+Value::Value(Value const& other)
+    : type_(other.type_), allocated_(false)
+      ,
+      comments_(0), start_(other.start_), limit_(other.limit_)
+{
+  switch (type_) {
+  case nullValue:
+  case intValue:
+  case uintValue:
+  case realValue:
+  case booleanValue:
+    value_ = other.value_;
+    break;
+  case stringValue:
+    if (other.value_.string_ && other.allocated_) {
+      unsigned len;
+      char const* str;
+      decodePrefixedString(other.allocated_, other.value_.string_,
+          &len, &str);
+      value_.string_ = duplicateAndPrefixStringValue(str, len);
+      allocated_ = true;
+    } else {
+      value_.string_ = other.value_.string_;
+      allocated_ = false;
+    }
+    break;
+  case arrayValue:
+  case objectValue:
+    value_.map_ = new ObjectValues(*other.value_.map_);
+    break;
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+  if (other.comments_) {
+    comments_ = new CommentInfo[numberOfCommentPlacement];
+    for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
+      const CommentInfo& otherComment = other.comments_[comment];
+      if (otherComment.comment_)
+        comments_[comment].setComment(
+            otherComment.comment_, strlen(otherComment.comment_));
+    }
+  }
+}
+
+#if JSON_HAS_RVALUE_REFERENCES
+// Move constructor
+Value::Value(Value&& other) {
+  initBasic(nullValue);
+  swap(other);
+}
+#endif
+
+Value::~Value() {
+  switch (type_) {
+  case nullValue:
+  case intValue:
+  case uintValue:
+  case realValue:
+  case booleanValue:
+    break;
+  case stringValue:
+    if (allocated_)
+      releasePrefixedStringValue(value_.string_);
+    break;
+  case arrayValue:
+  case objectValue:
+    delete value_.map_;
+    break;
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+
+  delete[] comments_;
+
+  value_.uint_ = 0;
+}
+
+Value& Value::operator=(Value other) {
+  swap(other);
+  return *this;
+}
+
+void Value::swapPayload(Value& other) {
+  ValueType temp = type_;
+  type_ = other.type_;
+  other.type_ = temp;
+  std::swap(value_, other.value_);
+  int temp2 = allocated_;
+  allocated_ = other.allocated_;
+  other.allocated_ = temp2 & 0x1;
+}
+
+void Value::swap(Value& other) {
+  swapPayload(other);
+  std::swap(comments_, other.comments_);
+  std::swap(start_, other.start_);
+  std::swap(limit_, other.limit_);
+}
+
+ValueType Value::type() const { return type_; }
+
+int Value::compare(const Value& other) const {
+  if (*this < other)
+    return -1;
+  if (*this > other)
+    return 1;
+  return 0;
+}
+
+bool Value::operator<(const Value& other) const {
+  int typeDelta = type_ - other.type_;
+  if (typeDelta)
+    return typeDelta < 0 ? true : false;
+  switch (type_) {
+  case nullValue:
+    return false;
+  case intValue:
+    return value_.int_ < other.value_.int_;
+  case uintValue:
+    return value_.uint_ < other.value_.uint_;
+  case realValue:
+    return value_.real_ < other.value_.real_;
+  case booleanValue:
+    return value_.bool_ < other.value_.bool_;
+  case stringValue:
+  {
+    if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
+      if (other.value_.string_) return true;
+      else return false;
+    }
+    unsigned this_len;
+    unsigned other_len;
+    char const* this_str;
+    char const* other_str;
+    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+    decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
+    unsigned min_len = std::min(this_len, other_len);
+    JSON_ASSERT(this_str && other_str);
+    int comp = memcmp(this_str, other_str, min_len);
+    if (comp < 0) return true;
+    if (comp > 0) return false;
+    return (this_len < other_len);
+  }
+  case arrayValue:
+  case objectValue: {
+    int delta = int(value_.map_->size() - other.value_.map_->size());
+    if (delta)
+      return delta < 0;
+    return (*value_.map_) < (*other.value_.map_);
+  }
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+  return false; // unreachable
+}
+
+bool Value::operator<=(const Value& other) const { return !(other < *this); }
+
+bool Value::operator>=(const Value& other) const { return !(*this < other); }
+
+bool Value::operator>(const Value& other) const { return other < *this; }
+
+bool Value::operator==(const Value& other) const {
+  // if ( type_ != other.type_ )
+  // GCC 2.95.3 says:
+  // attempt to take address of bit-field structure member `Json::Value::type_'
+  // Beats me, but a temp solves the problem.
+  int temp = other.type_;
+  if (type_ != temp)
+    return false;
+  switch (type_) {
+  case nullValue:
+    return true;
+  case intValue:
+    return value_.int_ == other.value_.int_;
+  case uintValue:
+    return value_.uint_ == other.value_.uint_;
+  case realValue:
+    return value_.real_ == other.value_.real_;
+  case booleanValue:
+    return value_.bool_ == other.value_.bool_;
+  case stringValue:
+  {
+    if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
+      return (value_.string_ == other.value_.string_);
+    }
+    unsigned this_len;
+    unsigned other_len;
+    char const* this_str;
+    char const* other_str;
+    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+    decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
+    if (this_len != other_len) return false;
+    JSON_ASSERT(this_str && other_str);
+    int comp = memcmp(this_str, other_str, this_len);
+    return comp == 0;
+  }
+  case arrayValue:
+  case objectValue:
+    return value_.map_->size() == other.value_.map_->size() &&
+           (*value_.map_) == (*other.value_.map_);
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+  return false; // unreachable
+}
+
+bool Value::operator!=(const Value& other) const { return !(*this == other); }
+
+const char* Value::asCString() const {
+  JSON_ASSERT_MESSAGE(type_ == stringValue,
+                      "in Json::Value::asCString(): requires stringValue");
+  if (value_.string_ == 0) return 0;
+  unsigned this_len;
+  char const* this_str;
+  decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+  return this_str;
+}
+
+#if JSONCPP_USING_SECURE_MEMORY
+unsigned Value::getCStringLength() const {
+  JSON_ASSERT_MESSAGE(type_ == stringValue,
+	                  "in Json::Value::asCString(): requires stringValue");
+  if (value_.string_ == 0) return 0;
+  unsigned this_len;
+  char const* this_str;
+  decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+  return this_len;
+}
+#endif
+
+bool Value::getString(char const** str, char const** cend) const {
+  if (type_ != stringValue) return false;
+  if (value_.string_ == 0) return false;
+  unsigned length;
+  decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
+  *cend = *str + length;
+  return true;
+}
+
+JSONCPP_STRING Value::asString() const {
+  switch (type_) {
+  case nullValue:
+    return "";
+  case stringValue:
+  {
+    if (value_.string_ == 0) return "";
+    unsigned this_len;
+    char const* this_str;
+    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+    return JSONCPP_STRING(this_str, this_len);
+  }
+  case booleanValue:
+    return value_.bool_ ? "true" : "false";
+  case intValue:
+    return valueToString(value_.int_);
+  case uintValue:
+    return valueToString(value_.uint_);
+  case realValue:
+    return valueToString(value_.real_);
+  default:
+    JSON_FAIL_MESSAGE("Type is not convertible to string");
+  }
+}
+
+#ifdef JSON_USE_CPPTL
+CppTL::ConstString Value::asConstString() const {
+  unsigned len;
+  char const* str;
+  decodePrefixedString(allocated_, value_.string_,
+      &len, &str);
+  return CppTL::ConstString(str, len);
+}
+#endif
+
+Value::Int Value::asInt() const {
+  switch (type_) {
+  case intValue:
+    JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
+    return Int(value_.int_);
+  case uintValue:
+    JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
+    return Int(value_.uint_);
+  case realValue:
+    JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
+                        "double out of Int range");
+    return Int(value_.real_);
+  case nullValue:
+    return 0;
+  case booleanValue:
+    return value_.bool_ ? 1 : 0;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to Int.");
+}
+
+Value::UInt Value::asUInt() const {
+  switch (type_) {
+  case intValue:
+    JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
+    return UInt(value_.int_);
+  case uintValue:
+    JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
+    return UInt(value_.uint_);
+  case realValue:
+    JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
+                        "double out of UInt range");
+    return UInt(value_.real_);
+  case nullValue:
+    return 0;
+  case booleanValue:
+    return value_.bool_ ? 1 : 0;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
+}
+
+#if defined(JSON_HAS_INT64)
+
+Value::Int64 Value::asInt64() const {
+  switch (type_) {
+  case intValue:
+    return Int64(value_.int_);
+  case uintValue:
+    JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
+    return Int64(value_.uint_);
+  case realValue:
+    JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
+                        "double out of Int64 range");
+    return Int64(value_.real_);
+  case nullValue:
+    return 0;
+  case booleanValue:
+    return value_.bool_ ? 1 : 0;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
+}
+
+Value::UInt64 Value::asUInt64() const {
+  switch (type_) {
+  case intValue:
+    JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
+    return UInt64(value_.int_);
+  case uintValue:
+    return UInt64(value_.uint_);
+  case realValue:
+    JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
+                        "double out of UInt64 range");
+    return UInt64(value_.real_);
+  case nullValue:
+    return 0;
+  case booleanValue:
+    return value_.bool_ ? 1 : 0;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
+}
+#endif // if defined(JSON_HAS_INT64)
+
+LargestInt Value::asLargestInt() const {
+#if defined(JSON_NO_INT64)
+  return asInt();
+#else
+  return asInt64();
+#endif
+}
+
+LargestUInt Value::asLargestUInt() const {
+#if defined(JSON_NO_INT64)
+  return asUInt();
+#else
+  return asUInt64();
+#endif
+}
+
+double Value::asDouble() const {
+  switch (type_) {
+  case intValue:
+    return static_cast<double>(value_.int_);
+  case uintValue:
+#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+    return static_cast<double>(value_.uint_);
+#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+    return integerToDouble(value_.uint_);
+#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+  case realValue:
+    return value_.real_;
+  case nullValue:
+    return 0.0;
+  case booleanValue:
+    return value_.bool_ ? 1.0 : 0.0;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to double.");
+}
+
+float Value::asFloat() const {
+  switch (type_) {
+  case intValue:
+    return static_cast<float>(value_.int_);
+  case uintValue:
+#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+    return static_cast<float>(value_.uint_);
+#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+    // This can fail (silently?) if the value is bigger than MAX_FLOAT.
+    return static_cast<float>(integerToDouble(value_.uint_));
+#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+  case realValue:
+    return static_cast<float>(value_.real_);
+  case nullValue:
+    return 0.0;
+  case booleanValue:
+    return value_.bool_ ? 1.0f : 0.0f;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to float.");
+}
+
+bool Value::asBool() const {
+  switch (type_) {
+  case booleanValue:
+    return value_.bool_;
+  case nullValue:
+    return false;
+  case intValue:
+    return value_.int_ ? true : false;
+  case uintValue:
+    return value_.uint_ ? true : false;
+  case realValue:
+    // This is kind of strange. Not recommended.
+    return (value_.real_ != 0.0) ? true : false;
+  default:
+    break;
+  }
+  JSON_FAIL_MESSAGE("Value is not convertible to bool.");
+}
+
+bool Value::isConvertibleTo(ValueType other) const {
+  switch (other) {
+  case nullValue:
+    return (isNumeric() && asDouble() == 0.0) ||
+           (type_ == booleanValue && value_.bool_ == false) ||
+           (type_ == stringValue && asString() == "") ||
+           (type_ == arrayValue && value_.map_->size() == 0) ||
+           (type_ == objectValue && value_.map_->size() == 0) ||
+           type_ == nullValue;
+  case intValue:
+    return isInt() ||
+           (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
+           type_ == booleanValue || type_ == nullValue;
+  case uintValue:
+    return isUInt() ||
+           (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
+           type_ == booleanValue || type_ == nullValue;
+  case realValue:
+    return isNumeric() || type_ == booleanValue || type_ == nullValue;
+  case booleanValue:
+    return isNumeric() || type_ == booleanValue || type_ == nullValue;
+  case stringValue:
+    return isNumeric() || type_ == booleanValue || type_ == stringValue ||
+           type_ == nullValue;
+  case arrayValue:
+    return type_ == arrayValue || type_ == nullValue;
+  case objectValue:
+    return type_ == objectValue || type_ == nullValue;
+  }
+  JSON_ASSERT_UNREACHABLE;
+  return false;
+}
+
+/// Number of values in array or object
+ArrayIndex Value::size() const {
+  switch (type_) {
+  case nullValue:
+  case intValue:
+  case uintValue:
+  case realValue:
+  case booleanValue:
+  case stringValue:
+    return 0;
+  case arrayValue: // size of the array is highest index + 1
+    if (!value_.map_->empty()) {
+      ObjectValues::const_iterator itLast = value_.map_->end();
+      --itLast;
+      return (*itLast).first.index() + 1;
+    }
+    return 0;
+  case objectValue:
+    return ArrayIndex(value_.map_->size());
+  }
+  JSON_ASSERT_UNREACHABLE;
+  return 0; // unreachable;
+}
+
+bool Value::empty() const {
+  if (isNull() || isArray() || isObject())
+    return size() == 0u;
+  else
+    return false;
+}
+
+bool Value::operator!() const { return isNull(); }
+
+void Value::clear() {
+  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
+                          type_ == objectValue,
+                      "in Json::Value::clear(): requires complex value");
+  start_ = 0;
+  limit_ = 0;
+  switch (type_) {
+  case arrayValue:
+  case objectValue:
+    value_.map_->clear();
+    break;
+  default:
+    break;
+  }
+}
+
+void Value::resize(ArrayIndex newSize) {
+  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
+                      "in Json::Value::resize(): requires arrayValue");
+  if (type_ == nullValue)
+    *this = Value(arrayValue);
+  ArrayIndex oldSize = size();
+  if (newSize == 0)
+    clear();
+  else if (newSize > oldSize)
+    (*this)[newSize - 1];
+  else {
+    for (ArrayIndex index = newSize; index < oldSize; ++index) {
+      value_.map_->erase(index);
+    }
+    JSON_ASSERT(size() == newSize);
+  }
+}
+
+Value& Value::operator[](ArrayIndex index) {
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == arrayValue,
+      "in Json::Value::operator[](ArrayIndex): requires arrayValue");
+  if (type_ == nullValue)
+    *this = Value(arrayValue);
+  CZString key(index);
+  ObjectValues::iterator it = value_.map_->lower_bound(key);
+  if (it != value_.map_->end() && (*it).first == key)
+    return (*it).second;
+
+  ObjectValues::value_type defaultValue(key, nullSingleton());
+  it = value_.map_->insert(it, defaultValue);
+  return (*it).second;
+}
+
+Value& Value::operator[](int index) {
+  JSON_ASSERT_MESSAGE(
+      index >= 0,
+      "in Json::Value::operator[](int index): index cannot be negative");
+  return (*this)[ArrayIndex(index)];
+}
+
+const Value& Value::operator[](ArrayIndex index) const {
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == arrayValue,
+      "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
+  if (type_ == nullValue)
+    return nullSingleton();
+  CZString key(index);
+  ObjectValues::const_iterator it = value_.map_->find(key);
+  if (it == value_.map_->end())
+    return nullSingleton();
+  return (*it).second;
+}
+
+const Value& Value::operator[](int index) const {
+  JSON_ASSERT_MESSAGE(
+      index >= 0,
+      "in Json::Value::operator[](int index) const: index cannot be negative");
+  return (*this)[ArrayIndex(index)];
+}
+
+void Value::initBasic(ValueType vtype, bool allocated) {
+  type_ = vtype;
+  allocated_ = allocated;
+  comments_ = 0;
+  start_ = 0;
+  limit_ = 0;
+}
+
+// Access an object value by name, create a null member if it does not exist.
+// @pre Type of '*this' is object or null.
+// @param key is null-terminated.
+Value& Value::resolveReference(const char* key) {
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == objectValue,
+      "in Json::Value::resolveReference(): requires objectValue");
+  if (type_ == nullValue)
+    *this = Value(objectValue);
+  CZString actualKey(
+      key, static_cast<unsigned>(strlen(key)), CZString::noDuplication); // NOTE!
+  ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
+  if (it != value_.map_->end() && (*it).first == actualKey)
+    return (*it).second;
+
+  ObjectValues::value_type defaultValue(actualKey, nullSingleton());
+  it = value_.map_->insert(it, defaultValue);
+  Value& value = (*it).second;
+  return value;
+}
+
+// @param key is not null-terminated.
+Value& Value::resolveReference(char const* key, char const* cend)
+{
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == objectValue,
+      "in Json::Value::resolveReference(key, end): requires objectValue");
+  if (type_ == nullValue)
+    *this = Value(objectValue);
+  CZString actualKey(
+      key, static_cast<unsigned>(cend-key), CZString::duplicateOnCopy);
+  ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
+  if (it != value_.map_->end() && (*it).first == actualKey)
+    return (*it).second;
+
+  ObjectValues::value_type defaultValue(actualKey, nullSingleton());
+  it = value_.map_->insert(it, defaultValue);
+  Value& value = (*it).second;
+  return value;
+}
+
+Value Value::get(ArrayIndex index, const Value& defaultValue) const {
+  const Value* value = &((*this)[index]);
+  return value == &nullSingleton() ? defaultValue : *value;
+}
+
+bool Value::isValidIndex(ArrayIndex index) const { return index < size(); }
+
+Value const* Value::find(char const* key, char const* cend) const
+{
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == objectValue,
+      "in Json::Value::find(key, end, found): requires objectValue or nullValue");
+  if (type_ == nullValue) return NULL;
+  CZString actualKey(key, static_cast<unsigned>(cend-key), CZString::noDuplication);
+  ObjectValues::const_iterator it = value_.map_->find(actualKey);
+  if (it == value_.map_->end()) return NULL;
+  return &(*it).second;
+}
+const Value& Value::operator[](const char* key) const
+{
+  Value const* found = find(key, key + strlen(key));
+  if (!found) return nullSingleton();
+  return *found;
+}
+Value const& Value::operator[](JSONCPP_STRING const& key) const
+{
+  Value const* found = find(key.data(), key.data() + key.length());
+  if (!found) return nullSingleton();
+  return *found;
+}
+
+Value& Value::operator[](const char* key) {
+  return resolveReference(key, key + strlen(key));
+}
+
+Value& Value::operator[](const JSONCPP_STRING& key) {
+  return resolveReference(key.data(), key.data() + key.length());
+}
+
+Value& Value::operator[](const StaticString& key) {
+  return resolveReference(key.c_str());
+}
+
+#ifdef JSON_USE_CPPTL
+Value& Value::operator[](const CppTL::ConstString& key) {
+  return resolveReference(key.c_str(), key.end_c_str());
+}
+Value const& Value::operator[](CppTL::ConstString const& key) const
+{
+  Value const* found = find(key.c_str(), key.end_c_str());
+  if (!found) return nullSingleton();
+  return *found;
+}
+#endif
+
+Value& Value::append(const Value& value) { return (*this)[size()] = value; }
+
+Value Value::get(char const* key, char const* cend, Value const& defaultValue) const
+{
+  Value const* found = find(key, cend);
+  return !found ? defaultValue : *found;
+}
+Value Value::get(char const* key, Value const& defaultValue) const
+{
+  return get(key, key + strlen(key), defaultValue);
+}
+Value Value::get(JSONCPP_STRING const& key, Value const& defaultValue) const
+{
+  return get(key.data(), key.data() + key.length(), defaultValue);
+}
+
+
+bool Value::removeMember(const char* key, const char* cend, Value* removed)
+{
+  if (type_ != objectValue) {
+    return false;
+  }
+  CZString actualKey(key, static_cast<unsigned>(cend-key), CZString::noDuplication);
+  ObjectValues::iterator it = value_.map_->find(actualKey);
+  if (it == value_.map_->end())
+    return false;
+  *removed = it->second;
+  value_.map_->erase(it);
+  return true;
+}
+bool Value::removeMember(const char* key, Value* removed)
+{
+  return removeMember(key, key + strlen(key), removed);
+}
+bool Value::removeMember(JSONCPP_STRING const& key, Value* removed)
+{
+  return removeMember(key.data(), key.data() + key.length(), removed);
+}
+Value Value::removeMember(const char* key)
+{
+  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == objectValue,
+                      "in Json::Value::removeMember(): requires objectValue");
+  if (type_ == nullValue)
+    return nullSingleton();
+
+  Value removed;  // null
+  removeMember(key, key + strlen(key), &removed);
+  return removed; // still null if removeMember() did nothing
+}
+Value Value::removeMember(const JSONCPP_STRING& key)
+{
+  return removeMember(key.c_str());
+}
+
+bool Value::removeIndex(ArrayIndex index, Value* removed) {
+  if (type_ != arrayValue) {
+    return false;
+  }
+  CZString key(index);
+  ObjectValues::iterator it = value_.map_->find(key);
+  if (it == value_.map_->end()) {
+    return false;
+  }
+  *removed = it->second;
+  ArrayIndex oldSize = size();
+  // shift left all items left, into the place of the "removed"
+  for (ArrayIndex i = index; i < (oldSize - 1); ++i){
+    CZString keey(i);
+    (*value_.map_)[keey] = (*this)[i + 1];
+  }
+  // erase the last one ("leftover")
+  CZString keyLast(oldSize - 1);
+  ObjectValues::iterator itLast = value_.map_->find(keyLast);
+  value_.map_->erase(itLast);
+  return true;
+}
+
+#ifdef JSON_USE_CPPTL
+Value Value::get(const CppTL::ConstString& key,
+                 const Value& defaultValue) const {
+  return get(key.c_str(), key.end_c_str(), defaultValue);
+}
+#endif
+
+bool Value::isMember(char const* key, char const* cend) const
+{
+  Value const* value = find(key, cend);
+  return NULL != value;
+}
+bool Value::isMember(char const* key) const
+{
+  return isMember(key, key + strlen(key));
+}
+bool Value::isMember(JSONCPP_STRING const& key) const
+{
+  return isMember(key.data(), key.data() + key.length());
+}
+
+#ifdef JSON_USE_CPPTL
+bool Value::isMember(const CppTL::ConstString& key) const {
+  return isMember(key.c_str(), key.end_c_str());
+}
+#endif
+
+Value::Members Value::getMemberNames() const {
+  JSON_ASSERT_MESSAGE(
+      type_ == nullValue || type_ == objectValue,
+      "in Json::Value::getMemberNames(), value must be objectValue");
+  if (type_ == nullValue)
+    return Value::Members();
+  Members members;
+  members.reserve(value_.map_->size());
+  ObjectValues::const_iterator it = value_.map_->begin();
+  ObjectValues::const_iterator itEnd = value_.map_->end();
+  for (; it != itEnd; ++it) {
+    members.push_back(JSONCPP_STRING((*it).first.data(),
+                                  (*it).first.length()));
+  }
+  return members;
+}
+//
+//# ifdef JSON_USE_CPPTL
+// EnumMemberNames
+// Value::enumMemberNames() const
+//{
+//   if ( type_ == objectValue )
+//   {
+//      return CppTL::Enum::any(  CppTL::Enum::transform(
+//         CppTL::Enum::keys( *(value_.map_), CppTL::Type<const CZString &>() ),
+//         MemberNamesTransform() ) );
+//   }
+//   return EnumMemberNames();
+//}
+//
+//
+// EnumValues
+// Value::enumValues() const
+//{
+//   if ( type_ == objectValue  ||  type_ == arrayValue )
+//      return CppTL::Enum::anyValues( *(value_.map_),
+//                                     CppTL::Type<const Value &>() );
+//   return EnumValues();
+//}
+//
+//# endif
+
+static bool IsIntegral(double d) {
+  double integral_part;
+  return modf(d, &integral_part) == 0.0;
+}
+
+bool Value::isNull() const { return type_ == nullValue; }
+
+bool Value::isBool() const { return type_ == booleanValue; }
+
+bool Value::isInt() const {
+  switch (type_) {
+  case intValue:
+    return value_.int_ >= minInt && value_.int_ <= maxInt;
+  case uintValue:
+    return value_.uint_ <= UInt(maxInt);
+  case realValue:
+    return value_.real_ >= minInt && value_.real_ <= maxInt &&
+           IsIntegral(value_.real_);
+  default:
+    break;
+  }
+  return false;
+}
+
+bool Value::isUInt() const {
+  switch (type_) {
+  case intValue:
+    return value_.int_ >= 0 && LargestUInt(value_.int_) <= LargestUInt(maxUInt);
+  case uintValue:
+    return value_.uint_ <= maxUInt;
+  case realValue:
+    return value_.real_ >= 0 && value_.real_ <= maxUInt &&
+           IsIntegral(value_.real_);
+  default:
+    break;
+  }
+  return false;
+}
+
+bool Value::isInt64() const {
+#if defined(JSON_HAS_INT64)
+  switch (type_) {
+  case intValue:
+    return true;
+  case uintValue:
+    return value_.uint_ <= UInt64(maxInt64);
+  case realValue:
+    // Note that maxInt64 (= 2^63 - 1) is not exactly representable as a
+    // double, so double(maxInt64) will be rounded up to 2^63. Therefore we
+    // require the value to be strictly less than the limit.
+    return value_.real_ >= double(minInt64) &&
+           value_.real_ < double(maxInt64) && IsIntegral(value_.real_);
+  default:
+    break;
+  }
+#endif // JSON_HAS_INT64
+  return false;
+}
+
+bool Value::isUInt64() const {
+#if defined(JSON_HAS_INT64)
+  switch (type_) {
+  case intValue:
+    return value_.int_ >= 0;
+  case uintValue:
+    return true;
+  case realValue:
+    // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
+    // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
+    // require the value to be strictly less than the limit.
+    return value_.real_ >= 0 && value_.real_ < maxUInt64AsDouble &&
+           IsIntegral(value_.real_);
+  default:
+    break;
+  }
+#endif // JSON_HAS_INT64
+  return false;
+}
+
+bool Value::isIntegral() const {
+#if defined(JSON_HAS_INT64)
+  return isInt64() || isUInt64();
+#else
+  return isInt() || isUInt();
+#endif
+}
+
+bool Value::isDouble() const { return type_ == realValue || isIntegral(); }
+
+bool Value::isNumeric() const { return isIntegral() || isDouble(); }
+
+bool Value::isString() const { return type_ == stringValue; }
+
+bool Value::isArray() const { return type_ == arrayValue; }
+
+bool Value::isObject() const { return type_ == objectValue; }
+
+void Value::setComment(const char* comment, size_t len, CommentPlacement placement) {
+  if (!comments_)
+    comments_ = new CommentInfo[numberOfCommentPlacement];
+  if ((len > 0) && (comment[len-1] == '\n')) {
+    // Always discard trailing newline, to aid indentation.
+    len -= 1;
+  }
+  comments_[placement].setComment(comment, len);
+}
+
+void Value::setComment(const char* comment, CommentPlacement placement) {
+  setComment(comment, strlen(comment), placement);
+}
+
+void Value::setComment(const JSONCPP_STRING& comment, CommentPlacement placement) {
+  setComment(comment.c_str(), comment.length(), placement);
+}
+
+bool Value::hasComment(CommentPlacement placement) const {
+  return comments_ != 0 && comments_[placement].comment_ != 0;
+}
+
+JSONCPP_STRING Value::getComment(CommentPlacement placement) const {
+  if (hasComment(placement))
+    return comments_[placement].comment_;
+  return "";
+}
+
+void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }
+
+void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }
+
+ptrdiff_t Value::getOffsetStart() const { return start_; }
+
+ptrdiff_t Value::getOffsetLimit() const { return limit_; }
+
+JSONCPP_STRING Value::toStyledString() const {
+  StyledWriter writer;
+  return writer.write(*this);
+}
+
+Value::const_iterator Value::begin() const {
+  switch (type_) {
+  case arrayValue:
+  case objectValue:
+    if (value_.map_)
+      return const_iterator(value_.map_->begin());
+    break;
+  default:
+    break;
+  }
+  return const_iterator();
+}
+
+Value::const_iterator Value::end() const {
+  switch (type_) {
+  case arrayValue:
+  case objectValue:
+    if (value_.map_)
+      return const_iterator(value_.map_->end());
+    break;
+  default:
+    break;
+  }
+  return const_iterator();
+}
+
+Value::iterator Value::begin() {
+  switch (type_) {
+  case arrayValue:
+  case objectValue:
+    if (value_.map_)
+      return iterator(value_.map_->begin());
+    break;
+  default:
+    break;
+  }
+  return iterator();
+}
+
+Value::iterator Value::end() {
+  switch (type_) {
+  case arrayValue:
+  case objectValue:
+    if (value_.map_)
+      return iterator(value_.map_->end());
+    break;
+  default:
+    break;
+  }
+  return iterator();
+}
+
+// class PathArgument
+// //////////////////////////////////////////////////////////////////
+
+PathArgument::PathArgument() : key_(), index_(), kind_(kindNone) {}
+
+PathArgument::PathArgument(ArrayIndex index)
+    : key_(), index_(index), kind_(kindIndex) {}
+
+PathArgument::PathArgument(const char* key)
+    : key_(key), index_(), kind_(kindKey) {}
+
+PathArgument::PathArgument(const JSONCPP_STRING& key)
+    : key_(key.c_str()), index_(), kind_(kindKey) {}
+
+// class Path
+// //////////////////////////////////////////////////////////////////
+
+Path::Path(const JSONCPP_STRING& path,
+           const PathArgument& a1,
+           const PathArgument& a2,
+           const PathArgument& a3,
+           const PathArgument& a4,
+           const PathArgument& a5) {
+  InArgs in;
+  in.push_back(&a1);
+  in.push_back(&a2);
+  in.push_back(&a3);
+  in.push_back(&a4);
+  in.push_back(&a5);
+  makePath(path, in);
+}
+
+void Path::makePath(const JSONCPP_STRING& path, const InArgs& in) {
+  const char* current = path.c_str();
+  const char* end = current + path.length();
+  InArgs::const_iterator itInArg = in.begin();
+  while (current != end) {
+    if (*current == '[') {
+      ++current;
+      if (*current == '%')
+        addPathInArg(path, in, itInArg, PathArgument::kindIndex);
+      else {
+        ArrayIndex index = 0;
+        for (; current != end && *current >= '0' && *current <= '9'; ++current)
+          index = index * 10 + ArrayIndex(*current - '0');
+        args_.push_back(index);
+      }
+      if (current == end || *++current != ']')
+        invalidPath(path, int(current - path.c_str()));
+    } else if (*current == '%') {
+      addPathInArg(path, in, itInArg, PathArgument::kindKey);
+      ++current;
+    } else if (*current == '.' || *current == ']') {
+      ++current;
+    } else {
+      const char* beginName = current;
+      while (current != end && !strchr("[.", *current))
+        ++current;
+      args_.push_back(JSONCPP_STRING(beginName, current));
+    }
+  }
+}
+
+void Path::addPathInArg(const JSONCPP_STRING& /*path*/,
+                        const InArgs& in,
+                        InArgs::const_iterator& itInArg,
+                        PathArgument::Kind kind) {
+  if (itInArg == in.end()) {
+    // Error: missing argument %d
+  } else if ((*itInArg)->kind_ != kind) {
+    // Error: bad argument type
+  } else {
+    args_.push_back(**itInArg++);
+  }
+}
+
+void Path::invalidPath(const JSONCPP_STRING& /*path*/, int /*location*/) {
+  // Error: invalid path.
+}
+
+const Value& Path::resolve(const Value& root) const {
+  const Value* node = &root;
+  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
+    const PathArgument& arg = *it;
+    if (arg.kind_ == PathArgument::kindIndex) {
+      if (!node->isArray() || !node->isValidIndex(arg.index_)) {
+        // Error: unable to resolve path (array value expected at position...
+        return Value::null;
+      }
+      node = &((*node)[arg.index_]);
+    } else if (arg.kind_ == PathArgument::kindKey) {
+      if (!node->isObject()) {
+        // Error: unable to resolve path (object value expected at position...)
+        return Value::null;
+      }
+      node = &((*node)[arg.key_]);
+      if (node == &Value::nullSingleton()) {
+        // Error: unable to resolve path (object has no member named '' at
+        // position...)
+        return Value::null;
+      }
+    }
+  }
+  return *node;
+}
+
+Value Path::resolve(const Value& root, const Value& defaultValue) const {
+  const Value* node = &root;
+  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
+    const PathArgument& arg = *it;
+    if (arg.kind_ == PathArgument::kindIndex) {
+      if (!node->isArray() || !node->isValidIndex(arg.index_))
+        return defaultValue;
+      node = &((*node)[arg.index_]);
+    } else if (arg.kind_ == PathArgument::kindKey) {
+      if (!node->isObject())
+        return defaultValue;
+      node = &((*node)[arg.key_]);
+      if (node == &Value::nullSingleton())
+        return defaultValue;
+    }
+  }
+  return *node;
+}
+
+Value& Path::make(Value& root) const {
+  Value* node = &root;
+  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
+    const PathArgument& arg = *it;
+    if (arg.kind_ == PathArgument::kindIndex) {
+      if (!node->isArray()) {
+        // Error: node is not an array at position ...
+      }
+      node = &((*node)[arg.index_]);
+    } else if (arg.kind_ == PathArgument::kindKey) {
+      if (!node->isObject()) {
+        // Error: node is not an object at position...
+      }
+      node = &((*node)[arg.key_]);
+    }
+  }
+  return *node;
+}
+
+} // namespace Json
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_valueiterator.inl polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_valueiterator.inl
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_valueiterator.inl	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_valueiterator.inl	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,167 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+// included by json_value.cpp
+
+namespace Json {
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class ValueIteratorBase
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+ValueIteratorBase::ValueIteratorBase()
+    : current_(), isNull_(true) {
+}
+
+ValueIteratorBase::ValueIteratorBase(
+    const Value::ObjectValues::iterator& current)
+    : current_(current), isNull_(false) {}
+
+Value& ValueIteratorBase::deref() const {
+  return current_->second;
+}
+
+void ValueIteratorBase::increment() {
+  ++current_;
+}
+
+void ValueIteratorBase::decrement() {
+  --current_;
+}
+
+ValueIteratorBase::difference_type
+ValueIteratorBase::computeDistance(const SelfType& other) const {
+#ifdef JSON_USE_CPPTL_SMALLMAP
+  return other.current_ - current_;
+#else
+  // Iterator for null value are initialized using the default
+  // constructor, which initialize current_ to the default
+  // std::map::iterator. As begin() and end() are two instance
+  // of the default std::map::iterator, they can not be compared.
+  // To allow this, we handle this comparison specifically.
+  if (isNull_ && other.isNull_) {
+    return 0;
+  }
+
+  // Usage of std::distance is not portable (does not compile with Sun Studio 12
+  // RogueWave STL,
+  // which is the one used by default).
+  // Using a portable hand-made version for non random iterator instead:
+  //   return difference_type( std::distance( current_, other.current_ ) );
+  difference_type myDistance = 0;
+  for (Value::ObjectValues::iterator it = current_; it != other.current_;
+       ++it) {
+    ++myDistance;
+  }
+  return myDistance;
+#endif
+}
+
+bool ValueIteratorBase::isEqual(const SelfType& other) const {
+  if (isNull_) {
+    return other.isNull_;
+  }
+  return current_ == other.current_;
+}
+
+void ValueIteratorBase::copy(const SelfType& other) {
+  current_ = other.current_;
+  isNull_ = other.isNull_;
+}
+
+Value ValueIteratorBase::key() const {
+  const Value::CZString czstring = (*current_).first;
+  if (czstring.data()) {
+    if (czstring.isStaticString())
+      return Value(StaticString(czstring.data()));
+    return Value(czstring.data(), czstring.data() + czstring.length());
+  }
+  return Value(czstring.index());
+}
+
+UInt ValueIteratorBase::index() const {
+  const Value::CZString czstring = (*current_).first;
+  if (!czstring.data())
+    return czstring.index();
+  return Value::UInt(-1);
+}
+
+JSONCPP_STRING ValueIteratorBase::name() const {
+  char const* keey;
+  char const* end;
+  keey = memberName(&end);
+  if (!keey) return JSONCPP_STRING();
+  return JSONCPP_STRING(keey, end);
+}
+
+char const* ValueIteratorBase::memberName() const {
+  const char* cname = (*current_).first.data();
+  return cname ? cname : "";
+}
+
+char const* ValueIteratorBase::memberName(char const** end) const {
+  const char* cname = (*current_).first.data();
+  if (!cname) {
+    *end = NULL;
+    return NULL;
+  }
+  *end = cname + (*current_).first.length();
+  return cname;
+}
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class ValueConstIterator
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+ValueConstIterator::ValueConstIterator() {}
+
+ValueConstIterator::ValueConstIterator(
+    const Value::ObjectValues::iterator& current)
+    : ValueIteratorBase(current) {}
+
+ValueConstIterator::ValueConstIterator(ValueIterator const& other)
+    : ValueIteratorBase(other) {}
+
+ValueConstIterator& ValueConstIterator::
+operator=(const ValueIteratorBase& other) {
+  copy(other);
+  return *this;
+}
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// class ValueIterator
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+ValueIterator::ValueIterator() {}
+
+ValueIterator::ValueIterator(const Value::ObjectValues::iterator& current)
+    : ValueIteratorBase(current) {}
+
+ValueIterator::ValueIterator(const ValueConstIterator& other)
+    : ValueIteratorBase(other) {
+  throwRuntimeError("ConstIterator to Iterator should never be allowed.");
+}
+
+ValueIterator::ValueIterator(const ValueIterator& other)
+    : ValueIteratorBase(other) {}
+
+ValueIterator& ValueIterator::operator=(const SelfType& other) {
+  copy(other);
+  return *this;
+}
+
+} // namespace Json
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_writer.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_writer.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_writer.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/json_writer.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,1218 @@
+// Copyright 2011 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#if !defined(JSON_IS_AMALGAMATION)
+#include <json/writer.h>
+#include "json_tool.h"
+#endif // if !defined(JSON_IS_AMALGAMATION)
+#include <iomanip>
+#include <memory>
+#include <sstream>
+#include <utility>
+#include <set>
+#include <cassert>
+#include <cstring>
+#include <cstdio>
+
+#if defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1800 // Between VC++ 6.0 and VC++ 11.0
+#include <float.h>
+#define isfinite _finite
+#elif defined(__sun) && defined(__SVR4) //Solaris
+#if !defined(isfinite)
+#include <ieeefp.h>
+#define isfinite finite
+#endif
+#elif defined(_AIX)
+#if !defined(isfinite)
+#include <math.h>
+#define isfinite finite
+#endif
+#elif defined(__hpux)
+#if !defined(isfinite)
+#if defined(__ia64) && !defined(finite)
+#define isfinite(x) ((sizeof(x) == sizeof(float) ? \
+                     _Isfinitef(x) : _IsFinite(x)))
+#else
+#include <math.h>
+#define isfinite finite
+#endif
+#endif
+#else
+#include <cmath>
+#if !(defined(__QNXNTO__)) // QNX already defines isfinite
+#define isfinite std::isfinite
+#endif
+#endif
+
+#if defined(_MSC_VER)
+#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above
+#define snprintf sprintf_s
+#elif _MSC_VER >= 1900 // VC++ 14.0 and above
+#define snprintf std::snprintf
+#else
+#define snprintf _snprintf
+#endif
+#elif defined(__ANDROID__) || defined(__QNXNTO__)
+#define snprintf snprintf
+#elif __cplusplus >= 201103L
+#if !defined(__MINGW32__) && !defined(__CYGWIN__)
+#define snprintf std::snprintf
+#endif
+#endif
+
+#if defined(__BORLANDC__)  
+#include <float.h>
+#define isfinite _finite
+#define snprintf _snprintf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
+// Disable warning about strdup being deprecated.
+#pragma warning(disable : 4996)
+#endif
+
+namespace Json {
+
+#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
+typedef std::unique_ptr<StreamWriter> StreamWriterPtr;
+#else
+typedef std::auto_ptr<StreamWriter>   StreamWriterPtr;
+#endif
+
+static bool containsControlCharacter(const char* str) {
+  while (*str) {
+    if (isControlCharacter(*(str++)))
+      return true;
+  }
+  return false;
+}
+
+static bool containsControlCharacter0(const char* str, unsigned len) {
+  char const* end = str + len;
+  while (end != str) {
+    if (isControlCharacter(*str) || 0==*str)
+      return true;
+    ++str;
+  }
+  return false;
+}
+
+JSONCPP_STRING valueToString(LargestInt value) {
+  UIntToStringBuffer buffer;
+  char* current = buffer + sizeof(buffer);
+  if (value == Value::minLargestInt) {
+    uintToString(LargestUInt(Value::maxLargestInt) + 1, current);
+    *--current = '-';
+  } else if (value < 0) {
+    uintToString(LargestUInt(-value), current);
+    *--current = '-';
+  } else {
+    uintToString(LargestUInt(value), current);
+  }
+  assert(current >= buffer);
+  return current;
+}
+
+JSONCPP_STRING valueToString(LargestUInt value) {
+  UIntToStringBuffer buffer;
+  char* current = buffer + sizeof(buffer);
+  uintToString(value, current);
+  assert(current >= buffer);
+  return current;
+}
+
+#if defined(JSON_HAS_INT64)
+
+JSONCPP_STRING valueToString(Int value) {
+  return valueToString(LargestInt(value));
+}
+
+JSONCPP_STRING valueToString(UInt value) {
+  return valueToString(LargestUInt(value));
+}
+
+#endif // # if defined(JSON_HAS_INT64)
+
+namespace {
+JSONCPP_STRING valueToString(double value, bool useSpecialFloats, unsigned int precision) {
+  // Allocate a buffer that is more than large enough to store the 16 digits of
+  // precision requested below.
+  char buffer[32];
+  int len = -1;
+
+  char formatString[6];
+  sprintf(formatString, "%%.%dg", precision);
+
+  // Print into the buffer. We need not request the alternative representation
+  // that always has a decimal point because JSON doesn't distingish the
+  // concepts of reals and integers.
+  if (isfinite(value)) {
+    len = snprintf(buffer, sizeof(buffer), formatString, value);
+  } else {
+    // IEEE standard states that NaN values will not compare to themselves
+    if (value != value) {
+      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "NaN" : "null");
+    } else if (value < 0) {
+      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "-Infinity" : "-1e+9999");
+    } else {
+      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "Infinity" : "1e+9999");
+    }
+    // For those, we do not need to call fixNumLoc, but it is fast.
+  }
+  assert(len >= 0);
+  fixNumericLocale(buffer, buffer + len);
+  return buffer;
+}
+}
+
+JSONCPP_STRING valueToString(double value) { return valueToString(value, false, 17); }
+
+JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }
+
+JSONCPP_STRING valueToQuotedString(const char* value) {
+  if (value == NULL)
+    return "";
+  // Not sure how to handle unicode...
+  if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL &&
+      !containsControlCharacter(value))
+    return JSONCPP_STRING("\"") + value + "\"";
+  // We have to walk value and escape any special characters.
+  // Appending to JSONCPP_STRING is not efficient, but this should be rare.
+  // (Note: forward slashes are *not* rare, but I am not escaping them.)
+  JSONCPP_STRING::size_type maxsize =
+      strlen(value) * 2 + 3; // allescaped+quotes+NULL
+  JSONCPP_STRING result;
+  result.reserve(maxsize); // to avoid lots of mallocs
+  result += "\"";
+  for (const char* c = value; *c != 0; ++c) {
+    switch (*c) {
+    case '\"':
+      result += "\\\"";
+      break;
+    case '\\':
+      result += "\\\\";
+      break;
+    case '\b':
+      result += "\\b";
+      break;
+    case '\f':
+      result += "\\f";
+      break;
+    case '\n':
+      result += "\\n";
+      break;
+    case '\r':
+      result += "\\r";
+      break;
+    case '\t':
+      result += "\\t";
+      break;
+    // case '/':
+    // Even though \/ is considered a legal escape in JSON, a bare
+    // slash is also legal, so I see no reason to escape it.
+    // (I hope I am not misunderstanding something.
+    // blep notes: actually escaping \/ may be useful in javascript to avoid </
+    // sequence.
+    // Should add a flag to allow this compatibility mode and prevent this
+    // sequence from occurring.
+    default:
+      if (isControlCharacter(*c)) {
+        JSONCPP_OSTRINGSTREAM oss;
+        oss << "\\u" << std::hex << std::uppercase << std::setfill('0')
+            << std::setw(4) << static_cast<int>(*c);
+        result += oss.str();
+      } else {
+        result += *c;
+      }
+      break;
+    }
+  }
+  result += "\"";
+  return result;
+}
+
+// https://github.com/upcaste/upcaste/blob/master/src/upcore/src/cstring/strnpbrk.cpp
+static char const* strnpbrk(char const* s, char const* accept, size_t n) {
+  assert((s || !n) && accept);
+
+  char const* const end = s + n;
+  for (char const* cur = s; cur < end; ++cur) {
+    int const c = *cur;
+    for (char const* a = accept; *a; ++a) {
+      if (*a == c) {
+        return cur;
+      }
+    }
+  }
+  return NULL;
+}
+static JSONCPP_STRING valueToQuotedStringN(const char* value, unsigned length) {
+  if (value == NULL)
+    return "";
+  // Not sure how to handle unicode...
+  if (strnpbrk(value, "\"\\\b\f\n\r\t", length) == NULL &&
+      !containsControlCharacter0(value, length))
+    return JSONCPP_STRING("\"") + value + "\"";
+  // We have to walk value and escape any special characters.
+  // Appending to JSONCPP_STRING is not efficient, but this should be rare.
+  // (Note: forward slashes are *not* rare, but I am not escaping them.)
+  JSONCPP_STRING::size_type maxsize =
+      length * 2 + 3; // allescaped+quotes+NULL
+  JSONCPP_STRING result;
+  result.reserve(maxsize); // to avoid lots of mallocs
+  result += "\"";
+  char const* end = value + length;
+  for (const char* c = value; c != end; ++c) {
+    switch (*c) {
+    case '\"':
+      result += "\\\"";
+      break;
+    case '\\':
+      result += "\\\\";
+      break;
+    case '\b':
+      result += "\\b";
+      break;
+    case '\f':
+      result += "\\f";
+      break;
+    case '\n':
+      result += "\\n";
+      break;
+    case '\r':
+      result += "\\r";
+      break;
+    case '\t':
+      result += "\\t";
+      break;
+    // case '/':
+    // Even though \/ is considered a legal escape in JSON, a bare
+    // slash is also legal, so I see no reason to escape it.
+    // (I hope I am not misunderstanding something.)
+    // blep notes: actually escaping \/ may be useful in javascript to avoid </
+    // sequence.
+    // Should add a flag to allow this compatibility mode and prevent this
+    // sequence from occurring.
+    default:
+      if ((isControlCharacter(*c)) || (*c == 0)) {
+        JSONCPP_OSTRINGSTREAM oss;
+        oss << "\\u" << std::hex << std::uppercase << std::setfill('0')
+            << std::setw(4) << static_cast<int>(*c);
+        result += oss.str();
+      } else {
+        result += *c;
+      }
+      break;
+    }
+  }
+  result += "\"";
+  return result;
+}
+
+// Class Writer
+// //////////////////////////////////////////////////////////////////
+Writer::~Writer() {}
+
+// Class FastWriter
+// //////////////////////////////////////////////////////////////////
+
+FastWriter::FastWriter()
+    : yamlCompatiblityEnabled_(false), dropNullPlaceholders_(false),
+      omitEndingLineFeed_(false) {}
+
+void FastWriter::enableYAMLCompatibility() { yamlCompatiblityEnabled_ = true; }
+
+void FastWriter::dropNullPlaceholders() { dropNullPlaceholders_ = true; }
+
+void FastWriter::omitEndingLineFeed() { omitEndingLineFeed_ = true; }
+
+JSONCPP_STRING FastWriter::write(const Value& root) {
+  document_ = "";
+  writeValue(root);
+  if (!omitEndingLineFeed_)
+    document_ += "\n";
+  return document_;
+}
+
+void FastWriter::writeValue(const Value& value) {
+  switch (value.type()) {
+  case nullValue:
+    if (!dropNullPlaceholders_)
+      document_ += "null";
+    break;
+  case intValue:
+    document_ += valueToString(value.asLargestInt());
+    break;
+  case uintValue:
+    document_ += valueToString(value.asLargestUInt());
+    break;
+  case realValue:
+    document_ += valueToString(value.asDouble());
+    break;
+  case stringValue:
+  {
+    // Is NULL possible for value.string_? No.
+    char const* str;
+    char const* end;
+    bool ok = value.getString(&str, &end);
+    if (ok) document_ += valueToQuotedStringN(str, static_cast<unsigned>(end-str));
+    break;
+  }
+  case booleanValue:
+    document_ += valueToString(value.asBool());
+    break;
+  case arrayValue: {
+    document_ += '[';
+    ArrayIndex size = value.size();
+    for (ArrayIndex index = 0; index < size; ++index) {
+      if (index > 0)
+        document_ += ',';
+      writeValue(value[index]);
+    }
+    document_ += ']';
+  } break;
+  case objectValue: {
+    Value::Members members(value.getMemberNames());
+    document_ += '{';
+    for (Value::Members::iterator it = members.begin(); it != members.end();
+         ++it) {
+      const JSONCPP_STRING& name = *it;
+      if (it != members.begin())
+        document_ += ',';
+      document_ += valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length()));
+      document_ += yamlCompatiblityEnabled_ ? ": " : ":";
+      writeValue(value[name]);
+    }
+    document_ += '}';
+  } break;
+  }
+}
+
+// Class StyledWriter
+// //////////////////////////////////////////////////////////////////
+
+StyledWriter::StyledWriter()
+    : rightMargin_(74), indentSize_(3), addChildValues_() {}
+
+JSONCPP_STRING StyledWriter::write(const Value& root) {
+  document_ = "";
+  addChildValues_ = false;
+  indentString_ = "";
+  writeCommentBeforeValue(root);
+  writeValue(root);
+  writeCommentAfterValueOnSameLine(root);
+  document_ += "\n";
+  return document_;
+}
+
+void StyledWriter::writeValue(const Value& value) {
+  switch (value.type()) {
+  case nullValue:
+    pushValue("null");
+    break;
+  case intValue:
+    pushValue(valueToString(value.asLargestInt()));
+    break;
+  case uintValue:
+    pushValue(valueToString(value.asLargestUInt()));
+    break;
+  case realValue:
+    pushValue(valueToString(value.asDouble()));
+    break;
+  case stringValue:
+  {
+    // Is NULL possible for value.string_? No.
+    char const* str;
+    char const* end;
+    bool ok = value.getString(&str, &end);
+    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
+    else pushValue("");
+    break;
+  }
+  case booleanValue:
+    pushValue(valueToString(value.asBool()));
+    break;
+  case arrayValue:
+    writeArrayValue(value);
+    break;
+  case objectValue: {
+    Value::Members members(value.getMemberNames());
+    if (members.empty())
+      pushValue("{}");
+    else {
+      writeWithIndent("{");
+      indent();
+      Value::Members::iterator it = members.begin();
+      for (;;) {
+        const JSONCPP_STRING& name = *it;
+        const Value& childValue = value[name];
+        writeCommentBeforeValue(childValue);
+        writeWithIndent(valueToQuotedString(name.c_str()));
+        document_ += " : ";
+        writeValue(childValue);
+        if (++it == members.end()) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        document_ += ',';
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("}");
+    }
+  } break;
+  }
+}
+
+void StyledWriter::writeArrayValue(const Value& value) {
+  unsigned size = value.size();
+  if (size == 0)
+    pushValue("[]");
+  else {
+    bool isArrayMultiLine = isMultineArray(value);
+    if (isArrayMultiLine) {
+      writeWithIndent("[");
+      indent();
+      bool hasChildValue = !childValues_.empty();
+      unsigned index = 0;
+      for (;;) {
+        const Value& childValue = value[index];
+        writeCommentBeforeValue(childValue);
+        if (hasChildValue)
+          writeWithIndent(childValues_[index]);
+        else {
+          writeIndent();
+          writeValue(childValue);
+        }
+        if (++index == size) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        document_ += ',';
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("]");
+    } else // output on a single line
+    {
+      assert(childValues_.size() == size);
+      document_ += "[ ";
+      for (unsigned index = 0; index < size; ++index) {
+        if (index > 0)
+          document_ += ", ";
+        document_ += childValues_[index];
+      }
+      document_ += " ]";
+    }
+  }
+}
+
+bool StyledWriter::isMultineArray(const Value& value) {
+  ArrayIndex const size = value.size();
+  bool isMultiLine = size * 3 >= rightMargin_;
+  childValues_.clear();
+  for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
+    const Value& childValue = value[index];
+    isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
+                        childValue.size() > 0);
+  }
+  if (!isMultiLine) // check if line length > max line length
+  {
+    childValues_.reserve(size);
+    addChildValues_ = true;
+    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
+    for (ArrayIndex index = 0; index < size; ++index) {
+      if (hasCommentForValue(value[index])) {
+        isMultiLine = true;
+      }
+      writeValue(value[index]);
+      lineLength += static_cast<ArrayIndex>(childValues_[index].length());
+    }
+    addChildValues_ = false;
+    isMultiLine = isMultiLine || lineLength >= rightMargin_;
+  }
+  return isMultiLine;
+}
+
+void StyledWriter::pushValue(const JSONCPP_STRING& value) {
+  if (addChildValues_)
+    childValues_.push_back(value);
+  else
+    document_ += value;
+}
+
+void StyledWriter::writeIndent() {
+  if (!document_.empty()) {
+    char last = document_[document_.length() - 1];
+    if (last == ' ') // already indented
+      return;
+    if (last != '\n') // Comments may add new-line
+      document_ += '\n';
+  }
+  document_ += indentString_;
+}
+
+void StyledWriter::writeWithIndent(const JSONCPP_STRING& value) {
+  writeIndent();
+  document_ += value;
+}
+
+void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }
+
+void StyledWriter::unindent() {
+  assert(indentString_.size() >= indentSize_);
+  indentString_.resize(indentString_.size() - indentSize_);
+}
+
+void StyledWriter::writeCommentBeforeValue(const Value& root) {
+  if (!root.hasComment(commentBefore))
+    return;
+
+  document_ += "\n";
+  writeIndent();
+  const JSONCPP_STRING& comment = root.getComment(commentBefore);
+  JSONCPP_STRING::const_iterator iter = comment.begin();
+  while (iter != comment.end()) {
+    document_ += *iter;
+    if (*iter == '\n' &&
+       (iter != comment.end() && *(iter + 1) == '/'))
+      writeIndent();
+    ++iter;
+  }
+
+  // Comments are stripped of trailing newlines, so add one here
+  document_ += "\n";
+}
+
+void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {
+  if (root.hasComment(commentAfterOnSameLine))
+    document_ += " " + root.getComment(commentAfterOnSameLine);
+
+  if (root.hasComment(commentAfter)) {
+    document_ += "\n";
+    document_ += root.getComment(commentAfter);
+    document_ += "\n";
+  }
+}
+
+bool StyledWriter::hasCommentForValue(const Value& value) {
+  return value.hasComment(commentBefore) ||
+         value.hasComment(commentAfterOnSameLine) ||
+         value.hasComment(commentAfter);
+}
+
+// Class StyledStreamWriter
+// //////////////////////////////////////////////////////////////////
+
+StyledStreamWriter::StyledStreamWriter(JSONCPP_STRING indentation)
+    : document_(NULL), rightMargin_(74), indentation_(indentation),
+      addChildValues_() {}
+
+void StyledStreamWriter::write(JSONCPP_OSTREAM& out, const Value& root) {
+  document_ = &out;
+  addChildValues_ = false;
+  indentString_ = "";
+  indented_ = true;
+  writeCommentBeforeValue(root);
+  if (!indented_) writeIndent();
+  indented_ = true;
+  writeValue(root);
+  writeCommentAfterValueOnSameLine(root);
+  *document_ << "\n";
+  document_ = NULL; // Forget the stream, for safety.
+}
+
+void StyledStreamWriter::writeValue(const Value& value) {
+  switch (value.type()) {
+  case nullValue:
+    pushValue("null");
+    break;
+  case intValue:
+    pushValue(valueToString(value.asLargestInt()));
+    break;
+  case uintValue:
+    pushValue(valueToString(value.asLargestUInt()));
+    break;
+  case realValue:
+    pushValue(valueToString(value.asDouble()));
+    break;
+  case stringValue:
+  {
+    // Is NULL possible for value.string_? No.
+    char const* str;
+    char const* end;
+    bool ok = value.getString(&str, &end);
+    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
+    else pushValue("");
+    break;
+  }
+  case booleanValue:
+    pushValue(valueToString(value.asBool()));
+    break;
+  case arrayValue:
+    writeArrayValue(value);
+    break;
+  case objectValue: {
+    Value::Members members(value.getMemberNames());
+    if (members.empty())
+      pushValue("{}");
+    else {
+      writeWithIndent("{");
+      indent();
+      Value::Members::iterator it = members.begin();
+      for (;;) {
+        const JSONCPP_STRING& name = *it;
+        const Value& childValue = value[name];
+        writeCommentBeforeValue(childValue);
+        writeWithIndent(valueToQuotedString(name.c_str()));
+        *document_ << " : ";
+        writeValue(childValue);
+        if (++it == members.end()) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        *document_ << ",";
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("}");
+    }
+  } break;
+  }
+}
+
+void StyledStreamWriter::writeArrayValue(const Value& value) {
+  unsigned size = value.size();
+  if (size == 0)
+    pushValue("[]");
+  else {
+    bool isArrayMultiLine = isMultineArray(value);
+    if (isArrayMultiLine) {
+      writeWithIndent("[");
+      indent();
+      bool hasChildValue = !childValues_.empty();
+      unsigned index = 0;
+      for (;;) {
+        const Value& childValue = value[index];
+        writeCommentBeforeValue(childValue);
+        if (hasChildValue)
+          writeWithIndent(childValues_[index]);
+        else {
+          if (!indented_) writeIndent();
+          indented_ = true;
+          writeValue(childValue);
+          indented_ = false;
+        }
+        if (++index == size) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        *document_ << ",";
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("]");
+    } else // output on a single line
+    {
+      assert(childValues_.size() == size);
+      *document_ << "[ ";
+      for (unsigned index = 0; index < size; ++index) {
+        if (index > 0)
+          *document_ << ", ";
+        *document_ << childValues_[index];
+      }
+      *document_ << " ]";
+    }
+  }
+}
+
+bool StyledStreamWriter::isMultineArray(const Value& value) {
+  ArrayIndex const size = value.size();
+  bool isMultiLine = size * 3 >= rightMargin_;
+  childValues_.clear();
+  for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
+    const Value& childValue = value[index];
+    isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
+                        childValue.size() > 0);
+  }
+  if (!isMultiLine) // check if line length > max line length
+  {
+    childValues_.reserve(size);
+    addChildValues_ = true;
+    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
+    for (ArrayIndex index = 0; index < size; ++index) {
+      if (hasCommentForValue(value[index])) {
+        isMultiLine = true;
+      }
+      writeValue(value[index]);
+      lineLength += static_cast<ArrayIndex>(childValues_[index].length());
+    }
+    addChildValues_ = false;
+    isMultiLine = isMultiLine || lineLength >= rightMargin_;
+  }
+  return isMultiLine;
+}
+
+void StyledStreamWriter::pushValue(const JSONCPP_STRING& value) {
+  if (addChildValues_)
+    childValues_.push_back(value);
+  else
+    *document_ << value;
+}
+
+void StyledStreamWriter::writeIndent() {
+  // blep intended this to look at the so-far-written string
+  // to determine whether we are already indented, but
+  // with a stream we cannot do that. So we rely on some saved state.
+  // The caller checks indented_.
+  *document_ << '\n' << indentString_;
+}
+
+void StyledStreamWriter::writeWithIndent(const JSONCPP_STRING& value) {
+  if (!indented_) writeIndent();
+  *document_ << value;
+  indented_ = false;
+}
+
+void StyledStreamWriter::indent() { indentString_ += indentation_; }
+
+void StyledStreamWriter::unindent() {
+  assert(indentString_.size() >= indentation_.size());
+  indentString_.resize(indentString_.size() - indentation_.size());
+}
+
+void StyledStreamWriter::writeCommentBeforeValue(const Value& root) {
+  if (!root.hasComment(commentBefore))
+    return;
+
+  if (!indented_) writeIndent();
+  const JSONCPP_STRING& comment = root.getComment(commentBefore);
+  JSONCPP_STRING::const_iterator iter = comment.begin();
+  while (iter != comment.end()) {
+    *document_ << *iter;
+    if (*iter == '\n' &&
+       (iter != comment.end() && *(iter + 1) == '/'))
+      // writeIndent();  // would include newline
+      *document_ << indentString_;
+    ++iter;
+  }
+  indented_ = false;
+}
+
+void StyledStreamWriter::writeCommentAfterValueOnSameLine(const Value& root) {
+  if (root.hasComment(commentAfterOnSameLine))
+    *document_ << ' ' << root.getComment(commentAfterOnSameLine);
+
+  if (root.hasComment(commentAfter)) {
+    writeIndent();
+    *document_ << root.getComment(commentAfter);
+  }
+  indented_ = false;
+}
+
+bool StyledStreamWriter::hasCommentForValue(const Value& value) {
+  return value.hasComment(commentBefore) ||
+         value.hasComment(commentAfterOnSameLine) ||
+         value.hasComment(commentAfter);
+}
+
+//////////////////////////
+// BuiltStyledStreamWriter
+
+/// Scoped enums are not available until C++11.
+struct CommentStyle {
+  /// Decide whether to write comments.
+  enum Enum {
+    None,  ///< Drop all comments.
+    Most,  ///< Recover odd behavior of previous versions (not implemented yet).
+    All  ///< Keep all comments.
+  };
+};
+
+struct BuiltStyledStreamWriter : public StreamWriter
+{
+  BuiltStyledStreamWriter(
+      JSONCPP_STRING const& indentation,
+      CommentStyle::Enum cs,
+      JSONCPP_STRING const& colonSymbol,
+      JSONCPP_STRING const& nullSymbol,
+      JSONCPP_STRING const& endingLineFeedSymbol,
+      bool useSpecialFloats,
+      unsigned int precision);
+  int write(Value const& root, JSONCPP_OSTREAM* sout) JSONCPP_OVERRIDE;
+private:
+  void writeValue(Value const& value);
+  void writeArrayValue(Value const& value);
+  bool isMultineArray(Value const& value);
+  void pushValue(JSONCPP_STRING const& value);
+  void writeIndent();
+  void writeWithIndent(JSONCPP_STRING const& value);
+  void indent();
+  void unindent();
+  void writeCommentBeforeValue(Value const& root);
+  void writeCommentAfterValueOnSameLine(Value const& root);
+  static bool hasCommentForValue(const Value& value);
+
+  typedef std::vector<JSONCPP_STRING> ChildValues;
+
+  ChildValues childValues_;
+  JSONCPP_STRING indentString_;
+  unsigned int rightMargin_;
+  JSONCPP_STRING indentation_;
+  CommentStyle::Enum cs_;
+  JSONCPP_STRING colonSymbol_;
+  JSONCPP_STRING nullSymbol_;
+  JSONCPP_STRING endingLineFeedSymbol_;
+  bool addChildValues_ : 1;
+  bool indented_ : 1;
+  bool useSpecialFloats_ : 1;
+  unsigned int precision_;
+};
+BuiltStyledStreamWriter::BuiltStyledStreamWriter(
+      JSONCPP_STRING const& indentation,
+      CommentStyle::Enum cs,
+      JSONCPP_STRING const& colonSymbol,
+      JSONCPP_STRING const& nullSymbol,
+      JSONCPP_STRING const& endingLineFeedSymbol,
+      bool useSpecialFloats,
+      unsigned int precision)
+  : rightMargin_(74)
+  , indentation_(indentation)
+  , cs_(cs)
+  , colonSymbol_(colonSymbol)
+  , nullSymbol_(nullSymbol)
+  , endingLineFeedSymbol_(endingLineFeedSymbol)
+  , addChildValues_(false)
+  , indented_(false)
+  , useSpecialFloats_(useSpecialFloats)
+  , precision_(precision)
+{
+}
+int BuiltStyledStreamWriter::write(Value const& root, JSONCPP_OSTREAM* sout)
+{
+  sout_ = sout;
+  addChildValues_ = false;
+  indented_ = true;
+  indentString_ = "";
+  writeCommentBeforeValue(root);
+  if (!indented_) writeIndent();
+  indented_ = true;
+  writeValue(root);
+  writeCommentAfterValueOnSameLine(root);
+  *sout_ << endingLineFeedSymbol_;
+  sout_ = NULL;
+  return 0;
+}
+void BuiltStyledStreamWriter::writeValue(Value const& value) {
+  switch (value.type()) {
+  case nullValue:
+    pushValue(nullSymbol_);
+    break;
+  case intValue:
+    pushValue(valueToString(value.asLargestInt()));
+    break;
+  case uintValue:
+    pushValue(valueToString(value.asLargestUInt()));
+    break;
+  case realValue:
+    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));
+    break;
+  case stringValue:
+  {
+    // Is NULL is possible for value.string_? No.
+    char const* str;
+    char const* end;
+    bool ok = value.getString(&str, &end);
+    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
+    else pushValue("");
+    break;
+  }
+  case booleanValue:
+    pushValue(valueToString(value.asBool()));
+    break;
+  case arrayValue:
+    writeArrayValue(value);
+    break;
+  case objectValue: {
+    Value::Members members(value.getMemberNames());
+    if (members.empty())
+      pushValue("{}");
+    else {
+      writeWithIndent("{");
+      indent();
+      Value::Members::iterator it = members.begin();
+      for (;;) {
+        JSONCPP_STRING const& name = *it;
+        Value const& childValue = value[name];
+        writeCommentBeforeValue(childValue);
+        writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));
+        *sout_ << colonSymbol_;
+        writeValue(childValue);
+        if (++it == members.end()) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        *sout_ << ",";
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("}");
+    }
+  } break;
+  }
+}
+
+void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
+  unsigned size = value.size();
+  if (size == 0)
+    pushValue("[]");
+  else {
+    bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
+    if (isMultiLine) {
+      writeWithIndent("[");
+      indent();
+      bool hasChildValue = !childValues_.empty();
+      unsigned index = 0;
+      for (;;) {
+        Value const& childValue = value[index];
+        writeCommentBeforeValue(childValue);
+        if (hasChildValue)
+          writeWithIndent(childValues_[index]);
+        else {
+          if (!indented_) writeIndent();
+          indented_ = true;
+          writeValue(childValue);
+          indented_ = false;
+        }
+        if (++index == size) {
+          writeCommentAfterValueOnSameLine(childValue);
+          break;
+        }
+        *sout_ << ",";
+        writeCommentAfterValueOnSameLine(childValue);
+      }
+      unindent();
+      writeWithIndent("]");
+    } else // output on a single line
+    {
+      assert(childValues_.size() == size);
+      *sout_ << "[";
+      if (!indentation_.empty()) *sout_ << " ";
+      for (unsigned index = 0; index < size; ++index) {
+        if (index > 0)
+          *sout_ << ((!indentation_.empty()) ? ", " : ",");
+        *sout_ << childValues_[index];
+      }
+      if (!indentation_.empty()) *sout_ << " ";
+      *sout_ << "]";
+    }
+  }
+}
+
+bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
+  ArrayIndex const size = value.size();
+  bool isMultiLine = size * 3 >= rightMargin_;
+  childValues_.clear();
+  for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
+    Value const& childValue = value[index];
+    isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
+                        childValue.size() > 0);
+  }
+  if (!isMultiLine) // check if line length > max line length
+  {
+    childValues_.reserve(size);
+    addChildValues_ = true;
+    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
+    for (ArrayIndex index = 0; index < size; ++index) {
+      if (hasCommentForValue(value[index])) {
+        isMultiLine = true;
+      }
+      writeValue(value[index]);
+      lineLength += static_cast<ArrayIndex>(childValues_[index].length());
+    }
+    addChildValues_ = false;
+    isMultiLine = isMultiLine || lineLength >= rightMargin_;
+  }
+  return isMultiLine;
+}
+
+void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
+  if (addChildValues_)
+    childValues_.push_back(value);
+  else
+    *sout_ << value;
+}
+
+void BuiltStyledStreamWriter::writeIndent() {
+  // blep intended this to look at the so-far-written string
+  // to determine whether we are already indented, but
+  // with a stream we cannot do that. So we rely on some saved state.
+  // The caller checks indented_.
+
+  if (!indentation_.empty()) {
+    // In this case, drop newlines too.
+    *sout_ << '\n' << indentString_;
+  }
+}
+
+void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {
+  if (!indented_) writeIndent();
+  *sout_ << value;
+  indented_ = false;
+}
+
+void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }
+
+void BuiltStyledStreamWriter::unindent() {
+  assert(indentString_.size() >= indentation_.size());
+  indentString_.resize(indentString_.size() - indentation_.size());
+}
+
+void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
+  if (cs_ == CommentStyle::None) return;
+  if (!root.hasComment(commentBefore))
+    return;
+
+  if (!indented_) writeIndent();
+  const JSONCPP_STRING& comment = root.getComment(commentBefore);
+  JSONCPP_STRING::const_iterator iter = comment.begin();
+  while (iter != comment.end()) {
+    *sout_ << *iter;
+    if (*iter == '\n' &&
+       (iter != comment.end() && *(iter + 1) == '/'))
+      // writeIndent();  // would write extra newline
+      *sout_ << indentString_;
+    ++iter;
+  }
+  indented_ = false;
+}
+
+void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {
+  if (cs_ == CommentStyle::None) return;
+  if (root.hasComment(commentAfterOnSameLine))
+    *sout_ << " " + root.getComment(commentAfterOnSameLine);
+
+  if (root.hasComment(commentAfter)) {
+    writeIndent();
+    *sout_ << root.getComment(commentAfter);
+  }
+}
+
+// static
+bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
+  return value.hasComment(commentBefore) ||
+         value.hasComment(commentAfterOnSameLine) ||
+         value.hasComment(commentAfter);
+}
+
+///////////////
+// StreamWriter
+
+StreamWriter::StreamWriter()
+    : sout_(NULL)
+{
+}
+StreamWriter::~StreamWriter()
+{
+}
+StreamWriter::Factory::~Factory()
+{}
+StreamWriterBuilder::StreamWriterBuilder()
+{
+  setDefaults(&settings_);
+}
+StreamWriterBuilder::~StreamWriterBuilder()
+{}
+StreamWriter* StreamWriterBuilder::newStreamWriter() const
+{
+  JSONCPP_STRING indentation = settings_["indentation"].asString();
+  JSONCPP_STRING cs_str = settings_["commentStyle"].asString();
+  bool eyc = settings_["enableYAMLCompatibility"].asBool();
+  bool dnp = settings_["dropNullPlaceholders"].asBool();
+  bool usf = settings_["useSpecialFloats"].asBool(); 
+  unsigned int pre = settings_["precision"].asUInt();
+  CommentStyle::Enum cs = CommentStyle::All;
+  if (cs_str == "All") {
+    cs = CommentStyle::All;
+  } else if (cs_str == "None") {
+    cs = CommentStyle::None;
+  } else {
+    throwRuntimeError("commentStyle must be 'All' or 'None'");
+  }
+  JSONCPP_STRING colonSymbol = " : ";
+  if (eyc) {
+    colonSymbol = ": ";
+  } else if (indentation.empty()) {
+    colonSymbol = ":";
+  }
+  JSONCPP_STRING nullSymbol = "null";
+  if (dnp) {
+    nullSymbol = "";
+  }
+  if (pre > 17) pre = 17;
+  JSONCPP_STRING endingLineFeedSymbol = "";
+  return new BuiltStyledStreamWriter(
+      indentation, cs,
+      colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);
+}
+static void getValidWriterKeys(std::set<JSONCPP_STRING>* valid_keys)
+{
+  valid_keys->clear();
+  valid_keys->insert("indentation");
+  valid_keys->insert("commentStyle");
+  valid_keys->insert("enableYAMLCompatibility");
+  valid_keys->insert("dropNullPlaceholders");
+  valid_keys->insert("useSpecialFloats");
+  valid_keys->insert("precision");
+}
+bool StreamWriterBuilder::validate(Json::Value* invalid) const
+{
+  Json::Value my_invalid;
+  if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
+  Json::Value& inv = *invalid;
+  std::set<JSONCPP_STRING> valid_keys;
+  getValidWriterKeys(&valid_keys);
+  Value::Members keys = settings_.getMemberNames();
+  size_t n = keys.size();
+  for (size_t i = 0; i < n; ++i) {
+    JSONCPP_STRING const& key = keys[i];
+    if (valid_keys.find(key) == valid_keys.end()) {
+      inv[key] = settings_[key];
+    }
+  }
+  return 0u == inv.size();
+}
+Value& StreamWriterBuilder::operator[](JSONCPP_STRING key)
+{
+  return settings_[key];
+}
+// static
+void StreamWriterBuilder::setDefaults(Json::Value* settings)
+{
+  //! [StreamWriterBuilderDefaults]
+  (*settings)["commentStyle"] = "All";
+  (*settings)["indentation"] = "\t";
+  (*settings)["enableYAMLCompatibility"] = false;
+  (*settings)["dropNullPlaceholders"] = false;
+  (*settings)["useSpecialFloats"] = false;
+  (*settings)["precision"] = 17;
+  //! [StreamWriterBuilderDefaults]
+}
+
+JSONCPP_STRING writeString(StreamWriter::Factory const& builder, Value const& root) {
+  JSONCPP_OSTRINGSTREAM sout;
+  StreamWriterPtr const writer(builder.newStreamWriter());
+  writer->write(root, &sout);
+  return sout.str();
+}
+
+JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM& sout, Value const& root) {
+  StreamWriterBuilder builder;
+  StreamWriterPtr const writer(builder.newStreamWriter());
+  writer->write(root, &sout);
+  return sout;
+}
+
+} // namespace Json
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/sconscript polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/sconscript
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/sconscript	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/sconscript	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,8 @@
+Import( 'env buildLibrary' )
+
+buildLibrary( env, Split( """
+    json_reader.cpp 
+    json_value.cpp 
+    json_writer.cpp
+     """ ),
+    'json' )
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/version.h.in polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/version.h.in
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/version.h.in	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/lib_json/version.h.in	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,20 @@
+// DO NOT EDIT. This file (and "version") is generated by CMake.
+// Run CMake configure step to update it.
+#ifndef JSON_VERSION_H_INCLUDED
+# define JSON_VERSION_H_INCLUDED
+
+# define JSONCPP_VERSION_STRING "@JSONCPP_VERSION@"
+# define JSONCPP_VERSION_MAJOR @JSONCPP_VERSION_MAJOR@
+# define JSONCPP_VERSION_MINOR @JSONCPP_VERSION_MINOR@
+# define JSONCPP_VERSION_PATCH @JSONCPP_VERSION_PATCH@
+# define JSONCPP_VERSION_QUALIFIER
+# define JSONCPP_VERSION_HEXA ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) | (JSONCPP_VERSION_PATCH << 8))
+
+#ifdef JSONCPP_USING_SECURE_MEMORY
+#undef JSONCPP_USING_SECURE_MEMORY
+#endif
+#define JSONCPP_USING_SECURE_MEMORY @JSONCPP_USE_SECURE_MEMORY@
+// If non-zero, the library zeroes any memory that it has allocated before
+// it frees its memory.
+
+#endif // JSON_VERSION_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/CMakeLists.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/CMakeLists.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/CMakeLists.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,38 @@
+# vim: et ts=4 sts=4 sw=4 tw=0
+
+ADD_EXECUTABLE( jsoncpp_test 
+                jsontest.cpp
+                jsontest.h
+                main.cpp
+                )
+
+
+IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS( -DJSON_DLL )
+    TARGET_LINK_LIBRARIES(jsoncpp_test jsoncpp_lib)
+ELSE(BUILD_SHARED_LIBS)
+    TARGET_LINK_LIBRARIES(jsoncpp_test jsoncpp_lib_static)
+ENDIF()
+
+# another way to solve issue #90
+#set_target_properties(jsoncpp_test PROPERTIES COMPILE_FLAGS -ffloat-store)
+
+# Run unit tests in post-build
+# (default cmake workflow hides away the test result into a file, resulting in poor dev workflow?!?)
+IF(JSONCPP_WITH_POST_BUILD_UNITTEST)
+    IF(BUILD_SHARED_LIBS)
+        # First, copy the shared lib, for Microsoft.
+        # Then, run the test executable.
+        ADD_CUSTOM_COMMAND( TARGET jsoncpp_test
+                            POST_BUILD
+                            COMMAND ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:jsoncpp_lib> $<TARGET_FILE_DIR:jsoncpp_test>
+                            COMMAND $<TARGET_FILE:jsoncpp_test>)
+    ELSE(BUILD_SHARED_LIBS)
+        # Just run the test executable.
+        ADD_CUSTOM_COMMAND( TARGET jsoncpp_test
+                            POST_BUILD
+                            COMMAND $<TARGET_FILE:jsoncpp_test>)
+    ENDIF()
+ENDIF()
+
+SET_TARGET_PROPERTIES(jsoncpp_test PROPERTIES OUTPUT_NAME jsoncpp_test) 
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,457 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#define _CRT_SECURE_NO_WARNINGS 1 // Prevents deprecation warning with MSVC
+#include "jsontest.h"
+#include <stdio.h>
+#include <string>
+
+#if defined(_MSC_VER)
+// Used to install a report hook that prevent dialog on assertion and error.
+#include <crtdbg.h>
+#endif // if defined(_MSC_VER)
+
+#if defined(_WIN32)
+// Used to prevent dialog on memory fault.
+// Limits headers included by Windows.h
+#define WIN32_LEAN_AND_MEAN
+#define NOSERVICE
+#define NOMCX
+#define NOIME
+#define NOSOUND
+#define NOCOMM
+#define NORPC
+#define NOGDI
+#define NOUSER
+#define NODRIVERS
+#define NOLOGERROR
+#define NOPROFILER
+#define NOMEMMGR
+#define NOLFILEIO
+#define NOOPENFILE
+#define NORESOURCE
+#define NOATOM
+#define NOLANGUAGE
+#define NOLSTRING
+#define NODBCS
+#define NOKEYBOARDINFO
+#define NOGDICAPMASKS
+#define NOCOLOR
+#define NOGDIOBJ
+#define NODRAWTEXT
+#define NOTEXTMETRIC
+#define NOSCALABLEFONT
+#define NOBITMAP
+#define NORASTEROPS
+#define NOMETAFILE
+#define NOSYSMETRICS
+#define NOSYSTEMPARAMSINFO
+#define NOMSG
+#define NOWINSTYLES
+#define NOWINOFFSETS
+#define NOSHOWWINDOW
+#define NODEFERWINDOWPOS
+#define NOVIRTUALKEYCODES
+#define NOKEYSTATES
+#define NOWH
+#define NOMENUS
+#define NOSCROLL
+#define NOCLIPBOARD
+#define NOICONS
+#define NOMB
+#define NOSYSCOMMANDS
+#define NOMDI
+#define NOCTLMGR
+#define NOWINMESSAGES
+#include <windows.h>
+#endif // if defined(_WIN32)
+
+namespace JsonTest {
+
+// class TestResult
+// //////////////////////////////////////////////////////////////////
+
+TestResult::TestResult()
+    : predicateId_(1), lastUsedPredicateId_(0), messageTarget_(0) {
+  // The root predicate has id 0
+  rootPredicateNode_.id_ = 0;
+  rootPredicateNode_.next_ = 0;
+  predicateStackTail_ = &rootPredicateNode_;
+}
+
+void TestResult::setTestName(const JSONCPP_STRING& name) { name_ = name; }
+
+TestResult&
+TestResult::addFailure(const char* file, unsigned int line, const char* expr) {
+  /// Walks the PredicateContext stack adding them to failures_ if not already
+  /// added.
+  unsigned int nestingLevel = 0;
+  PredicateContext* lastNode = rootPredicateNode_.next_;
+  for (; lastNode != 0; lastNode = lastNode->next_) {
+    if (lastNode->id_ > lastUsedPredicateId_) // new PredicateContext
+    {
+      lastUsedPredicateId_ = lastNode->id_;
+      addFailureInfo(
+          lastNode->file_, lastNode->line_, lastNode->expr_, nestingLevel);
+      // Link the PredicateContext to the failure for message target when
+      // popping the PredicateContext.
+      lastNode->failure_ = &(failures_.back());
+    }
+    ++nestingLevel;
+  }
+
+  // Adds the failed assertion
+  addFailureInfo(file, line, expr, nestingLevel);
+  messageTarget_ = &(failures_.back());
+  return *this;
+}
+
+void TestResult::addFailureInfo(const char* file,
+                                unsigned int line,
+                                const char* expr,
+                                unsigned int nestingLevel) {
+  Failure failure;
+  failure.file_ = file;
+  failure.line_ = line;
+  if (expr) {
+    failure.expr_ = expr;
+  }
+  failure.nestingLevel_ = nestingLevel;
+  failures_.push_back(failure);
+}
+
+TestResult& TestResult::popPredicateContext() {
+  PredicateContext* lastNode = &rootPredicateNode_;
+  while (lastNode->next_ != 0 && lastNode->next_->next_ != 0) {
+    lastNode = lastNode->next_;
+  }
+  // Set message target to popped failure
+  PredicateContext* tail = lastNode->next_;
+  if (tail != 0 && tail->failure_ != 0) {
+    messageTarget_ = tail->failure_;
+  }
+  // Remove tail from list
+  predicateStackTail_ = lastNode;
+  lastNode->next_ = 0;
+  return *this;
+}
+
+bool TestResult::failed() const { return !failures_.empty(); }
+
+unsigned int TestResult::getAssertionNestingLevel() const {
+  unsigned int level = 0;
+  const PredicateContext* lastNode = &rootPredicateNode_;
+  while (lastNode->next_ != 0) {
+    lastNode = lastNode->next_;
+    ++level;
+  }
+  return level;
+}
+
+void TestResult::printFailure(bool printTestName) const {
+  if (failures_.empty()) {
+    return;
+  }
+
+  if (printTestName) {
+    printf("* Detail of %s test failure:\n", name_.c_str());
+  }
+
+  // Print in reverse to display the callstack in the right order
+  Failures::const_iterator itEnd = failures_.end();
+  for (Failures::const_iterator it = failures_.begin(); it != itEnd; ++it) {
+    const Failure& failure = *it;
+    JSONCPP_STRING indent(failure.nestingLevel_ * 2, ' ');
+    if (failure.file_) {
+      printf("%s%s(%d): ", indent.c_str(), failure.file_, failure.line_);
+    }
+    if (!failure.expr_.empty()) {
+      printf("%s\n", failure.expr_.c_str());
+    } else if (failure.file_) {
+      printf("\n");
+    }
+    if (!failure.message_.empty()) {
+      JSONCPP_STRING reindented = indentText(failure.message_, indent + "  ");
+      printf("%s\n", reindented.c_str());
+    }
+  }
+}
+
+JSONCPP_STRING TestResult::indentText(const JSONCPP_STRING& text,
+                                   const JSONCPP_STRING& indent) {
+  JSONCPP_STRING reindented;
+  JSONCPP_STRING::size_type lastIndex = 0;
+  while (lastIndex < text.size()) {
+    JSONCPP_STRING::size_type nextIndex = text.find('\n', lastIndex);
+    if (nextIndex == JSONCPP_STRING::npos) {
+      nextIndex = text.size() - 1;
+    }
+    reindented += indent;
+    reindented += text.substr(lastIndex, nextIndex - lastIndex + 1);
+    lastIndex = nextIndex + 1;
+  }
+  return reindented;
+}
+
+TestResult& TestResult::addToLastFailure(const JSONCPP_STRING& message) {
+  if (messageTarget_ != 0) {
+    messageTarget_->message_ += message;
+  }
+  return *this;
+}
+
+TestResult& TestResult::operator<<(Json::Int64 value) {
+  return addToLastFailure(Json::valueToString(value));
+}
+
+TestResult& TestResult::operator<<(Json::UInt64 value) {
+  return addToLastFailure(Json::valueToString(value));
+}
+
+TestResult& TestResult::operator<<(bool value) {
+  return addToLastFailure(value ? "true" : "false");
+}
+
+// class TestCase
+// //////////////////////////////////////////////////////////////////
+
+TestCase::TestCase() : result_(0) {}
+
+TestCase::~TestCase() {}
+
+void TestCase::run(TestResult& result) {
+  result_ = &result;
+  runTestCase();
+}
+
+// class Runner
+// //////////////////////////////////////////////////////////////////
+
+Runner::Runner() {}
+
+Runner& Runner::add(TestCaseFactory factory) {
+  tests_.push_back(factory);
+  return *this;
+}
+
+unsigned int Runner::testCount() const {
+  return static_cast<unsigned int>(tests_.size());
+}
+
+JSONCPP_STRING Runner::testNameAt(unsigned int index) const {
+  TestCase* test = tests_[index]();
+  JSONCPP_STRING name = test->testName();
+  delete test;
+  return name;
+}
+
+void Runner::runTestAt(unsigned int index, TestResult& result) const {
+  TestCase* test = tests_[index]();
+  result.setTestName(test->testName());
+  printf("Testing %s: ", test->testName());
+  fflush(stdout);
+#if JSON_USE_EXCEPTION
+  try {
+#endif // if JSON_USE_EXCEPTION
+    test->run(result);
+#if JSON_USE_EXCEPTION
+  }
+  catch (const std::exception& e) {
+    result.addFailure(__FILE__, __LINE__, "Unexpected exception caught:")
+        << e.what();
+  }
+#endif // if JSON_USE_EXCEPTION
+  delete test;
+  const char* status = result.failed() ? "FAILED" : "OK";
+  printf("%s\n", status);
+  fflush(stdout);
+}
+
+bool Runner::runAllTest(bool printSummary) const {
+  unsigned int count = testCount();
+  std::deque<TestResult> failures;
+  for (unsigned int index = 0; index < count; ++index) {
+    TestResult result;
+    runTestAt(index, result);
+    if (result.failed()) {
+      failures.push_back(result);
+    }
+  }
+
+  if (failures.empty()) {
+    if (printSummary) {
+      printf("All %d tests passed\n", count);
+    }
+    return true;
+  } else {
+    for (unsigned int index = 0; index < failures.size(); ++index) {
+      TestResult& result = failures[index];
+      result.printFailure(count > 1);
+    }
+
+    if (printSummary) {
+      unsigned int failedCount = static_cast<unsigned int>(failures.size());
+      unsigned int passedCount = count - failedCount;
+      printf("%d/%d tests passed (%d failure(s))\n",
+             passedCount,
+             count,
+             failedCount);
+    }
+    return false;
+  }
+}
+
+bool Runner::testIndex(const JSONCPP_STRING& testName,
+                       unsigned int& indexOut) const {
+  unsigned int count = testCount();
+  for (unsigned int index = 0; index < count; ++index) {
+    if (testNameAt(index) == testName) {
+      indexOut = index;
+      return true;
+    }
+  }
+  return false;
+}
+
+void Runner::listTests() const {
+  unsigned int count = testCount();
+  for (unsigned int index = 0; index < count; ++index) {
+    printf("%s\n", testNameAt(index).c_str());
+  }
+}
+
+int Runner::runCommandLine(int argc, const char* argv[]) const {
+  // typedef std::deque<JSONCPP_STRING> TestNames;
+  Runner subrunner;
+  for (int index = 1; index < argc; ++index) {
+    JSONCPP_STRING opt = argv[index];
+    if (opt == "--list-tests") {
+      listTests();
+      return 0;
+    } else if (opt == "--test-auto") {
+      preventDialogOnCrash();
+    } else if (opt == "--test") {
+      ++index;
+      if (index < argc) {
+        unsigned int testNameIndex;
+        if (testIndex(argv[index], testNameIndex)) {
+          subrunner.add(tests_[testNameIndex]);
+        } else {
+          fprintf(stderr, "Test '%s' does not exist!\n", argv[index]);
+          return 2;
+        }
+      } else {
+        printUsage(argv[0]);
+        return 2;
+      }
+    } else {
+      printUsage(argv[0]);
+      return 2;
+    }
+  }
+  bool succeeded;
+  if (subrunner.testCount() > 0) {
+    succeeded = subrunner.runAllTest(subrunner.testCount() > 1);
+  } else {
+    succeeded = runAllTest(true);
+  }
+  return succeeded ? 0 : 1;
+}
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+// Hook MSVCRT assertions to prevent dialog from appearing
+static int
+msvcrtSilentReportHook(int reportType, char* message, int* /*returnValue*/) {
+  // The default CRT handling of error and assertion is to display
+  // an error dialog to the user.
+  // Instead, when an error or an assertion occurs, we force the
+  // application to terminate using abort() after display
+  // the message on stderr.
+  if (reportType == _CRT_ERROR || reportType == _CRT_ASSERT) {
+    // calling abort() cause the ReportHook to be called
+    // The following is used to detect this case and let's the
+    // error handler fallback on its default behaviour (
+    // display a warning message)
+    static volatile bool isAborting = false;
+    if (isAborting) {
+      return TRUE;
+    }
+    isAborting = true;
+
+    fprintf(stderr, "CRT Error/Assert:\n%s\n", message);
+    fflush(stderr);
+    abort();
+  }
+  // Let's other reportType (_CRT_WARNING) be handled as they would by default
+  return FALSE;
+}
+#endif // if defined(_MSC_VER)
+
+void Runner::preventDialogOnCrash() {
+#if defined(_MSC_VER) && defined(_DEBUG)
+  // Install a hook to prevent MSVCRT error and assertion from
+  // popping a dialog
+  // This function a NO-OP in release configuration
+  // (which cause warning since msvcrtSilentReportHook is not referenced)
+  _CrtSetReportHook(&msvcrtSilentReportHook);
+#endif // if defined(_MSC_VER)
+
+// @todo investiguate this handler (for buffer overflow)
+// _set_security_error_handler
+
+#if defined(_WIN32)
+  // Prevents the system from popping a dialog for debugging if the
+  // application fails due to invalid memory access.
+  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX |
+               SEM_NOOPENFILEERRORBOX);
+#endif // if defined(_WIN32)
+}
+
+void Runner::printUsage(const char* appName) {
+  printf("Usage: %s [options]\n"
+         "\n"
+         "If --test is not specified, then all the test cases be run.\n"
+         "\n"
+         "Valid options:\n"
+         "--list-tests: print the name of all test cases on the standard\n"
+         "              output and exit.\n"
+         "--test TESTNAME: executes the test case with the specified name.\n"
+         "                 May be repeated.\n"
+         "--test-auto: prevent dialog prompting for debugging on crash.\n",
+         appName);
+}
+
+// Assertion functions
+// //////////////////////////////////////////////////////////////////
+
+JSONCPP_STRING ToJsonString(const char* toConvert) {
+  return JSONCPP_STRING(toConvert);
+}
+
+JSONCPP_STRING ToJsonString(JSONCPP_STRING in) {
+  return in;
+}
+
+#if JSONCPP_USING_SECURE_MEMORY
+JSONCPP_STRING ToJsonString(std::string in) {
+  return JSONCPP_STRING(in.data(), in.data() + in.length());
+}
+#endif
+
+TestResult& checkStringEqual(TestResult& result,
+                             const JSONCPP_STRING& expected,
+                             const JSONCPP_STRING& actual,
+                             const char* file,
+                             unsigned int line,
+                             const char* expr) {
+  if (expected != actual) {
+    result.addFailure(file, line, expr);
+    result << "Expected: '" << expected << "'\n";
+    result << "Actual  : '" << actual << "'";
+  }
+  return result;
+}
+
+} // namespace JsonTest
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.h polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.h
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.h	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/jsontest.h	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,286 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#ifndef JSONTEST_H_INCLUDED
+#define JSONTEST_H_INCLUDED
+
+#include <json/config.h>
+#include <json/value.h>
+#include <json/writer.h>
+#include <stdio.h>
+#include <deque>
+#include <sstream>
+#include <string>
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// Mini Unit Testing framework
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+/** \brief Unit testing framework.
+ * \warning: all assertions are non-aborting, test case execution will continue
+ *           even if an assertion namespace.
+ *           This constraint is for portability: the framework needs to compile
+ *           on Visual Studio 6 and must not require exception usage.
+ */
+namespace JsonTest {
+
+class Failure {
+public:
+  const char* file_;
+  unsigned int line_;
+  JSONCPP_STRING expr_;
+  JSONCPP_STRING message_;
+  unsigned int nestingLevel_;
+};
+
+/// Context used to create the assertion callstack on failure.
+/// Must be a POD to allow inline initialisation without stepping
+/// into the debugger.
+struct PredicateContext {
+  typedef unsigned int Id;
+  Id id_;
+  const char* file_;
+  unsigned int line_;
+  const char* expr_;
+  PredicateContext* next_;
+  /// Related Failure, set when the PredicateContext is converted
+  /// into a Failure.
+  Failure* failure_;
+};
+
+class TestResult {
+public:
+  TestResult();
+
+  /// \internal Implementation detail for assertion macros
+  /// Not encapsulated to prevent step into when debugging failed assertions
+  /// Incremented by one on assertion predicate entry, decreased by one
+  /// by addPredicateContext().
+  PredicateContext::Id predicateId_;
+
+  /// \internal Implementation detail for predicate macros
+  PredicateContext* predicateStackTail_;
+
+  void setTestName(const JSONCPP_STRING& name);
+
+  /// Adds an assertion failure.
+  TestResult&
+  addFailure(const char* file, unsigned int line, const char* expr = 0);
+
+  /// Removes the last PredicateContext added to the predicate stack
+  /// chained list.
+  /// Next messages will be targed at the PredicateContext that was removed.
+  TestResult& popPredicateContext();
+
+  bool failed() const;
+
+  void printFailure(bool printTestName) const;
+
+  // Generic operator that will work with anything ostream can deal with.
+  template <typename T> TestResult& operator<<(const T& value) {
+    JSONCPP_OSTRINGSTREAM oss;
+    oss.precision(16);
+    oss.setf(std::ios_base::floatfield);
+    oss << value;
+    return addToLastFailure(oss.str());
+  }
+
+  // Specialized versions.
+  TestResult& operator<<(bool value);
+  // std:ostream does not support 64bits integers on all STL implementation
+  TestResult& operator<<(Json::Int64 value);
+  TestResult& operator<<(Json::UInt64 value);
+
+private:
+  TestResult& addToLastFailure(const JSONCPP_STRING& message);
+  unsigned int getAssertionNestingLevel() const;
+  /// Adds a failure or a predicate context
+  void addFailureInfo(const char* file,
+                      unsigned int line,
+                      const char* expr,
+                      unsigned int nestingLevel);
+  static JSONCPP_STRING indentText(const JSONCPP_STRING& text,
+                                const JSONCPP_STRING& indent);
+
+  typedef std::deque<Failure> Failures;
+  Failures failures_;
+  JSONCPP_STRING name_;
+  PredicateContext rootPredicateNode_;
+  PredicateContext::Id lastUsedPredicateId_;
+  /// Failure which is the target of the messages added using operator <<
+  Failure* messageTarget_;
+};
+
+class TestCase {
+public:
+  TestCase();
+
+  virtual ~TestCase();
+
+  void run(TestResult& result);
+
+  virtual const char* testName() const = 0;
+
+protected:
+  TestResult* result_;
+
+private:
+  virtual void runTestCase() = 0;
+};
+
+/// Function pointer type for TestCase factory
+typedef TestCase* (*TestCaseFactory)();
+
+class Runner {
+public:
+  Runner();
+
+  /// Adds a test to the suite
+  Runner& add(TestCaseFactory factory);
+
+  /// Runs test as specified on the command-line
+  /// If no command-line arguments are provided, run all tests.
+  /// If --list-tests is provided, then print the list of all test cases
+  /// If --test <testname> is provided, then run test testname.
+  int runCommandLine(int argc, const char* argv[]) const;
+
+  /// Runs all the test cases
+  bool runAllTest(bool printSummary) const;
+
+  /// Returns the number of test case in the suite
+  unsigned int testCount() const;
+
+  /// Returns the name of the test case at the specified index
+  JSONCPP_STRING testNameAt(unsigned int index) const;
+
+  /// Runs the test case at the specified index using the specified TestResult
+  void runTestAt(unsigned int index, TestResult& result) const;
+
+  static void printUsage(const char* appName);
+
+private: // prevents copy construction and assignment
+  Runner(const Runner& other);
+  Runner& operator=(const Runner& other);
+
+private:
+  void listTests() const;
+  bool testIndex(const JSONCPP_STRING& testName, unsigned int& index) const;
+  static void preventDialogOnCrash();
+
+private:
+  typedef std::deque<TestCaseFactory> Factories;
+  Factories tests_;
+};
+
+template <typename T, typename U>
+TestResult& checkEqual(TestResult& result,
+                       T expected,
+                       U actual,
+                       const char* file,
+                       unsigned int line,
+                       const char* expr) {
+  if (static_cast<U>(expected) != actual) {
+    result.addFailure(file, line, expr);
+    result << "Expected: " << static_cast<U>(expected) << "\n";
+    result << "Actual  : " << actual;
+  }
+  return result;
+}
+
+JSONCPP_STRING ToJsonString(const char* toConvert);
+JSONCPP_STRING ToJsonString(JSONCPP_STRING in);
+#if JSONCPP_USING_SECURE_MEMORY
+JSONCPP_STRING ToJsonString(std::string in);
+#endif
+
+TestResult& checkStringEqual(TestResult& result,
+                             const JSONCPP_STRING& expected,
+                             const JSONCPP_STRING& actual,
+                             const char* file,
+                             unsigned int line,
+                             const char* expr);
+
+} // namespace JsonTest
+
+/// \brief Asserts that the given expression is true.
+/// JSONTEST_ASSERT( x == y ) << "x=" << x << ", y=" << y;
+/// JSONTEST_ASSERT( x == y );
+#define JSONTEST_ASSERT(expr)                                                  \
+  if (expr) {                                                                  \
+  } else                                                                       \
+  result_->addFailure(__FILE__, __LINE__, #expr)
+
+/// \brief Asserts that the given predicate is true.
+/// The predicate may do other assertions and be a member function of the
+/// fixture.
+#define JSONTEST_ASSERT_PRED(expr)                                             \
+  {                                                                            \
+    JsonTest::PredicateContext _minitest_Context = {                           \
+      result_->predicateId_, __FILE__, __LINE__, #expr, NULL, NULL             \
+    };                                                                         \
+    result_->predicateStackTail_->next_ = &_minitest_Context;                  \
+    result_->predicateId_ += 1;                                                \
+    result_->predicateStackTail_ = &_minitest_Context;                         \
+    (expr);                                                                    \
+    result_->popPredicateContext();                                            \
+  }
+
+/// \brief Asserts that two values are equals.
+#define JSONTEST_ASSERT_EQUAL(expected, actual)                                \
+  JsonTest::checkEqual(*result_,                                               \
+                       expected,                                               \
+                       actual,                                                 \
+                       __FILE__,                                               \
+                       __LINE__,                                               \
+                       #expected " == " #actual)
+
+/// \brief Asserts that two values are equals.
+#define JSONTEST_ASSERT_STRING_EQUAL(expected, actual)                         \
+  JsonTest::checkStringEqual(*result_,                                         \
+		                 JsonTest::ToJsonString(expected),                 \
+		                     JsonTest::ToJsonString(actual),                   \
+                             __FILE__,                                         \
+                             __LINE__,                                         \
+                             #expected " == " #actual)
+
+/// \brief Asserts that a given expression throws an exception
+#define JSONTEST_ASSERT_THROWS(expr)                                           \
+  {                                                                            \
+    bool _threw = false;                                                       \
+    try {                                                                      \
+      expr;                                                                    \
+    }                                                                          \
+    catch (...) {                                                              \
+      _threw = true;                                                           \
+    }                                                                          \
+    if (!_threw)                                                               \
+      result_->addFailure(                                                     \
+          __FILE__, __LINE__, "expected exception thrown: " #expr);            \
+  }
+
+/// \brief Begin a fixture test case.
+#define JSONTEST_FIXTURE(FixtureType, name)                                    \
+  class Test##FixtureType##name : public FixtureType {                         \
+  public:                                                                      \
+    static JsonTest::TestCase* factory() {                                     \
+      return new Test##FixtureType##name();                                    \
+    }                                                                          \
+                                                                               \
+  public: /* overidden from TestCase */                                        \
+    const char* testName() const JSONCPP_OVERRIDE { return #FixtureType "/" #name; }    \
+    void runTestCase() JSONCPP_OVERRIDE;                                                \
+  };                                                                           \
+                                                                               \
+  void Test##FixtureType##name::runTestCase()
+
+#define JSONTEST_FIXTURE_FACTORY(FixtureType, name)                            \
+  &Test##FixtureType##name::factory
+
+#define JSONTEST_REGISTER_FIXTURE(runner, FixtureType, name)                   \
+  (runner).add(JSONTEST_FIXTURE_FACTORY(FixtureType, name))
+
+#endif // ifndef JSONTEST_H_INCLUDED
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/main.cpp polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/main.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/main.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/main.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2589 @@
+// Copyright 2007-2010 Baptiste Lepilleur
+// Distributed under MIT license, or public domain if desired and
+// recognized in your jurisdiction.
+// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+#include "jsontest.h"
+#include <json/config.h>
+#include <json/json.h>
+#include <cstring>
+#include <limits>
+#include <sstream>
+#include <string>
+#include <iomanip>
+
+// Make numeric limits more convenient to talk about.
+// Assumes int type in 32 bits.
+#define kint32max Json::Value::maxInt
+#define kint32min Json::Value::minInt
+#define kuint32max Json::Value::maxUInt
+#define kint64max Json::Value::maxInt64
+#define kint64min Json::Value::minInt64
+#define kuint64max Json::Value::maxUInt64
+
+//static const double kdint64max = double(kint64max);
+//static const float kfint64max = float(kint64max);
+static const float kfint32max = float(kint32max);
+static const float kfuint32max = float(kuint32max);
+
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+// Json Library test cases
+// //////////////////////////////////////////////////////////////////
+// //////////////////////////////////////////////////////////////////
+
+#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+static inline double uint64ToDouble(Json::UInt64 value) {
+  return static_cast<double>(value);
+}
+#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+static inline double uint64ToDouble(Json::UInt64 value) {
+  return static_cast<double>(Json::Int64(value / 2)) * 2.0 +
+         static_cast<double>(Json::Int64(value & 1));
+}
+#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
+
+struct ValueTest : JsonTest::TestCase {
+  Json::Value null_;
+  Json::Value emptyArray_;
+  Json::Value emptyObject_;
+  Json::Value integer_;
+  Json::Value unsignedInteger_;
+  Json::Value smallUnsignedInteger_;
+  Json::Value real_;
+  Json::Value float_;
+  Json::Value array1_;
+  Json::Value object1_;
+  Json::Value emptyString_;
+  Json::Value string1_;
+  Json::Value string_;
+  Json::Value true_;
+  Json::Value false_;
+
+  ValueTest()
+      : emptyArray_(Json::arrayValue), emptyObject_(Json::objectValue),
+        integer_(123456789), unsignedInteger_(34567890u),
+        smallUnsignedInteger_(Json::Value::UInt(Json::Value::maxInt)),
+        real_(1234.56789), float_(0.00390625f), emptyString_(""), string1_("a"),
+        string_("sometext with space"), true_(true), false_(false) {
+    array1_.append(1234);
+    object1_["id"] = 1234;
+  }
+
+  struct IsCheck {
+    /// Initialize all checks to \c false by default.
+    IsCheck();
+
+    bool isObject_;
+    bool isArray_;
+    bool isBool_;
+    bool isString_;
+    bool isNull_;
+
+    bool isInt_;
+    bool isInt64_;
+    bool isUInt_;
+    bool isUInt64_;
+    bool isIntegral_;
+    bool isDouble_;
+    bool isNumeric_;
+  };
+
+  void checkConstMemberCount(const Json::Value& value,
+                             unsigned int expectedCount);
+
+  void checkMemberCount(Json::Value& value, unsigned int expectedCount);
+
+  void checkIs(const Json::Value& value, const IsCheck& check);
+
+  void checkIsLess(const Json::Value& x, const Json::Value& y);
+
+  void checkIsEqual(const Json::Value& x, const Json::Value& y);
+
+  /// Normalize the representation of floating-point number by stripped leading
+  /// 0 in exponent.
+  static JSONCPP_STRING normalizeFloatingPointStr(const JSONCPP_STRING& s);
+};
+
+JSONCPP_STRING ValueTest::normalizeFloatingPointStr(const JSONCPP_STRING& s) {
+  JSONCPP_STRING::size_type index = s.find_last_of("eE");
+  if (index != JSONCPP_STRING::npos) {
+    JSONCPP_STRING::size_type hasSign =
+        (s[index + 1] == '+' || s[index + 1] == '-') ? 1 : 0;
+    JSONCPP_STRING::size_type exponentStartIndex = index + 1 + hasSign;
+    JSONCPP_STRING normalized = s.substr(0, exponentStartIndex);
+    JSONCPP_STRING::size_type indexDigit =
+        s.find_first_not_of('0', exponentStartIndex);
+    JSONCPP_STRING exponent = "0";
+    if (indexDigit !=
+        JSONCPP_STRING::npos) // There is an exponent different from 0
+    {
+      exponent = s.substr(indexDigit);
+    }
+    return normalized + exponent;
+  }
+  return s;
+}
+
+JSONTEST_FIXTURE(ValueTest, checkNormalizeFloatingPointStr) {
+  JSONTEST_ASSERT_STRING_EQUAL("0.0", normalizeFloatingPointStr("0.0"));
+  JSONTEST_ASSERT_STRING_EQUAL("0e0", normalizeFloatingPointStr("0e0"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234.0", normalizeFloatingPointStr("1234.0"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234.0e0",
+                               normalizeFloatingPointStr("1234.0e0"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234.0e+0",
+                               normalizeFloatingPointStr("1234.0e+0"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e-1", normalizeFloatingPointStr("1234e-1"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e10", normalizeFloatingPointStr("1234e10"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e10",
+                               normalizeFloatingPointStr("1234e010"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e+10",
+                               normalizeFloatingPointStr("1234e+010"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e-10",
+                               normalizeFloatingPointStr("1234e-010"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e+100",
+                               normalizeFloatingPointStr("1234e+100"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e-100",
+                               normalizeFloatingPointStr("1234e-100"));
+  JSONTEST_ASSERT_STRING_EQUAL("1234e+1",
+                               normalizeFloatingPointStr("1234e+001"));
+}
+
+JSONTEST_FIXTURE(ValueTest, memberCount) {
+  JSONTEST_ASSERT_PRED(checkMemberCount(emptyArray_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(emptyObject_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(array1_, 1));
+  JSONTEST_ASSERT_PRED(checkMemberCount(object1_, 1));
+  JSONTEST_ASSERT_PRED(checkMemberCount(null_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(integer_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(unsignedInteger_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(smallUnsignedInteger_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(real_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(emptyString_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(string_, 0));
+  JSONTEST_ASSERT_PRED(checkMemberCount(true_, 0));
+}
+
+JSONTEST_FIXTURE(ValueTest, objects) {
+  // Types
+  IsCheck checks;
+  checks.isObject_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(emptyObject_, checks));
+  JSONTEST_ASSERT_PRED(checkIs(object1_, checks));
+
+  JSONTEST_ASSERT_EQUAL(Json::objectValue, emptyObject_.type());
+
+  // Empty object okay
+  JSONTEST_ASSERT(emptyObject_.isConvertibleTo(Json::nullValue));
+
+  // Non-empty object not okay
+  JSONTEST_ASSERT(!object1_.isConvertibleTo(Json::nullValue));
+
+  // Always okay
+  JSONTEST_ASSERT(emptyObject_.isConvertibleTo(Json::objectValue));
+
+  // Never okay
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(!emptyObject_.isConvertibleTo(Json::stringValue));
+
+  // Access through const reference
+  const Json::Value& constObject = object1_;
+
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), constObject["id"]);
+  JSONTEST_ASSERT_EQUAL(Json::Value(), constObject["unknown id"]);
+
+  // Access through non-const reference
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), object1_["id"]);
+  JSONTEST_ASSERT_EQUAL(Json::Value(), object1_["unknown id"]);
+
+  object1_["some other id"] = "foo";
+  JSONTEST_ASSERT_EQUAL(Json::Value("foo"), object1_["some other id"]);
+  JSONTEST_ASSERT_EQUAL(Json::Value("foo"), object1_["some other id"]);
+
+  // Remove.
+  Json::Value got;
+  bool did;
+  did = object1_.removeMember("some other id", &got);
+  JSONTEST_ASSERT_EQUAL(Json::Value("foo"), got);
+  JSONTEST_ASSERT_EQUAL(true, did);
+  got = Json::Value("bar");
+  did = object1_.removeMember("some other id", &got);
+  JSONTEST_ASSERT_EQUAL(Json::Value("bar"), got);
+  JSONTEST_ASSERT_EQUAL(false, did);
+}
+
+JSONTEST_FIXTURE(ValueTest, arrays) {
+  const unsigned int index0 = 0;
+
+  // Types
+  IsCheck checks;
+  checks.isArray_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(emptyArray_, checks));
+  JSONTEST_ASSERT_PRED(checkIs(array1_, checks));
+
+  JSONTEST_ASSERT_EQUAL(Json::arrayValue, array1_.type());
+
+  // Empty array okay
+  JSONTEST_ASSERT(emptyArray_.isConvertibleTo(Json::nullValue));
+
+  // Non-empty array not okay
+  JSONTEST_ASSERT(!array1_.isConvertibleTo(Json::nullValue));
+
+  // Always okay
+  JSONTEST_ASSERT(emptyArray_.isConvertibleTo(Json::arrayValue));
+
+  // Never okay
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::objectValue));
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(!emptyArray_.isConvertibleTo(Json::stringValue));
+
+  // Access through const reference
+  const Json::Value& constArray = array1_;
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), constArray[index0]);
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), constArray[0]);
+
+  // Access through non-const reference
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), array1_[index0]);
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), array1_[0]);
+
+  array1_[2] = Json::Value(17);
+  JSONTEST_ASSERT_EQUAL(Json::Value(), array1_[1]);
+  JSONTEST_ASSERT_EQUAL(Json::Value(17), array1_[2]);
+  Json::Value got;
+  JSONTEST_ASSERT_EQUAL(true, array1_.removeIndex(2, &got));
+  JSONTEST_ASSERT_EQUAL(Json::Value(17), got);
+  JSONTEST_ASSERT_EQUAL(false, array1_.removeIndex(2, &got)); // gone now
+}
+JSONTEST_FIXTURE(ValueTest, arrayIssue252)
+{
+  int count = 5;
+  Json::Value root;
+  Json::Value item;
+  root["array"] = Json::Value::nullRef;
+  for (int i = 0; i < count; i++)
+  {
+    item["a"] = i;
+    item["b"] = i;
+    root["array"][i] = item;
+  }
+  //JSONTEST_ASSERT_EQUAL(5, root["array"].size());
+}
+
+JSONTEST_FIXTURE(ValueTest, null) {
+  JSONTEST_ASSERT_EQUAL(Json::nullValue, null_.type());
+
+  IsCheck checks;
+  checks.isNull_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(null_, checks));
+
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(null_.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(Json::Int(0), null_.asInt());
+  JSONTEST_ASSERT_EQUAL(Json::LargestInt(0), null_.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(Json::UInt(0), null_.asUInt());
+  JSONTEST_ASSERT_EQUAL(Json::LargestUInt(0), null_.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, null_.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, null_.asFloat());
+  JSONTEST_ASSERT_STRING_EQUAL("", null_.asString());
+
+  JSONTEST_ASSERT_EQUAL(Json::Value::null, null_);
+}
+
+JSONTEST_FIXTURE(ValueTest, strings) {
+  JSONTEST_ASSERT_EQUAL(Json::stringValue, string1_.type());
+
+  IsCheck checks;
+  checks.isString_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(emptyString_, checks));
+  JSONTEST_ASSERT_PRED(checkIs(string_, checks));
+  JSONTEST_ASSERT_PRED(checkIs(string1_, checks));
+
+  // Empty string okay
+  JSONTEST_ASSERT(emptyString_.isConvertibleTo(Json::nullValue));
+
+  // Non-empty string not okay
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::nullValue));
+
+  // Always okay
+  JSONTEST_ASSERT(string1_.isConvertibleTo(Json::stringValue));
+
+  // Never okay
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::objectValue));
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!string1_.isConvertibleTo(Json::realValue));
+
+  JSONTEST_ASSERT_STRING_EQUAL("a", string1_.asString());
+  JSONTEST_ASSERT_STRING_EQUAL("a", string1_.asCString());
+}
+
+JSONTEST_FIXTURE(ValueTest, bools) {
+  JSONTEST_ASSERT_EQUAL(Json::booleanValue, false_.type());
+
+  IsCheck checks;
+  checks.isBool_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(false_, checks));
+  JSONTEST_ASSERT_PRED(checkIs(true_, checks));
+
+  // False okay
+  JSONTEST_ASSERT(false_.isConvertibleTo(Json::nullValue));
+
+  // True not okay
+  JSONTEST_ASSERT(!true_.isConvertibleTo(Json::nullValue));
+
+  // Always okay
+  JSONTEST_ASSERT(true_.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(true_.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(true_.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(true_.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(true_.isConvertibleTo(Json::stringValue));
+
+  // Never okay
+  JSONTEST_ASSERT(!true_.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!true_.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(true, true_.asBool());
+  JSONTEST_ASSERT_EQUAL(1, true_.asInt());
+  JSONTEST_ASSERT_EQUAL(1, true_.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(1, true_.asUInt());
+  JSONTEST_ASSERT_EQUAL(1, true_.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(1.0, true_.asDouble());
+  JSONTEST_ASSERT_EQUAL(1.0, true_.asFloat());
+
+  JSONTEST_ASSERT_EQUAL(false, false_.asBool());
+  JSONTEST_ASSERT_EQUAL(0, false_.asInt());
+  JSONTEST_ASSERT_EQUAL(0, false_.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, false_.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, false_.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, false_.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, false_.asFloat());
+}
+
+JSONTEST_FIXTURE(ValueTest, integers) {
+  IsCheck checks;
+  Json::Value val;
+
+  // Conversions that don't depend on the value.
+  JSONTEST_ASSERT(Json::Value(17).isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(Json::Value(17).isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(Json::Value(17).isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(!Json::Value(17).isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!Json::Value(17).isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT(Json::Value(17U).isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(Json::Value(17U).isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(Json::Value(17U).isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(!Json::Value(17U).isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!Json::Value(17U).isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT(Json::Value(17.0).isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(Json::Value(17.0).isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(Json::Value(17.0).isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(!Json::Value(17.0).isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!Json::Value(17.0).isConvertibleTo(Json::objectValue));
+
+  // Default int
+  val = Json::Value(Json::intValue);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // Default uint
+  val = Json::Value(Json::uintValue);
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // Default real
+  val = Json::Value(Json::realValue);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // Zero (signed constructor arg)
+  val = Json::Value(0);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // Zero (unsigned constructor arg)
+  val = Json::Value(0u);
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // Zero (floating-point constructor arg)
+  val = Json::Value(0.0);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(0, val.asInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(0, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(0.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(false, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("0", val.asString());
+
+  // 2^20 (signed constructor arg)
+  val = Json::Value(1 << 20);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1048576", val.asString());
+
+  // 2^20 (unsigned constructor arg)
+  val = Json::Value(Json::UInt(1 << 20));
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1048576", val.asString());
+
+  // 2^20 (floating-point constructor arg)
+  val = Json::Value((1 << 20) / 1.0);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((1 << 20), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1048576",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // -2^20
+  val = Json::Value(-(1 << 20));
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(-(1 << 20), val.asInt());
+  JSONTEST_ASSERT_EQUAL(-(1 << 20), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(-(1 << 20), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(-(1 << 20), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-1048576", val.asString());
+
+  // int32 max
+  val = Json::Value(kint32max);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kint32max, val.asInt());
+  JSONTEST_ASSERT_EQUAL(kint32max, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(kint32max, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(kint32max, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(kint32max, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(kfint32max, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("2147483647", val.asString());
+
+  // int32 min
+  val = Json::Value(kint32min);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt_ = true;
+  checks.isInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kint32min, val.asInt());
+  JSONTEST_ASSERT_EQUAL(kint32min, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(kint32min, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(kint32min, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-2147483648", val.asString());
+
+  // uint32 max
+  val = Json::Value(kuint32max);
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isUInt_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+
+#ifndef JSON_NO_INT64
+  JSONTEST_ASSERT_EQUAL(kuint32max, val.asLargestInt());
+#endif
+  JSONTEST_ASSERT_EQUAL(kuint32max, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(kuint32max, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(kuint32max, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(kfuint32max, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("4294967295", val.asString());
+
+#ifdef JSON_NO_INT64
+  // int64 max
+  val = Json::Value(double(kint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(double(kint64max), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(kint64max), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("9.22337e+18", val.asString());
+
+  // int64 min
+  val = Json::Value(double(kint64min));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(double(kint64min), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(kint64min), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-9.22337e+18", val.asString());
+
+  // uint64 max
+  val = Json::Value(double(kuint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(double(kuint64max), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(kuint64max), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1.84467e+19", val.asString());
+#else // ifdef JSON_NO_INT64
+  // 2^40 (signed constructor arg)
+  val = Json::Value(Json::Int64(1) << 40);
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asUInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1099511627776", val.asString());
+
+  // 2^40 (unsigned constructor arg)
+  val = Json::Value(Json::UInt64(1) << 40);
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asUInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1099511627776", val.asString());
+
+  // 2^40 (floating-point constructor arg)
+  val = Json::Value((Json::Int64(1) << 40) / 1.0);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asUInt64());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asDouble());
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1099511627776",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // -2^40
+  val = Json::Value(-(Json::Int64(1) << 40));
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 40), val.asInt64());
+  JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 40), val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 40), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 40), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-1099511627776", val.asString());
+
+  // int64 max
+  val = Json::Value(Json::Int64(kint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kint64max, val.asInt64());
+  JSONTEST_ASSERT_EQUAL(kint64max, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(kint64max, val.asUInt64());
+  JSONTEST_ASSERT_EQUAL(kint64max, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(double(kint64max), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(kint64max), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("9223372036854775807", val.asString());
+
+  // int64 max (floating point constructor). Note that kint64max is not exactly
+  // representable as a double, and will be rounded up to be higher.
+  val = Json::Value(double(kint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(Json::UInt64(1) << 63, val.asUInt64());
+  JSONTEST_ASSERT_EQUAL(Json::UInt64(1) << 63, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(uint64ToDouble(Json::UInt64(1) << 63), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(uint64ToDouble(Json::UInt64(1) << 63)),
+                        val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("9.2233720368547758e+18",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // int64 min
+  val = Json::Value(Json::Int64(kint64min));
+
+  JSONTEST_ASSERT_EQUAL(Json::intValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kint64min, val.asInt64());
+  JSONTEST_ASSERT_EQUAL(kint64min, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(double(kint64min), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(kint64min), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-9223372036854775808", val.asString());
+
+  // int64 min (floating point constructor). Note that kint64min *is* exactly
+  // representable as a double.
+  val = Json::Value(double(kint64min));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kint64min, val.asInt64());
+  JSONTEST_ASSERT_EQUAL(kint64min, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(-9223372036854775808.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(-9223372036854775808.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("-9.2233720368547758e+18",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // 10^19
+  const Json::UInt64 ten_to_19 = static_cast<Json::UInt64>(1e19);
+  val = Json::Value(Json::UInt64(ten_to_19));
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(ten_to_19, val.asUInt64());
+  JSONTEST_ASSERT_EQUAL(ten_to_19, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(uint64ToDouble(ten_to_19), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(uint64ToDouble(ten_to_19)), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("10000000000000000000", val.asString());
+
+  // 10^19 (double constructor). Note that 10^19 is not exactly representable
+  // as a double.
+  val = Json::Value(uint64ToDouble(ten_to_19));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(1e19, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(1e19, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1e+19",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // uint64 max
+  val = Json::Value(Json::UInt64(kuint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
+
+  checks = IsCheck();
+  checks.isUInt64_ = true;
+  checks.isIntegral_ = true;
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(kuint64max, val.asUInt64());
+  JSONTEST_ASSERT_EQUAL(kuint64max, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(uint64ToDouble(kuint64max), val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(uint64ToDouble(kuint64max)), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("18446744073709551615", val.asString());
+
+  // uint64 max (floating point constructor). Note that kuint64max is not
+  // exactly representable as a double, and will be rounded up to be higher.
+  val = Json::Value(uint64ToDouble(kuint64max));
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+
+  JSONTEST_ASSERT_EQUAL(18446744073709551616.0, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(18446744073709551616.0, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_STRING_EQUAL("1.8446744073709552e+19",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+#endif
+}
+
+JSONTEST_FIXTURE(ValueTest, nonIntegers) {
+  IsCheck checks;
+  Json::Value val;
+
+  // Small positive number
+  val = Json::Value(1.5);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(1.5, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(1.5, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(1, val.asInt());
+  JSONTEST_ASSERT_EQUAL(1, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(1, val.asUInt());
+  JSONTEST_ASSERT_EQUAL(1, val.asLargestUInt());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_EQUAL("1.5", val.asString());
+
+  // Small negative number
+  val = Json::Value(-1.5);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(-1.5, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(-1.5, val.asFloat());
+  JSONTEST_ASSERT_EQUAL(-1, val.asInt());
+  JSONTEST_ASSERT_EQUAL(-1, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_EQUAL("-1.5", val.asString());
+
+  // A bit over int32 max
+  val = Json::Value(kint32max + 0.5);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(2147483647.5, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(2147483647.5), val.asFloat());
+  JSONTEST_ASSERT_EQUAL(2147483647U, val.asUInt());
+#ifdef JSON_HAS_INT64
+  JSONTEST_ASSERT_EQUAL(2147483647L, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL(2147483647U, val.asLargestUInt());
+#endif
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_EQUAL("2147483647.5",
+                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // A bit under int32 min
+  val = Json::Value(kint32min - 0.5);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(-2147483648.5, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(-2147483648.5), val.asFloat());
+#ifdef JSON_HAS_INT64
+  JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 31), val.asLargestInt());
+#endif
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_EQUAL("-2147483648.5",
+                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // A bit over uint32 max
+  val = Json::Value(kuint32max + 0.5);
+
+  JSONTEST_ASSERT_EQUAL(Json::realValue, val.type());
+
+  checks = IsCheck();
+  checks.isDouble_ = true;
+  checks.isNumeric_ = true;
+  JSONTEST_ASSERT_PRED(checkIs(val, checks));
+
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::realValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::booleanValue));
+  JSONTEST_ASSERT(val.isConvertibleTo(Json::stringValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::nullValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::intValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::uintValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::arrayValue));
+  JSONTEST_ASSERT(!val.isConvertibleTo(Json::objectValue));
+
+  JSONTEST_ASSERT_EQUAL(4294967295.5, val.asDouble());
+  JSONTEST_ASSERT_EQUAL(float(4294967295.5), val.asFloat());
+#ifdef JSON_HAS_INT64
+  JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 32) - 1, val.asLargestInt());
+  JSONTEST_ASSERT_EQUAL((Json::UInt64(1) << 32) - Json::UInt64(1),
+                        val.asLargestUInt());
+#endif
+  JSONTEST_ASSERT_EQUAL(true, val.asBool());
+  JSONTEST_ASSERT_EQUAL("4294967295.5",
+                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  val = Json::Value(1.2345678901234);
+  JSONTEST_ASSERT_STRING_EQUAL("1.2345678901234001",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // A 16-digit floating point number.
+  val = Json::Value(2199023255552000.0f);
+  JSONTEST_ASSERT_EQUAL(float(2199023255552000.0f), val.asFloat());
+  JSONTEST_ASSERT_STRING_EQUAL("2199023255552000",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // A very large floating point number.
+  val = Json::Value(3.402823466385289e38);
+  JSONTEST_ASSERT_EQUAL(float(3.402823466385289e38), val.asFloat());
+  JSONTEST_ASSERT_STRING_EQUAL("3.402823466385289e+38",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+
+  // An even larger floating point number.
+  val = Json::Value(1.2345678e300);
+  JSONTEST_ASSERT_EQUAL(double(1.2345678e300), val.asDouble());
+  JSONTEST_ASSERT_STRING_EQUAL("1.2345678e+300",
+                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+}
+
+void ValueTest::checkConstMemberCount(const Json::Value& value,
+                                      unsigned int expectedCount) {
+  unsigned int count = 0;
+  Json::Value::const_iterator itEnd = value.end();
+  for (Json::Value::const_iterator it = value.begin(); it != itEnd; ++it) {
+    ++count;
+  }
+  JSONTEST_ASSERT_EQUAL(expectedCount, count) << "Json::Value::const_iterator";
+}
+
+void ValueTest::checkMemberCount(Json::Value& value,
+                                 unsigned int expectedCount) {
+  JSONTEST_ASSERT_EQUAL(expectedCount, value.size());
+
+  unsigned int count = 0;
+  Json::Value::iterator itEnd = value.end();
+  for (Json::Value::iterator it = value.begin(); it != itEnd; ++it) {
+    ++count;
+  }
+  JSONTEST_ASSERT_EQUAL(expectedCount, count) << "Json::Value::iterator";
+
+  JSONTEST_ASSERT_PRED(checkConstMemberCount(value, expectedCount));
+}
+
+ValueTest::IsCheck::IsCheck()
+    : isObject_(false), isArray_(false), isBool_(false), isString_(false),
+      isNull_(false), isInt_(false), isInt64_(false), isUInt_(false),
+      isUInt64_(false), isIntegral_(false), isDouble_(false),
+      isNumeric_(false) {}
+
+void ValueTest::checkIs(const Json::Value& value, const IsCheck& check) {
+  JSONTEST_ASSERT_EQUAL(check.isObject_, value.isObject());
+  JSONTEST_ASSERT_EQUAL(check.isArray_, value.isArray());
+  JSONTEST_ASSERT_EQUAL(check.isBool_, value.isBool());
+  JSONTEST_ASSERT_EQUAL(check.isDouble_, value.isDouble());
+  JSONTEST_ASSERT_EQUAL(check.isInt_, value.isInt());
+  JSONTEST_ASSERT_EQUAL(check.isUInt_, value.isUInt());
+  JSONTEST_ASSERT_EQUAL(check.isIntegral_, value.isIntegral());
+  JSONTEST_ASSERT_EQUAL(check.isNumeric_, value.isNumeric());
+  JSONTEST_ASSERT_EQUAL(check.isString_, value.isString());
+  JSONTEST_ASSERT_EQUAL(check.isNull_, value.isNull());
+
+#ifdef JSON_HAS_INT64
+  JSONTEST_ASSERT_EQUAL(check.isInt64_, value.isInt64());
+  JSONTEST_ASSERT_EQUAL(check.isUInt64_, value.isUInt64());
+#else
+  JSONTEST_ASSERT_EQUAL(false, value.isInt64());
+  JSONTEST_ASSERT_EQUAL(false, value.isUInt64());
+#endif
+}
+
+JSONTEST_FIXTURE(ValueTest, compareNull) {
+  JSONTEST_ASSERT_PRED(checkIsEqual(Json::Value(), Json::Value()));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareInt) {
+  JSONTEST_ASSERT_PRED(checkIsLess(0, 10));
+  JSONTEST_ASSERT_PRED(checkIsEqual(10, 10));
+  JSONTEST_ASSERT_PRED(checkIsEqual(-10, -10));
+  JSONTEST_ASSERT_PRED(checkIsLess(-10, 0));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareUInt) {
+  JSONTEST_ASSERT_PRED(checkIsLess(0u, 10u));
+  JSONTEST_ASSERT_PRED(checkIsLess(0u, Json::Value::maxUInt));
+  JSONTEST_ASSERT_PRED(checkIsEqual(10u, 10u));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareDouble) {
+  JSONTEST_ASSERT_PRED(checkIsLess(0.0, 10.0));
+  JSONTEST_ASSERT_PRED(checkIsEqual(10.0, 10.0));
+  JSONTEST_ASSERT_PRED(checkIsEqual(-10.0, -10.0));
+  JSONTEST_ASSERT_PRED(checkIsLess(-10.0, 0.0));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareString) {
+  JSONTEST_ASSERT_PRED(checkIsLess("", " "));
+  JSONTEST_ASSERT_PRED(checkIsLess("", "a"));
+  JSONTEST_ASSERT_PRED(checkIsLess("abcd", "zyui"));
+  JSONTEST_ASSERT_PRED(checkIsLess("abc", "abcd"));
+  JSONTEST_ASSERT_PRED(checkIsEqual("abcd", "abcd"));
+  JSONTEST_ASSERT_PRED(checkIsEqual(" ", " "));
+  JSONTEST_ASSERT_PRED(checkIsLess("ABCD", "abcd"));
+  JSONTEST_ASSERT_PRED(checkIsEqual("ABCD", "ABCD"));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareBoolean) {
+  JSONTEST_ASSERT_PRED(checkIsLess(false, true));
+  JSONTEST_ASSERT_PRED(checkIsEqual(false, false));
+  JSONTEST_ASSERT_PRED(checkIsEqual(true, true));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareArray) {
+  // array compare size then content
+  Json::Value emptyArray(Json::arrayValue);
+  Json::Value l1aArray;
+  l1aArray.append(0);
+  Json::Value l1bArray;
+  l1bArray.append(10);
+  Json::Value l2aArray;
+  l2aArray.append(0);
+  l2aArray.append(0);
+  Json::Value l2bArray;
+  l2bArray.append(0);
+  l2bArray.append(10);
+  JSONTEST_ASSERT_PRED(checkIsLess(emptyArray, l1aArray));
+  JSONTEST_ASSERT_PRED(checkIsLess(emptyArray, l2aArray));
+  JSONTEST_ASSERT_PRED(checkIsLess(l1aArray, l2aArray));
+  JSONTEST_ASSERT_PRED(checkIsLess(l2aArray, l2bArray));
+  JSONTEST_ASSERT_PRED(checkIsEqual(emptyArray, Json::Value(emptyArray)));
+  JSONTEST_ASSERT_PRED(checkIsEqual(l1aArray, Json::Value(l1aArray)));
+  JSONTEST_ASSERT_PRED(checkIsEqual(l2bArray, Json::Value(l2bArray)));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareObject) {
+  // object compare size then content
+  Json::Value emptyObject(Json::objectValue);
+  Json::Value l1aObject;
+  l1aObject["key1"] = 0;
+  Json::Value l1bObject;
+  l1aObject["key1"] = 10;
+  Json::Value l2aObject;
+  l2aObject["key1"] = 0;
+  l2aObject["key2"] = 0;
+  JSONTEST_ASSERT_PRED(checkIsLess(emptyObject, l1aObject));
+  JSONTEST_ASSERT_PRED(checkIsLess(emptyObject, l2aObject));
+  JSONTEST_ASSERT_PRED(checkIsLess(l1aObject, l2aObject));
+  JSONTEST_ASSERT_PRED(checkIsEqual(emptyObject, Json::Value(emptyObject)));
+  JSONTEST_ASSERT_PRED(checkIsEqual(l1aObject, Json::Value(l1aObject)));
+  JSONTEST_ASSERT_PRED(checkIsEqual(l2aObject, Json::Value(l2aObject)));
+}
+
+JSONTEST_FIXTURE(ValueTest, compareType) {
+  // object of different type are ordered according to their type
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value(), Json::Value(1)));
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value(1), Json::Value(1u)));
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value(1u), Json::Value(1.0)));
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value(1.0), Json::Value("a")));
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value("a"), Json::Value(true)));
+  JSONTEST_ASSERT_PRED(
+      checkIsLess(Json::Value(true), Json::Value(Json::arrayValue)));
+  JSONTEST_ASSERT_PRED(checkIsLess(Json::Value(Json::arrayValue),
+                                   Json::Value(Json::objectValue)));
+}
+
+void ValueTest::checkIsLess(const Json::Value& x, const Json::Value& y) {
+  JSONTEST_ASSERT(x < y);
+  JSONTEST_ASSERT(y > x);
+  JSONTEST_ASSERT(x <= y);
+  JSONTEST_ASSERT(y >= x);
+  JSONTEST_ASSERT(!(x == y));
+  JSONTEST_ASSERT(!(y == x));
+  JSONTEST_ASSERT(!(x >= y));
+  JSONTEST_ASSERT(!(y <= x));
+  JSONTEST_ASSERT(!(x > y));
+  JSONTEST_ASSERT(!(y < x));
+  JSONTEST_ASSERT(x.compare(y) < 0);
+  JSONTEST_ASSERT(y.compare(x) >= 0);
+}
+
+void ValueTest::checkIsEqual(const Json::Value& x, const Json::Value& y) {
+  JSONTEST_ASSERT(x == y);
+  JSONTEST_ASSERT(y == x);
+  JSONTEST_ASSERT(x <= y);
+  JSONTEST_ASSERT(y <= x);
+  JSONTEST_ASSERT(x >= y);
+  JSONTEST_ASSERT(y >= x);
+  JSONTEST_ASSERT(!(x < y));
+  JSONTEST_ASSERT(!(y < x));
+  JSONTEST_ASSERT(!(x > y));
+  JSONTEST_ASSERT(!(y > x));
+  JSONTEST_ASSERT(x.compare(y) == 0);
+  JSONTEST_ASSERT(y.compare(x) == 0);
+}
+
+JSONTEST_FIXTURE(ValueTest, typeChecksThrowExceptions) {
+#if JSON_USE_EXCEPTION
+
+  Json::Value intVal(1);
+  Json::Value strVal("Test");
+  Json::Value objVal(Json::objectValue);
+  Json::Value arrVal(Json::arrayValue);
+
+  JSONTEST_ASSERT_THROWS(intVal["test"]);
+  JSONTEST_ASSERT_THROWS(strVal["test"]);
+  JSONTEST_ASSERT_THROWS(arrVal["test"]);
+
+  JSONTEST_ASSERT_THROWS(intVal.removeMember("test"));
+  JSONTEST_ASSERT_THROWS(strVal.removeMember("test"));
+  JSONTEST_ASSERT_THROWS(arrVal.removeMember("test"));
+
+  JSONTEST_ASSERT_THROWS(intVal.getMemberNames());
+  JSONTEST_ASSERT_THROWS(strVal.getMemberNames());
+  JSONTEST_ASSERT_THROWS(arrVal.getMemberNames());
+
+  JSONTEST_ASSERT_THROWS(intVal[0]);
+  JSONTEST_ASSERT_THROWS(objVal[0]);
+  JSONTEST_ASSERT_THROWS(strVal[0]);
+
+  JSONTEST_ASSERT_THROWS(intVal.clear());
+
+  JSONTEST_ASSERT_THROWS(intVal.resize(1));
+  JSONTEST_ASSERT_THROWS(strVal.resize(1));
+  JSONTEST_ASSERT_THROWS(objVal.resize(1));
+
+  JSONTEST_ASSERT_THROWS(intVal.asCString());
+
+  JSONTEST_ASSERT_THROWS(objVal.asString());
+  JSONTEST_ASSERT_THROWS(arrVal.asString());
+
+  JSONTEST_ASSERT_THROWS(strVal.asInt());
+  JSONTEST_ASSERT_THROWS(objVal.asInt());
+  JSONTEST_ASSERT_THROWS(arrVal.asInt());
+
+  JSONTEST_ASSERT_THROWS(strVal.asUInt());
+  JSONTEST_ASSERT_THROWS(objVal.asUInt());
+  JSONTEST_ASSERT_THROWS(arrVal.asUInt());
+
+  JSONTEST_ASSERT_THROWS(strVal.asInt64());
+  JSONTEST_ASSERT_THROWS(objVal.asInt64());
+  JSONTEST_ASSERT_THROWS(arrVal.asInt64());
+
+  JSONTEST_ASSERT_THROWS(strVal.asUInt64());
+  JSONTEST_ASSERT_THROWS(objVal.asUInt64());
+  JSONTEST_ASSERT_THROWS(arrVal.asUInt64());
+
+  JSONTEST_ASSERT_THROWS(strVal.asDouble());
+  JSONTEST_ASSERT_THROWS(objVal.asDouble());
+  JSONTEST_ASSERT_THROWS(arrVal.asDouble());
+
+  JSONTEST_ASSERT_THROWS(strVal.asFloat());
+  JSONTEST_ASSERT_THROWS(objVal.asFloat());
+  JSONTEST_ASSERT_THROWS(arrVal.asFloat());
+
+  JSONTEST_ASSERT_THROWS(strVal.asBool());
+  JSONTEST_ASSERT_THROWS(objVal.asBool());
+  JSONTEST_ASSERT_THROWS(arrVal.asBool());
+
+#endif
+}
+
+JSONTEST_FIXTURE(ValueTest, offsetAccessors) {
+  Json::Value x;
+  JSONTEST_ASSERT(x.getOffsetStart() == 0);
+  JSONTEST_ASSERT(x.getOffsetLimit() == 0);
+  x.setOffsetStart(10);
+  x.setOffsetLimit(20);
+  JSONTEST_ASSERT(x.getOffsetStart() == 10);
+  JSONTEST_ASSERT(x.getOffsetLimit() == 20);
+  Json::Value y(x);
+  JSONTEST_ASSERT(y.getOffsetStart() == 10);
+  JSONTEST_ASSERT(y.getOffsetLimit() == 20);
+  Json::Value z;
+  z.swap(y);
+  JSONTEST_ASSERT(z.getOffsetStart() == 10);
+  JSONTEST_ASSERT(z.getOffsetLimit() == 20);
+  JSONTEST_ASSERT(y.getOffsetStart() == 0);
+  JSONTEST_ASSERT(y.getOffsetLimit() == 0);
+}
+
+JSONTEST_FIXTURE(ValueTest, StaticString) {
+  char mutant[] = "hello";
+  Json::StaticString ss(mutant);
+  JSONCPP_STRING regular(mutant);
+  mutant[1] = 'a';
+  JSONTEST_ASSERT_STRING_EQUAL("hallo", ss.c_str());
+  JSONTEST_ASSERT_STRING_EQUAL("hello", regular.c_str());
+  {
+    Json::Value root;
+    root["top"] = ss;
+    JSONTEST_ASSERT_STRING_EQUAL("hallo", root["top"].asString());
+    mutant[1] = 'u';
+    JSONTEST_ASSERT_STRING_EQUAL("hullo", root["top"].asString());
+  }
+  {
+    Json::Value root;
+    root["top"] = regular;
+    JSONTEST_ASSERT_STRING_EQUAL("hello", root["top"].asString());
+    mutant[1] = 'u';
+    JSONTEST_ASSERT_STRING_EQUAL("hello", root["top"].asString());
+  }
+}
+
+JSONTEST_FIXTURE(ValueTest, CommentBefore) {
+  Json::Value val; // fill val
+  val.setComment(JSONCPP_STRING("// this comment should appear before"), Json::commentBefore);
+  Json::StreamWriterBuilder wbuilder;
+  wbuilder.settings_["commentStyle"] = "All";
+  {
+    char const expected[] = "// this comment should appear before\nnull";
+    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+    JSONCPP_STRING res2 = val.toStyledString();
+    JSONCPP_STRING exp2 = "\n";
+    exp2 += expected;
+    exp2 += "\n";
+    JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
+  }
+  Json::Value other = "hello";
+  val.swapPayload(other);
+  {
+    char const expected[] = "// this comment should appear before\n\"hello\"";
+    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+    JSONCPP_STRING res2 = val.toStyledString();
+    JSONCPP_STRING exp2 = "\n";
+    exp2 += expected;
+    exp2 += "\n";
+    JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
+    JSONTEST_ASSERT_STRING_EQUAL("null\n", other.toStyledString());
+  }
+  val = "hello";
+  // val.setComment("// this comment should appear before", Json::CommentPlacement::commentBefore);
+  // Assignment over-writes comments.
+  {
+    char const expected[] = "\"hello\"";
+    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+    JSONCPP_STRING res2 = val.toStyledString();
+    JSONCPP_STRING exp2 = "";
+    exp2 += expected;
+    exp2 += "\n";
+    JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
+  }
+}
+
+JSONTEST_FIXTURE(ValueTest, zeroes) {
+  char const cstr[] = "h\0i";
+  JSONCPP_STRING binary(cstr, sizeof(cstr));  // include trailing 0
+  JSONTEST_ASSERT_EQUAL(4U, binary.length());
+  Json::StreamWriterBuilder b;
+  {
+    Json::Value root;
+    root = binary;
+    JSONTEST_ASSERT_STRING_EQUAL(binary, root.asString());
+  }
+  {
+    char const top[] = "top";
+    Json::Value root;
+    root[top] = binary;
+    JSONTEST_ASSERT_STRING_EQUAL(binary, root[top].asString());
+    Json::Value removed;
+    bool did;
+    did = root.removeMember(top, top + sizeof(top) - 1U,
+        &removed);
+    JSONTEST_ASSERT(did);
+    JSONTEST_ASSERT_STRING_EQUAL(binary, removed.asString());
+    did = root.removeMember(top, top + sizeof(top) - 1U,
+        &removed);
+    JSONTEST_ASSERT(!did);
+    JSONTEST_ASSERT_STRING_EQUAL(binary, removed.asString()); // still
+  }
+}
+
+JSONTEST_FIXTURE(ValueTest, zeroesInKeys) {
+  char const cstr[] = "h\0i";
+  JSONCPP_STRING binary(cstr, sizeof(cstr));  // include trailing 0
+  JSONTEST_ASSERT_EQUAL(4U, binary.length());
+  {
+    Json::Value root;
+    root[binary] = "there";
+    JSONTEST_ASSERT_STRING_EQUAL("there", root[binary].asString());
+    JSONTEST_ASSERT(!root.isMember("h"));
+    JSONTEST_ASSERT(root.isMember(binary));
+    JSONTEST_ASSERT_STRING_EQUAL("there", root.get(binary, Json::Value::nullRef).asString());
+    Json::Value removed;
+    bool did;
+    did = root.removeMember(binary.data(), binary.data() + binary.length(),
+        &removed);
+    JSONTEST_ASSERT(did);
+    JSONTEST_ASSERT_STRING_EQUAL("there", removed.asString());
+    did = root.removeMember(binary.data(), binary.data() + binary.length(),
+        &removed);
+    JSONTEST_ASSERT(!did);
+    JSONTEST_ASSERT_STRING_EQUAL("there", removed.asString()); // still
+    JSONTEST_ASSERT(!root.isMember(binary));
+    JSONTEST_ASSERT_STRING_EQUAL("", root.get(binary, Json::Value::nullRef).asString());
+  }
+}
+
+JSONTEST_FIXTURE(ValueTest, specialFloats) {
+  Json::StreamWriterBuilder b;
+  b.settings_["useSpecialFloats"] = true;
+
+  Json::Value v = std::numeric_limits<double>::quiet_NaN();
+  JSONCPP_STRING expected = "NaN";
+  JSONCPP_STRING result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  v = std::numeric_limits<double>::infinity();
+  expected = "Infinity";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  v = -std::numeric_limits<double>::infinity();
+  expected = "-Infinity";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+}
+
+JSONTEST_FIXTURE(ValueTest, precision) {
+    Json::StreamWriterBuilder b;
+    b.settings_["precision"] = 5;
+
+    Json::Value v = 100.0/3;
+    JSONCPP_STRING expected = "33.333";
+    JSONCPP_STRING result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+    
+    v = 0.25000000;
+    expected = "0.25";
+    result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+    v = 0.2563456;
+    expected = "0.25635";
+    result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+    b.settings_["precision"] = 1;
+    expected = "0.3";
+    result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+    b.settings_["precision"] = 17;
+    v = 1234857476305.256345694873740545068;
+    expected = "1234857476305.2563";
+    result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+    b.settings_["precision"] = 24;
+    v = 0.256345694873740545068;
+    expected = "0.25634569487374054";
+    result = Json::writeString(b, v);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+}
+
+struct WriterTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(WriterTest, dropNullPlaceholders) {
+  Json::FastWriter writer;
+  Json::Value nullValue;
+  JSONTEST_ASSERT(writer.write(nullValue) == "null\n");
+
+  writer.dropNullPlaceholders();
+  JSONTEST_ASSERT(writer.write(nullValue) == "\n");
+}
+
+struct StreamWriterTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(StreamWriterTest, dropNullPlaceholders) {
+  Json::StreamWriterBuilder b;
+  Json::Value nullValue;
+  b.settings_["dropNullPlaceholders"] = false;
+  JSONTEST_ASSERT(Json::writeString(b, nullValue) == "null");
+  b.settings_["dropNullPlaceholders"] = true;
+  JSONTEST_ASSERT(Json::writeString(b, nullValue) == "");
+}
+
+JSONTEST_FIXTURE(StreamWriterTest, writeZeroes) {
+  JSONCPP_STRING binary("hi", 3);  // include trailing 0
+  JSONTEST_ASSERT_EQUAL(3, binary.length());
+  JSONCPP_STRING expected("\"hi\\u0000\"");  // unicoded zero
+  Json::StreamWriterBuilder b;
+  {
+    Json::Value root;
+    root = binary;
+    JSONTEST_ASSERT_STRING_EQUAL(binary, root.asString());
+    JSONCPP_STRING out = Json::writeString(b, root);
+    JSONTEST_ASSERT_EQUAL(expected.size(), out.size());
+    JSONTEST_ASSERT_STRING_EQUAL(expected, out);
+  }
+  {
+    Json::Value root;
+    root["top"] = binary;
+    JSONTEST_ASSERT_STRING_EQUAL(binary, root["top"].asString());
+    JSONCPP_STRING out = Json::writeString(b, root["top"]);
+    JSONTEST_ASSERT_STRING_EQUAL(expected, out);
+  }
+}
+
+struct ReaderTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(ReaderTest, parseWithNoErrors) {
+  Json::Reader reader;
+  Json::Value root;
+  bool ok = reader.parse("{ \"property\" : \"value\" }", root);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages().size() == 0);
+  JSONTEST_ASSERT(reader.getStructuredErrors().size() == 0);
+}
+
+JSONTEST_FIXTURE(ReaderTest, parseWithNoErrorsTestingOffsets) {
+  Json::Reader reader;
+  Json::Value root;
+  bool ok = reader.parse("{ \"property\" : [\"value\", \"value2\"], \"obj\" : "
+                         "{ \"nested\" : 123, \"bool\" : true}, \"null\" : "
+                         "null, \"false\" : false }",
+                         root);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages().size() == 0);
+  JSONTEST_ASSERT(reader.getStructuredErrors().size() == 0);
+  JSONTEST_ASSERT(root["property"].getOffsetStart() == 15);
+  JSONTEST_ASSERT(root["property"].getOffsetLimit() == 34);
+  JSONTEST_ASSERT(root["property"][0].getOffsetStart() == 16);
+  JSONTEST_ASSERT(root["property"][0].getOffsetLimit() == 23);
+  JSONTEST_ASSERT(root["property"][1].getOffsetStart() == 25);
+  JSONTEST_ASSERT(root["property"][1].getOffsetLimit() == 33);
+  JSONTEST_ASSERT(root["obj"].getOffsetStart() == 44);
+  JSONTEST_ASSERT(root["obj"].getOffsetLimit() == 76);
+  JSONTEST_ASSERT(root["obj"]["nested"].getOffsetStart() == 57);
+  JSONTEST_ASSERT(root["obj"]["nested"].getOffsetLimit() == 60);
+  JSONTEST_ASSERT(root["obj"]["bool"].getOffsetStart() == 71);
+  JSONTEST_ASSERT(root["obj"]["bool"].getOffsetLimit() == 75);
+  JSONTEST_ASSERT(root["null"].getOffsetStart() == 87);
+  JSONTEST_ASSERT(root["null"].getOffsetLimit() == 91);
+  JSONTEST_ASSERT(root["false"].getOffsetStart() == 103);
+  JSONTEST_ASSERT(root["false"].getOffsetLimit() == 108);
+  JSONTEST_ASSERT(root.getOffsetStart() == 0);
+  JSONTEST_ASSERT(root.getOffsetLimit() == 110);
+}
+
+JSONTEST_FIXTURE(ReaderTest, parseWithOneError) {
+  Json::Reader reader;
+  Json::Value root;
+  bool ok = reader.parse("{ \"property\" :: \"value\" }", root);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages() ==
+                  "* Line 1, Column 15\n  Syntax error: value, object or array "
+                  "expected.\n");
+  std::vector<Json::Reader::StructuredError> errors =
+      reader.getStructuredErrors();
+  JSONTEST_ASSERT(errors.size() == 1);
+  JSONTEST_ASSERT(errors.at(0).offset_start == 14);
+  JSONTEST_ASSERT(errors.at(0).offset_limit == 15);
+  JSONTEST_ASSERT(errors.at(0).message ==
+                  "Syntax error: value, object or array expected.");
+}
+
+JSONTEST_FIXTURE(ReaderTest, parseChineseWithOneError) {
+  Json::Reader reader;
+  Json::Value root;
+  bool ok = reader.parse("{ \"prä½è¤erty\" :: \"value\" }", root);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages() ==
+                  "* Line 1, Column 19\n  Syntax error: value, object or array "
+                  "expected.\n");
+  std::vector<Json::Reader::StructuredError> errors =
+      reader.getStructuredErrors();
+  JSONTEST_ASSERT(errors.size() == 1);
+  JSONTEST_ASSERT(errors.at(0).offset_start == 18);
+  JSONTEST_ASSERT(errors.at(0).offset_limit == 19);
+  JSONTEST_ASSERT(errors.at(0).message ==
+                  "Syntax error: value, object or array expected.");
+}
+
+JSONTEST_FIXTURE(ReaderTest, parseWithDetailError) {
+  Json::Reader reader;
+  Json::Value root;
+  bool ok = reader.parse("{ \"property\" : \"v\\alue\" }", root);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages() ==
+                  "* Line 1, Column 16\n  Bad escape sequence in string\nSee "
+                  "Line 1, Column 20 for detail.\n");
+  std::vector<Json::Reader::StructuredError> errors =
+      reader.getStructuredErrors();
+  JSONTEST_ASSERT(errors.size() == 1);
+  JSONTEST_ASSERT(errors.at(0).offset_start == 15);
+  JSONTEST_ASSERT(errors.at(0).offset_limit == 23);
+  JSONTEST_ASSERT(errors.at(0).message == "Bad escape sequence in string");
+}
+
+struct CharReaderTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderTest, parseWithNoErrors) {
+  Json::CharReaderBuilder b;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  Json::Value root;
+  char const doc[] = "{ \"property\" : \"value\" }";
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(errs.size() == 0);
+  delete reader;
+}
+
+JSONTEST_FIXTURE(CharReaderTest, parseWithNoErrorsTestingOffsets) {
+  Json::CharReaderBuilder b;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  Json::Value root;
+  char const doc[] =
+                         "{ \"property\" : [\"value\", \"value2\"], \"obj\" : "
+                         "{ \"nested\" : 123, \"bool\" : true}, \"null\" : "
+                         "null, \"false\" : false }";
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(errs.size() == 0);
+  delete reader;
+}
+
+JSONTEST_FIXTURE(CharReaderTest, parseWithOneError) {
+  Json::CharReaderBuilder b;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  Json::Value root;
+  char const doc[] =
+      "{ \"property\" :: \"value\" }";
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(errs ==
+                  "* Line 1, Column 15\n  Syntax error: value, object or array "
+                  "expected.\n");
+  delete reader;
+}
+
+JSONTEST_FIXTURE(CharReaderTest, parseChineseWithOneError) {
+  Json::CharReaderBuilder b;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  Json::Value root;
+  char const doc[] =
+      "{ \"prä½è¤erty\" :: \"value\" }";
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(errs ==
+                  "* Line 1, Column 19\n  Syntax error: value, object or array "
+                  "expected.\n");
+  delete reader;
+}
+
+JSONTEST_FIXTURE(CharReaderTest, parseWithDetailError) {
+  Json::CharReaderBuilder b;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  Json::Value root;
+  char const doc[] =
+      "{ \"property\" : \"v\\alue\" }";
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT(errs ==
+                  "* Line 1, Column 16\n  Bad escape sequence in string\nSee "
+                  "Line 1, Column 20 for detail.\n");
+  delete reader;
+}
+
+JSONTEST_FIXTURE(CharReaderTest, parseWithStackLimit) {
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      "{ \"property\" : \"value\" }";
+  {
+  b.settings_["stackLimit"] = 2;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(errs == "");
+  JSONTEST_ASSERT_EQUAL("value", root["property"]);
+  delete reader;
+  }
+  {
+  b.settings_["stackLimit"] = 1;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  JSONTEST_ASSERT_THROWS(reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs));
+  delete reader;
+  }
+}
+
+struct CharReaderStrictModeTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderStrictModeTest, dupKeys) {
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      "{ \"property\" : \"value\", \"key\" : \"val1\", \"key\" : \"val2\" }";
+  {
+    b.strictMode(&b.settings_);
+    Json::CharReader* reader(b.newCharReader());
+    JSONCPP_STRING errs;
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(!ok);
+    JSONTEST_ASSERT_STRING_EQUAL(
+        "* Line 1, Column 41\n"
+        "  Duplicate key: 'key'\n",
+        errs);
+    JSONTEST_ASSERT_EQUAL("val1", root["key"]); // so far
+    delete reader;
+  }
+}
+struct CharReaderFailIfExtraTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderFailIfExtraTest, issue164) {
+  // This is interpreted as a string value followed by a colon.
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      " \"property\" : \"value\" }";
+  {
+  b.settings_["failIfExtra"] = false;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT(errs == "");
+  JSONTEST_ASSERT_EQUAL("property", root);
+  delete reader;
+  }
+  {
+  b.settings_["failIfExtra"] = true;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT_STRING_EQUAL(errs,
+      "* Line 1, Column 13\n"
+      "  Extra non-whitespace after JSON value.\n");
+  JSONTEST_ASSERT_EQUAL("property", root);
+  delete reader;
+  }
+  {
+  b.settings_["failIfExtra"] = false;
+  b.strictMode(&b.settings_);
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT_STRING_EQUAL(errs,
+      "* Line 1, Column 13\n"
+      "  Extra non-whitespace after JSON value.\n");
+  JSONTEST_ASSERT_EQUAL("property", root);
+  delete reader;
+  }
+}
+JSONTEST_FIXTURE(CharReaderFailIfExtraTest, issue107) {
+  // This is interpretted as an int value followed by a colon.
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      "1:2:3";
+  b.settings_["failIfExtra"] = true;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(!ok);
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "* Line 1, Column 2\n"
+      "  Extra non-whitespace after JSON value.\n",
+      errs);
+  JSONTEST_ASSERT_EQUAL(1, root.asInt());
+  delete reader;
+}
+JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterObject) {
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  {
+  char const doc[] =
+      "{ \"property\" : \"value\" } //trailing\n//comment\n";
+  b.settings_["failIfExtra"] = true;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT_STRING_EQUAL("", errs);
+  JSONTEST_ASSERT_EQUAL("value", root["property"]);
+  delete reader;
+  }
+}
+JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterArray) {
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      "[ \"property\" , \"value\" ] //trailing\n//comment\n";
+  b.settings_["failIfExtra"] = true;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT_STRING_EQUAL("", errs);
+  JSONTEST_ASSERT_EQUAL("value", root[1u]);
+  delete reader;
+}
+JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterBool) {
+  Json::CharReaderBuilder b;
+  Json::Value root;
+  char const doc[] =
+      " true /*trailing\ncomment*/";
+  b.settings_["failIfExtra"] = true;
+  Json::CharReader* reader(b.newCharReader());
+  JSONCPP_STRING errs;
+  bool ok = reader->parse(
+      doc, doc + std::strlen(doc),
+      &root, &errs);
+  JSONTEST_ASSERT(ok);
+  JSONTEST_ASSERT_STRING_EQUAL("", errs);
+  JSONTEST_ASSERT_EQUAL(true, root.asBool());
+  delete reader;
+}
+struct CharReaderAllowDropNullTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
+  Json::CharReaderBuilder b;
+  b.settings_["allowDroppedNullPlaceholders"] = true;
+  Json::Value root;
+  JSONCPP_STRING errs;
+  Json::CharReader* reader(b.newCharReader());
+  {
+    char const doc[] = "{\"a\":,\"b\":true}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::nullValue, root.get("a", true));
+  }
+  {
+    char const doc[] = "{\"a\":}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(1u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::nullValue, root.get("a", true));
+  }
+  {
+    char const doc[] = "[]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT_EQUAL(0u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::arrayValue, root);
+  }
+  {
+    char const doc[] = "[null]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT_EQUAL(1u, root.size());
+  }
+  {
+    char const doc[] = "[,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+  }
+  {
+    char const doc[] = "[,,,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(4u, root.size());
+  }
+  {
+    char const doc[] = "[null,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+  }
+  {
+    char const doc[] = "[,null]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+  }
+  {
+    char const doc[] = "[,,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(3u, root.size());
+  }
+  {
+    char const doc[] = "[null,,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(3u, root.size());
+  }
+  {
+    char const doc[] = "[,null,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(3u, root.size());
+  }
+  {
+    char const doc[] = "[,,null]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT_EQUAL(3u, root.size());
+  }
+  {
+    char const doc[] = "[[],,,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(4u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::arrayValue, root[0u]);
+  }
+  {
+    char const doc[] = "[,[],,]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(4u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::arrayValue, root[1u]);
+  }
+  {
+    char const doc[] = "[,,,[]]";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT_EQUAL(4u, root.size());
+    JSONTEST_ASSERT_EQUAL(Json::arrayValue, root[3u]);
+  }
+  delete reader;
+}
+
+struct CharReaderAllowSingleQuotesTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderAllowSingleQuotesTest, issue182) {
+  Json::CharReaderBuilder b;
+  b.settings_["allowSingleQuotes"] = true;
+  Json::Value root;
+  JSONCPP_STRING errs;
+  Json::CharReader* reader(b.newCharReader());
+  {
+    char const doc[] = "{'a':true,\"b\":true}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_EQUAL(true, root.get("a", false));
+    JSONTEST_ASSERT_EQUAL(true, root.get("b", false));
+  }
+  {
+    char const doc[] = "{'a': 'x', \"b\":'y'}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_STRING_EQUAL("x", root["a"].asString());
+    JSONTEST_ASSERT_STRING_EQUAL("y", root["b"].asString());
+  }
+  delete reader;
+}
+
+struct CharReaderAllowZeroesTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderAllowZeroesTest, issue176) {
+  Json::CharReaderBuilder b;
+  b.settings_["allowSingleQuotes"] = true;
+  Json::Value root;
+  JSONCPP_STRING errs;
+  Json::CharReader* reader(b.newCharReader());
+  {
+    char const doc[] = "{'a':true,\"b\":true}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_EQUAL(true, root.get("a", false));
+    JSONTEST_ASSERT_EQUAL(true, root.get("b", false));
+  }
+  {
+    char const doc[] = "{'a': 'x', \"b\":'y'}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_STRING_EQUAL("x", root["a"].asString());
+    JSONTEST_ASSERT_STRING_EQUAL("y", root["b"].asString());
+  }
+  delete reader;
+}
+
+struct CharReaderAllowSpecialFloatsTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(CharReaderAllowSpecialFloatsTest, issue209) {
+  Json::CharReaderBuilder b;
+  b.settings_["allowSpecialFloats"] = true;
+  Json::Value root;
+  JSONCPP_STRING errs;
+  Json::CharReader* reader(b.newCharReader());
+  {
+    char const doc[] = "{\"a\":NaN,\"b\":Infinity,\"c\":-Infinity}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(3u, root.size());
+    double n = root["a"].asDouble();
+    JSONTEST_ASSERT(n != n);
+    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(), root.get("b", 0.0));
+    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(), root.get("c", 0.0));
+  }
+
+  struct TestData {
+    int line;
+    bool ok;
+    JSONCPP_STRING in;
+  };
+  const TestData test_data[] = {
+    {__LINE__, 1, "{\"a\":9}"},
+    {__LINE__, 0, "{\"a\":0Infinity}"},
+    {__LINE__, 0, "{\"a\":1Infinity}"},
+    {__LINE__, 0, "{\"a\":9Infinity}"},
+    {__LINE__, 0, "{\"a\":0nfinity}"},
+    {__LINE__, 0, "{\"a\":1nfinity}"},
+    {__LINE__, 0, "{\"a\":9nfinity}"},
+    {__LINE__, 0, "{\"a\":nfinity}"},
+    {__LINE__, 0, "{\"a\":.nfinity}"},
+    {__LINE__, 0, "{\"a\":9nfinity}"},
+    {__LINE__, 0, "{\"a\":-nfinity}"},
+    {__LINE__, 1, "{\"a\":Infinity}"},
+    {__LINE__, 0, "{\"a\":.Infinity}"},
+    {__LINE__, 0, "{\"a\":_Infinity}"},
+    {__LINE__, 0, "{\"a\":_nfinity}"},
+    {__LINE__, 1, "{\"a\":-Infinity}"}
+  };
+  for (size_t tdi = 0; tdi < sizeof(test_data) / sizeof(*test_data); ++tdi) {
+    const TestData& td = test_data[tdi];
+    bool ok = reader->parse(&*td.in.begin(),
+                            &*td.in.begin() + td.in.size(),
+                            &root, &errs);
+    JSONTEST_ASSERT(td.ok == ok)
+        << "line:" << td.line << "\n"
+        << "  expected: {"
+        << "ok:" << td.ok
+        << ", in:\'" << td.in << "\'"
+        << "}\n"
+        << "  actual: {"
+        << "ok:" << ok
+        << "}\n";
+  }
+
+  {
+    char const doc[] = "{\"posInf\": Infinity, \"NegInf\": -Infinity}";
+    bool ok = reader->parse(
+        doc, doc + std::strlen(doc),
+        &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL(2u, root.size());
+    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(), root["posInf"].asDouble());
+    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(), root["NegInf"].asDouble());
+  }
+  delete reader;
+}
+
+struct BuilderTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(BuilderTest, settings) {
+  {
+    Json::Value errs;
+    Json::CharReaderBuilder rb;
+    JSONTEST_ASSERT_EQUAL(false, rb.settings_.isMember("foo"));
+    JSONTEST_ASSERT_EQUAL(true, rb.validate(&errs));
+    rb["foo"] = "bar";
+    JSONTEST_ASSERT_EQUAL(true, rb.settings_.isMember("foo"));
+    JSONTEST_ASSERT_EQUAL(false, rb.validate(&errs));
+  }
+  {
+    Json::Value errs;
+    Json::StreamWriterBuilder wb;
+    JSONTEST_ASSERT_EQUAL(false, wb.settings_.isMember("foo"));
+    JSONTEST_ASSERT_EQUAL(true, wb.validate(&errs));
+    wb["foo"] = "bar";
+    JSONTEST_ASSERT_EQUAL(true, wb.settings_.isMember("foo"));
+    JSONTEST_ASSERT_EQUAL(false, wb.validate(&errs));
+  }
+}
+
+struct IteratorTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(IteratorTest, distance) {
+  Json::Value json;
+  json["k1"] = "a";
+  json["k2"] = "b";
+  int dist = 0;
+  JSONCPP_STRING str;
+  for (Json::ValueIterator it = json.begin(); it != json.end(); ++it) {
+    dist = it - json.begin();
+    str = it->asString().c_str();
+  }
+  JSONTEST_ASSERT_EQUAL(1, dist);
+  JSONTEST_ASSERT_STRING_EQUAL("b", str);
+}
+
+JSONTEST_FIXTURE(IteratorTest, names) {
+  Json::Value json;
+  json["k1"] = "a";
+  json["k2"] = "b";
+  Json::ValueIterator it = json.begin();
+  JSONTEST_ASSERT(it != json.end());
+  JSONTEST_ASSERT_EQUAL(Json::Value("k1"), it.key());
+  JSONTEST_ASSERT_STRING_EQUAL("k1", it.name());
+  JSONTEST_ASSERT_EQUAL(-1, it.index());
+  ++it;
+  JSONTEST_ASSERT(it != json.end());
+  JSONTEST_ASSERT_EQUAL(Json::Value("k2"), it.key());
+  JSONTEST_ASSERT_STRING_EQUAL("k2", it.name());
+  JSONTEST_ASSERT_EQUAL(-1, it.index());
+  ++it;
+  JSONTEST_ASSERT(it == json.end());
+}
+
+JSONTEST_FIXTURE(IteratorTest, indexes) {
+  Json::Value json;
+  json[0] = "a";
+  json[1] = "b";
+  Json::ValueIterator it = json.begin();
+  JSONTEST_ASSERT(it != json.end());
+  JSONTEST_ASSERT_EQUAL(Json::Value(Json::ArrayIndex(0)), it.key());
+  JSONTEST_ASSERT_STRING_EQUAL("", it.name());
+  JSONTEST_ASSERT_EQUAL(0, it.index());
+  ++it;
+  JSONTEST_ASSERT(it != json.end());
+  JSONTEST_ASSERT_EQUAL(Json::Value(Json::ArrayIndex(1)), it.key());
+  JSONTEST_ASSERT_STRING_EQUAL("", it.name());
+  JSONTEST_ASSERT_EQUAL(1, it.index());
+  ++it;
+  JSONTEST_ASSERT(it == json.end());
+}
+
+JSONTEST_FIXTURE(IteratorTest, const) {
+  Json::Value const v;
+  JSONTEST_ASSERT_THROWS(
+    Json::Value::iterator it(v.begin()) // Compile, but throw.
+  );
+
+  Json::Value value;
+
+  for(int i = 9; i < 12; ++i)
+  {
+    JSONCPP_OSTRINGSTREAM out;
+    out << std::setw(2) << i;
+    JSONCPP_STRING str = out.str();
+    value[str] = str;
+  }
+
+  JSONCPP_OSTRINGSTREAM out;
+  //in old code, this will get a compile error
+  Json::Value::const_iterator iter = value.begin();
+  for(; iter != value.end(); ++iter)
+  {
+    out << *iter << ',';
+  }
+  JSONCPP_STRING expected = "\" 9\",\"10\",\"11\",";
+  JSONTEST_ASSERT_STRING_EQUAL(expected, out.str());
+}
+
+struct RValueTest : JsonTest::TestCase {};
+
+JSONTEST_FIXTURE(RValueTest, moveConstruction) {
+#if JSON_HAS_RVALUE_REFERENCES
+  Json::Value json;
+  json["key"] = "value";
+  Json::Value moved = std::move(json);
+  JSONTEST_ASSERT(moved != json); // Possibly not nullValue; definitely not equal.
+  JSONTEST_ASSERT_EQUAL(Json::objectValue, moved.type());
+  JSONTEST_ASSERT_EQUAL(Json::stringValue, moved["key"].type());
+#endif
+}
+
+int main(int argc, const char* argv[]) {
+  JsonTest::Runner runner;
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, checkNormalizeFloatingPointStr);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, memberCount);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, objects);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, arrays);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, arrayIssue252);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, null);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, strings);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, bools);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, integers);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, nonIntegers);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareNull);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareInt);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareUInt);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareDouble);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareString);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareBoolean);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareArray);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareObject);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareType);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, offsetAccessors);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, typeChecksThrowExceptions);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, StaticString);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, CommentBefore);
+  //JSONTEST_REGISTER_FIXTURE(runner, ValueTest, nulls);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, zeroes);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, zeroesInKeys);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, specialFloats);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, precision);
+
+  JSONTEST_REGISTER_FIXTURE(runner, WriterTest, dropNullPlaceholders);
+  JSONTEST_REGISTER_FIXTURE(runner, StreamWriterTest, dropNullPlaceholders);
+  JSONTEST_REGISTER_FIXTURE(runner, StreamWriterTest, writeZeroes);
+
+  JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithNoErrors);
+  JSONTEST_REGISTER_FIXTURE(
+      runner, ReaderTest, parseWithNoErrorsTestingOffsets);
+  JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithOneError);
+  JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseChineseWithOneError);
+  JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithDetailError);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithNoErrors);
+  JSONTEST_REGISTER_FIXTURE(
+      runner, CharReaderTest, parseWithNoErrorsTestingOffsets);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithOneError);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseChineseWithOneError);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithDetailError);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithStackLimit);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderStrictModeTest, dupKeys);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, issue164);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, issue107);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterObject);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterArray);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterBool);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderAllowDropNullTest, issue178);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderAllowSingleQuotesTest, issue182);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderAllowZeroesTest, issue176);
+
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderAllowSpecialFloatsTest, issue209);
+
+  JSONTEST_REGISTER_FIXTURE(runner, BuilderTest, settings);
+
+  JSONTEST_REGISTER_FIXTURE(runner, IteratorTest, distance);
+  JSONTEST_REGISTER_FIXTURE(runner, IteratorTest, names);
+  JSONTEST_REGISTER_FIXTURE(runner, IteratorTest, indexes);
+  JSONTEST_REGISTER_FIXTURE(runner, IteratorTest, const);
+
+  JSONTEST_REGISTER_FIXTURE(runner, RValueTest, moveConstruction);
+
+  return runner.runCommandLine(argc, argv);
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/sconscript polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/sconscript
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/sconscript	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/src/test_lib_json/sconscript	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,10 @@
+Import( 'env_testing buildUnitTests' )
+
+buildUnitTests( env_testing, Split( """
+    main.cpp
+    jsontest.cpp
+     """ ),
+    'test_lib_json' )
+
+# For 'check' to work, 'libs' must be built first.
+env_testing.Depends('test_lib_json', '#libs')
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/cleantests.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/cleantests.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/cleantests.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/cleantests.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,16 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+"""Removes all files created during testing."""
+
+import glob
+import os
+
+paths = []
+for pattern in [ '*.actual', '*.actual-rewrite', '*.rewrite', '*.process-output' ]:
+    paths += glob.glob('data/' + pattern)
+
+for path in paths:
+    os.unlink(path)
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/fail_test_array_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/fail_test_array_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/fail_test_array_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/fail_test_array_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[ 1 2 3]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=[]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=[]
+.[0]=1
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[1]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,6 @@
+.=[]
+.[0]=1
+.[1]=2
+.[2]=3
+.[3]=4
+.[4]=5
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[ 1, 2 ,  3,4,5]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,5 @@
+.=[]
+.[0]=1
+.[1]="abc"
+.[2]=12.3
+.[3]=-4
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[1, "abc" , 12.3, -4]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,100 @@
+.=[]
+.[0]=1
+.[1]=2
+.[2]=3
+.[3]=4
+.[4]=5
+.[5]=6
+.[6]=7
+.[7]=8
+.[8]=9
+.[9]=10
+.[10]=11
+.[11]=12
+.[12]=13
+.[13]=14
+.[14]=15
+.[15]=16
+.[16]=17
+.[17]=18
+.[18]=19
+.[19]=20
+.[20]=21
+.[21]=22
+.[22]=23
+.[23]=24
+.[24]=25
+.[25]=26
+.[26]=27
+.[27]=28
+.[28]=29
+.[29]=30
+.[30]=31
+.[31]=32
+.[32]=33
+.[33]=34
+.[34]=35
+.[35]=36
+.[36]=37
+.[37]=38
+.[38]=39
+.[39]=40
+.[40]=41
+.[41]=42
+.[42]=43
+.[43]=44
+.[44]=45
+.[45]=46
+.[46]=47
+.[47]=48
+.[48]=49
+.[49]=50
+.[50]=51
+.[51]=52
+.[52]=53
+.[53]=54
+.[54]=55
+.[55]=56
+.[56]=57
+.[57]=58
+.[58]=59
+.[59]=60
+.[60]=61
+.[61]=62
+.[62]=63
+.[63]=64
+.[64]=65
+.[65]=66
+.[66]=67
+.[67]=68
+.[68]=69
+.[69]=70
+.[70]=71
+.[71]=72
+.[72]=73
+.[73]=74
+.[74]=75
+.[75]=76
+.[76]=77
+.[77]=78
+.[78]=79
+.[79]=80
+.[80]=81
+.[81]=82
+.[82]=83
+.[83]=84
+.[84]=85
+.[85]=86
+.[86]=87
+.[87]=88
+.[88]=89
+.[89]=90
+.[90]=91
+.[91]=92
+.[92]=93
+.[93]=94
+.[94]=95
+.[95]=96
+.[96]=97
+.[97]=98
+.[98]=99
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,5 @@
+.=[]
+.[0]="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+.[1]="bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+.[2]="ccccccccccccccccccccccc"
+.[3]="dddddddddddddddddddddddddddddddddddddddddddddddddddd"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_06.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+[ "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 
+  "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+  "ccccccccccccccccccccccc",
+  "dddddddddddddddddddddddddddddddddddddddddddddddddddd" ]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2122 @@
+.=[]
+.[0]=[]
+.[0][0]="A"
+.[0][1]=0
+.[0][2]=1
+.[0][3]=2
+.[0][4]=3
+.[0][5]=4
+.[0][6]=5
+.[0][7]=6
+.[0][8]=7
+.[0][9]=8
+.[0][10]=9
+.[0][11]=10
+.[0][12]=11
+.[0][13]=12
+.[0][14]=13
+.[0][15]=14
+.[0][16]=15
+.[0][17]=16
+.[0][18]=17
+.[0][19]=18
+.[0][20]=19
+.[0][21]=20
+.[0][22]=21
+.[0][23]=22
+.[0][24]=23
+.[0][25]=24
+.[0][26]=25
+.[0][27]=26
+.[0][28]=27
+.[0][29]=28
+.[0][30]=29
+.[0][31]=30
+.[0][32]=31
+.[0][33]=32
+.[0][34]=33
+.[0][35]=34
+.[0][36]=35
+.[0][37]=36
+.[0][38]=37
+.[0][39]=38
+.[0][40]=39
+.[0][41]=40
+.[0][42]=41
+.[0][43]=42
+.[0][44]=43
+.[0][45]=44
+.[0][46]=45
+.[0][47]=46
+.[0][48]=47
+.[0][49]=48
+.[0][50]=49
+.[0][51]=50
+.[0][52]=51
+.[0][53]=52
+.[0][54]=53
+.[0][55]=54
+.[0][56]=55
+.[0][57]=56
+.[0][58]=57
+.[0][59]=58
+.[0][60]=59
+.[0][61]=60
+.[0][62]=61
+.[0][63]=62
+.[0][64]=63
+.[0][65]=64
+.[0][66]=65
+.[0][67]=66
+.[0][68]=67
+.[0][69]=68
+.[0][70]=69
+.[0][71]=70
+.[0][72]=71
+.[0][73]=72
+.[0][74]=73
+.[0][75]=74
+.[0][76]=75
+.[0][77]=76
+.[0][78]=77
+.[0][79]=78
+.[0][80]=79
+.[0][81]=80
+.[0][82]=81
+.[0][83]=82
+.[0][84]=83
+.[0][85]=84
+.[0][86]=85
+.[0][87]=86
+.[0][88]=87
+.[0][89]=88
+.[0][90]=89
+.[0][91]=90
+.[0][92]=91
+.[0][93]=92
+.[0][94]=93
+.[0][95]=94
+.[0][96]=95
+.[0][97]=96
+.[0][98]=97
+.[0][99]=98
+.[0][100]=99
+.[0][101]=100
+.[0][102]=101
+.[0][103]=102
+.[0][104]=103
+.[0][105]=104
+.[0][106]=105
+.[0][107]=106
+.[0][108]=107
+.[0][109]=108
+.[0][110]=109
+.[0][111]=110
+.[0][112]=111
+.[0][113]=112
+.[0][114]=113
+.[0][115]=114
+.[0][116]=115
+.[0][117]=116
+.[0][118]=117
+.[0][119]=118
+.[0][120]=119
+.[0][121]=120
+.[0][122]=121
+.[0][123]=122
+.[0][124]=123
+.[0][125]=124
+.[0][126]=125
+.[0][127]=126
+.[0][128]=127
+.[0][129]=128
+.[0][130]=129
+.[0][131]=130
+.[0][132]=131
+.[0][133]=132
+.[0][134]=133
+.[0][135]=134
+.[0][136]=135
+.[0][137]=136
+.[0][138]=137
+.[0][139]=138
+.[0][140]=139
+.[0][141]=140
+.[0][142]=141
+.[0][143]=142
+.[0][144]=143
+.[0][145]=144
+.[0][146]=145
+.[0][147]=146
+.[0][148]=147
+.[0][149]=148
+.[0][150]=149
+.[0][151]=150
+.[0][152]=151
+.[0][153]=152
+.[0][154]=153
+.[0][155]=154
+.[0][156]=155
+.[0][157]=156
+.[0][158]=157
+.[0][159]=158
+.[0][160]=159
+.[0][161]=160
+.[0][162]=161
+.[0][163]=162
+.[0][164]=163
+.[0][165]=164
+.[0][166]=165
+.[0][167]=166
+.[0][168]=167
+.[0][169]=168
+.[0][170]=169
+.[0][171]=170
+.[0][172]=171
+.[0][173]=172
+.[0][174]=173
+.[0][175]=174
+.[0][176]=175
+.[0][177]=176
+.[0][178]=177
+.[0][179]=178
+.[0][180]=179
+.[0][181]=180
+.[0][182]=181
+.[0][183]=182
+.[0][184]=183
+.[0][185]=184
+.[0][186]=185
+.[0][187]=186
+.[0][188]=187
+.[0][189]=188
+.[0][190]=189
+.[0][191]=190
+.[0][192]=191
+.[0][193]=192
+.[0][194]=193
+.[0][195]=194
+.[0][196]=195
+.[0][197]=196
+.[0][198]=197
+.[0][199]=198
+.[0][200]=199
+.[0][201]=200
+.[0][202]=201
+.[0][203]=202
+.[0][204]=203
+.[0][205]=204
+.[0][206]=205
+.[0][207]=206
+.[0][208]=207
+.[0][209]=208
+.[0][210]=209
+.[0][211]=210
+.[0][212]=211
+.[0][213]=212
+.[0][214]=213
+.[0][215]=214
+.[0][216]=215
+.[0][217]=216
+.[0][218]=217
+.[0][219]=218
+.[0][220]=219
+.[0][221]=220
+.[0][222]=221
+.[0][223]=222
+.[0][224]=223
+.[0][225]=224
+.[0][226]=225
+.[0][227]=226
+.[0][228]=227
+.[0][229]=228
+.[0][230]=229
+.[0][231]=230
+.[0][232]=231
+.[0][233]=232
+.[0][234]=233
+.[0][235]=234
+.[0][236]=235
+.[0][237]=236
+.[0][238]=237
+.[0][239]=238
+.[0][240]=239
+.[0][241]=240
+.[0][242]=241
+.[0][243]=242
+.[0][244]=243
+.[0][245]=244
+.[0][246]=245
+.[0][247]=246
+.[0][248]=247
+.[0][249]=248
+.[0][250]=249
+.[0][251]=250
+.[0][252]=251
+.[0][253]=252
+.[0][254]=253
+.[0][255]=254
+.[0][256]=255
+.[0][257]=256
+.[0][258]=257
+.[0][259]=258
+.[0][260]=259
+.[0][261]=260
+.[0][262]=261
+.[0][263]=262
+.[0][264]=263
+.[0][265]=264
+.[0][266]=265
+.[0][267]=266
+.[0][268]=267
+.[0][269]=268
+.[0][270]=269
+.[0][271]=270
+.[0][272]=271
+.[0][273]=272
+.[0][274]=273
+.[0][275]=274
+.[0][276]=275
+.[0][277]=276
+.[0][278]=277
+.[0][279]=278
+.[0][280]=279
+.[0][281]=280
+.[0][282]=281
+.[0][283]=282
+.[0][284]=283
+.[0][285]=284
+.[0][286]=285
+.[0][287]=286
+.[0][288]=287
+.[0][289]=288
+.[0][290]=289
+.[0][291]=290
+.[0][292]=291
+.[0][293]=292
+.[0][294]=293
+.[0][295]=294
+.[0][296]=295
+.[0][297]=296
+.[0][298]=297
+.[0][299]=298
+.[0][300]=299
+.[0][301]=300
+.[0][302]=301
+.[0][303]=302
+.[0][304]=303
+.[0][305]=304
+.[0][306]=305
+.[0][307]=306
+.[0][308]=307
+.[0][309]=308
+.[0][310]=309
+.[0][311]=310
+.[0][312]=311
+.[0][313]=312
+.[0][314]=313
+.[0][315]=314
+.[0][316]=315
+.[0][317]=316
+.[0][318]=317
+.[0][319]=318
+.[0][320]=319
+.[0][321]=320
+.[0][322]=321
+.[0][323]=322
+.[0][324]=323
+.[0][325]=324
+.[0][326]=325
+.[0][327]=326
+.[0][328]=327
+.[0][329]=328
+.[0][330]=329
+.[0][331]=330
+.[0][332]=331
+.[0][333]=332
+.[0][334]=333
+.[0][335]=334
+.[0][336]=335
+.[0][337]=336
+.[0][338]=337
+.[0][339]=338
+.[0][340]=339
+.[0][341]=340
+.[0][342]=341
+.[0][343]=342
+.[0][344]=343
+.[0][345]=344
+.[0][346]=345
+.[0][347]=346
+.[0][348]=347
+.[0][349]=348
+.[0][350]=349
+.[0][351]=350
+.[0][352]=351
+.[0][353]=352
+.[0][354]=353
+.[0][355]=354
+.[0][356]=355
+.[0][357]=356
+.[0][358]=357
+.[0][359]=358
+.[0][360]=359
+.[0][361]=360
+.[0][362]=361
+.[0][363]=362
+.[0][364]=363
+.[0][365]=364
+.[0][366]=365
+.[0][367]=366
+.[0][368]=367
+.[0][369]=368
+.[0][370]=369
+.[0][371]=370
+.[0][372]=371
+.[0][373]=372
+.[0][374]=373
+.[0][375]=374
+.[0][376]=375
+.[0][377]=376
+.[0][378]=377
+.[0][379]=378
+.[0][380]=379
+.[0][381]=380
+.[0][382]=381
+.[0][383]=382
+.[0][384]=383
+.[0][385]=384
+.[0][386]=385
+.[0][387]=386
+.[0][388]=387
+.[0][389]=388
+.[0][390]=389
+.[0][391]=390
+.[0][392]=391
+.[0][393]=392
+.[0][394]=393
+.[0][395]=394
+.[0][396]=395
+.[0][397]=396
+.[0][398]=397
+.[0][399]=398
+.[0][400]=399
+.[0][401]=400
+.[0][402]=401
+.[0][403]=402
+.[0][404]=403
+.[0][405]=404
+.[0][406]=405
+.[0][407]=406
+.[0][408]=407
+.[0][409]=408
+.[0][410]=409
+.[0][411]=410
+.[0][412]=411
+.[0][413]=412
+.[0][414]=413
+.[0][415]=414
+.[0][416]=415
+.[0][417]=416
+.[0][418]=417
+.[0][419]=418
+.[0][420]=419
+.[0][421]=420
+.[0][422]=421
+.[0][423]=422
+.[0][424]=423
+.[0][425]=424
+.[0][426]=425
+.[0][427]=426
+.[0][428]=427
+.[0][429]=428
+.[0][430]=429
+.[0][431]=430
+.[0][432]=431
+.[0][433]=432
+.[0][434]=433
+.[0][435]=434
+.[0][436]=435
+.[0][437]=436
+.[0][438]=437
+.[0][439]=438
+.[0][440]=439
+.[0][441]=440
+.[0][442]=441
+.[0][443]=442
+.[0][444]=443
+.[0][445]=444
+.[0][446]=445
+.[0][447]=446
+.[0][448]=447
+.[0][449]=448
+.[0][450]=449
+.[0][451]=450
+.[0][452]=451
+.[0][453]=452
+.[0][454]=453
+.[0][455]=454
+.[0][456]=455
+.[0][457]=456
+.[0][458]=457
+.[0][459]=458
+.[0][460]=459
+.[0][461]=460
+.[0][462]=461
+.[0][463]=462
+.[0][464]=463
+.[0][465]=464
+.[0][466]=465
+.[0][467]=466
+.[0][468]=467
+.[0][469]=468
+.[0][470]=469
+.[0][471]=470
+.[0][472]=471
+.[0][473]=472
+.[0][474]=473
+.[0][475]=474
+.[0][476]=475
+.[0][477]=476
+.[0][478]=477
+.[0][479]=478
+.[0][480]=479
+.[0][481]=480
+.[0][482]=481
+.[0][483]=482
+.[0][484]=483
+.[0][485]=484
+.[0][486]=485
+.[0][487]=486
+.[0][488]=487
+.[0][489]=488
+.[0][490]=489
+.[0][491]=490
+.[0][492]=491
+.[0][493]=492
+.[0][494]=493
+.[0][495]=494
+.[0][496]=495
+.[0][497]=496
+.[0][498]=497
+.[0][499]=498
+.[0][500]=499
+.[0][501]=500
+.[0][502]=501
+.[0][503]=502
+.[0][504]=503
+.[0][505]=504
+.[0][506]=505
+.[0][507]=506
+.[0][508]=507
+.[0][509]=508
+.[0][510]=509
+.[0][511]=510
+.[0][512]=511
+.[0][513]=512
+.[0][514]=513
+.[0][515]=514
+.[0][516]=515
+.[0][517]=516
+.[0][518]=517
+.[0][519]=518
+.[0][520]=519
+.[0][521]=520
+.[0][522]=521
+.[0][523]=522
+.[0][524]=523
+.[0][525]=524
+.[0][526]=525
+.[0][527]=526
+.[0][528]=527
+.[0][529]=528
+.[0][530]=529
+.[0][531]=530
+.[0][532]=531
+.[0][533]=532
+.[0][534]=533
+.[0][535]=534
+.[0][536]=535
+.[0][537]=536
+.[0][538]=537
+.[0][539]=538
+.[0][540]=539
+.[0][541]=540
+.[0][542]=541
+.[0][543]=542
+.[0][544]=543
+.[0][545]=544
+.[0][546]=545
+.[0][547]=546
+.[0][548]=547
+.[0][549]=548
+.[0][550]=549
+.[0][551]=550
+.[0][552]=551
+.[0][553]=552
+.[0][554]=553
+.[0][555]=554
+.[0][556]=555
+.[0][557]=556
+.[0][558]=557
+.[0][559]=558
+.[0][560]=559
+.[0][561]=560
+.[0][562]=561
+.[0][563]=562
+.[0][564]=563
+.[0][565]=564
+.[0][566]=565
+.[0][567]=566
+.[0][568]=567
+.[0][569]=568
+.[0][570]=569
+.[0][571]=570
+.[0][572]=571
+.[0][573]=572
+.[0][574]=573
+.[0][575]=574
+.[0][576]=575
+.[0][577]=576
+.[0][578]=577
+.[0][579]=578
+.[0][580]=579
+.[0][581]=580
+.[0][582]=581
+.[0][583]=582
+.[0][584]=583
+.[0][585]=584
+.[0][586]=585
+.[0][587]=586
+.[0][588]=587
+.[0][589]=588
+.[0][590]=589
+.[0][591]=590
+.[0][592]=591
+.[0][593]=592
+.[0][594]=593
+.[0][595]=594
+.[0][596]=595
+.[0][597]=596
+.[0][598]=597
+.[0][599]=598
+.[0][600]=599
+.[0][601]=600
+.[0][602]=601
+.[0][603]=602
+.[0][604]=603
+.[0][605]=604
+.[0][606]=605
+.[0][607]=606
+.[0][608]=607
+.[0][609]=608
+.[0][610]=609
+.[0][611]=610
+.[0][612]=611
+.[0][613]=612
+.[0][614]=613
+.[0][615]=614
+.[0][616]=615
+.[0][617]=616
+.[0][618]=617
+.[0][619]=618
+.[0][620]=619
+.[0][621]=620
+.[0][622]=621
+.[0][623]=622
+.[0][624]=623
+.[0][625]=624
+.[0][626]=625
+.[0][627]=626
+.[0][628]=627
+.[0][629]=628
+.[0][630]=629
+.[0][631]=630
+.[0][632]=631
+.[0][633]=632
+.[0][634]=633
+.[0][635]=634
+.[0][636]=635
+.[0][637]=636
+.[0][638]=637
+.[0][639]=638
+.[0][640]=639
+.[0][641]=640
+.[0][642]=641
+.[0][643]=642
+.[0][644]=643
+.[0][645]=644
+.[0][646]=645
+.[0][647]=646
+.[0][648]=647
+.[0][649]=648
+.[0][650]=649
+.[0][651]=650
+.[0][652]=651
+.[0][653]=652
+.[0][654]=653
+.[0][655]=654
+.[0][656]=655
+.[0][657]=656
+.[0][658]=657
+.[0][659]=658
+.[0][660]=659
+.[0][661]=660
+.[0][662]=661
+.[0][663]=662
+.[0][664]=663
+.[0][665]=664
+.[0][666]=665
+.[0][667]=666
+.[0][668]=667
+.[0][669]=668
+.[0][670]=669
+.[0][671]=670
+.[0][672]=671
+.[0][673]=672
+.[0][674]=673
+.[0][675]=674
+.[0][676]=675
+.[0][677]=676
+.[0][678]=677
+.[0][679]=678
+.[0][680]=679
+.[0][681]=680
+.[0][682]=681
+.[0][683]=682
+.[0][684]=683
+.[0][685]=684
+.[0][686]=685
+.[0][687]=686
+.[0][688]=687
+.[0][689]=688
+.[0][690]=689
+.[0][691]=690
+.[0][692]=691
+.[0][693]=692
+.[0][694]=693
+.[0][695]=694
+.[0][696]=695
+.[0][697]=696
+.[0][698]=697
+.[0][699]=698
+.[0][700]=699
+.[0][701]=700
+.[0][702]=701
+.[0][703]=702
+.[0][704]=703
+.[0][705]=704
+.[0][706]=705
+.[0][707]=706
+.[0][708]=707
+.[0][709]=708
+.[0][710]=709
+.[0][711]=710
+.[0][712]=711
+.[0][713]=712
+.[0][714]=713
+.[0][715]=714
+.[0][716]=715
+.[0][717]=716
+.[0][718]=717
+.[0][719]=718
+.[0][720]=719
+.[0][721]=720
+.[0][722]=721
+.[0][723]=722
+.[0][724]=723
+.[0][725]=724
+.[0][726]=725
+.[0][727]=726
+.[0][728]=727
+.[0][729]=728
+.[0][730]=729
+.[0][731]=730
+.[0][732]=731
+.[0][733]=732
+.[0][734]=733
+.[0][735]=734
+.[0][736]=735
+.[0][737]=736
+.[0][738]=737
+.[0][739]=738
+.[0][740]=739
+.[0][741]=740
+.[0][742]=741
+.[0][743]=742
+.[0][744]=743
+.[0][745]=744
+.[0][746]=745
+.[0][747]=746
+.[0][748]=747
+.[0][749]=748
+.[0][750]=749
+.[0][751]=750
+.[0][752]=751
+.[0][753]=752
+.[0][754]=753
+.[0][755]=754
+.[0][756]=755
+.[0][757]=756
+.[0][758]=757
+.[0][759]=758
+.[0][760]=759
+.[0][761]=760
+.[0][762]=761
+.[0][763]=762
+.[0][764]=763
+.[0][765]=764
+.[0][766]=765
+.[0][767]=766
+.[0][768]=767
+.[0][769]=768
+.[0][770]=769
+.[0][771]=770
+.[0][772]=771
+.[0][773]=772
+.[0][774]=773
+.[0][775]=774
+.[0][776]=775
+.[0][777]=776
+.[0][778]=777
+.[0][779]=778
+.[0][780]=779
+.[0][781]=780
+.[0][782]=781
+.[0][783]=782
+.[0][784]=783
+.[0][785]=784
+.[0][786]=785
+.[0][787]=786
+.[0][788]=787
+.[0][789]=788
+.[0][790]=789
+.[0][791]=790
+.[0][792]=791
+.[0][793]=792
+.[0][794]=793
+.[0][795]=794
+.[0][796]=795
+.[0][797]=796
+.[0][798]=797
+.[0][799]=798
+.[0][800]=799
+.[0][801]=800
+.[0][802]=801
+.[0][803]=802
+.[0][804]=803
+.[0][805]=804
+.[0][806]=805
+.[0][807]=806
+.[0][808]=807
+.[0][809]=808
+.[0][810]=809
+.[0][811]=810
+.[0][812]=811
+.[0][813]=812
+.[0][814]=813
+.[0][815]=814
+.[0][816]=815
+.[0][817]=816
+.[0][818]=817
+.[0][819]=818
+.[0][820]=819
+.[0][821]=820
+.[0][822]=821
+.[0][823]=822
+.[0][824]=823
+.[0][825]=824
+.[0][826]=825
+.[0][827]=826
+.[0][828]=827
+.[0][829]=828
+.[0][830]=829
+.[0][831]=830
+.[0][832]=831
+.[0][833]=832
+.[0][834]=833
+.[0][835]=834
+.[0][836]=835
+.[0][837]=836
+.[0][838]=837
+.[0][839]=838
+.[0][840]=839
+.[0][841]=840
+.[0][842]=841
+.[0][843]=842
+.[0][844]=843
+.[0][845]=844
+.[0][846]=845
+.[0][847]=846
+.[0][848]=847
+.[0][849]=848
+.[0][850]=849
+.[0][851]=850
+.[0][852]=851
+.[0][853]=852
+.[0][854]=853
+.[0][855]=854
+.[0][856]=855
+.[0][857]=856
+.[0][858]=857
+.[0][859]=858
+.[0][860]=859
+.[0][861]=860
+.[0][862]=861
+.[0][863]=862
+.[0][864]=863
+.[0][865]=864
+.[0][866]=865
+.[0][867]=866
+.[0][868]=867
+.[0][869]=868
+.[0][870]=869
+.[0][871]=870
+.[0][872]=871
+.[0][873]=872
+.[0][874]=873
+.[0][875]=874
+.[0][876]=875
+.[0][877]=876
+.[0][878]=877
+.[0][879]=878
+.[0][880]=879
+.[0][881]=880
+.[0][882]=881
+.[0][883]=882
+.[0][884]=883
+.[0][885]=884
+.[0][886]=885
+.[0][887]=886
+.[0][888]=887
+.[0][889]=888
+.[0][890]=889
+.[0][891]=890
+.[0][892]=891
+.[0][893]=892
+.[0][894]=893
+.[0][895]=894
+.[0][896]=895
+.[0][897]=896
+.[0][898]=897
+.[0][899]=898
+.[0][900]=899
+.[0][901]=900
+.[0][902]=901
+.[0][903]=902
+.[0][904]=903
+.[0][905]=904
+.[0][906]=905
+.[0][907]=906
+.[0][908]=907
+.[0][909]=908
+.[0][910]=909
+.[0][911]=910
+.[0][912]=911
+.[0][913]=912
+.[0][914]=913
+.[0][915]=914
+.[0][916]=915
+.[0][917]=916
+.[0][918]=917
+.[0][919]=918
+.[0][920]=919
+.[0][921]=920
+.[0][922]=921
+.[0][923]=922
+.[0][924]=923
+.[0][925]=924
+.[0][926]=925
+.[0][927]=926
+.[0][928]=927
+.[0][929]=928
+.[0][930]=929
+.[0][931]=930
+.[0][932]=931
+.[0][933]=932
+.[0][934]=933
+.[0][935]=934
+.[0][936]=935
+.[0][937]=936
+.[0][938]=937
+.[0][939]=938
+.[0][940]=939
+.[0][941]=940
+.[0][942]=941
+.[0][943]=942
+.[0][944]=943
+.[0][945]=944
+.[0][946]=945
+.[0][947]=946
+.[0][948]=947
+.[0][949]=948
+.[0][950]=949
+.[0][951]=950
+.[0][952]=951
+.[0][953]=952
+.[0][954]=953
+.[0][955]=954
+.[0][956]=955
+.[0][957]=956
+.[0][958]=957
+.[0][959]=958
+.[0][960]=959
+.[0][961]=960
+.[0][962]=961
+.[0][963]=962
+.[0][964]=963
+.[0][965]=964
+.[0][966]=965
+.[0][967]=966
+.[0][968]=967
+.[0][969]=968
+.[0][970]=969
+.[0][971]=970
+.[0][972]=971
+.[0][973]=972
+.[0][974]=973
+.[0][975]=974
+.[0][976]=975
+.[0][977]=976
+.[0][978]=977
+.[0][979]=978
+.[0][980]=979
+.[0][981]=980
+.[0][982]=981
+.[0][983]=982
+.[0][984]=983
+.[0][985]=984
+.[0][986]=985
+.[0][987]=986
+.[0][988]=987
+.[0][989]=988
+.[0][990]=989
+.[0][991]=990
+.[0][992]=991
+.[0][993]=992
+.[0][994]=993
+.[0][995]=994
+.[0][996]=995
+.[0][997]=996
+.[0][998]=997
+.[0][999]=998
+.[0][1000]=999
+.[0][1001]=1000
+.[0][1002]=1001
+.[0][1003]=1002
+.[0][1004]=1003
+.[0][1005]=1004
+.[0][1006]=1005
+.[0][1007]=1006
+.[0][1008]=1007
+.[0][1009]=1008
+.[0][1010]=1009
+.[0][1011]=1010
+.[0][1012]=1011
+.[0][1013]=1012
+.[0][1014]=1013
+.[0][1015]=1014
+.[0][1016]=1015
+.[0][1017]=1016
+.[0][1018]=1017
+.[0][1019]=1018
+.[0][1020]=1019
+.[0][1021]=1020
+.[0][1022]=1021
+.[0][1023]=1022
+.[0][1024]=1023
+.[0][1025]=1024
+.[0][1026]=1025
+.[0][1027]=1026
+.[0][1028]=1027
+.[0][1029]=1028
+.[0][1030]=1029
+.[0][1031]=1030
+.[0][1032]=1031
+.[0][1033]=1032
+.[0][1034]=1033
+.[0][1035]=1034
+.[0][1036]=1035
+.[0][1037]=1036
+.[0][1038]=1037
+.[0][1039]=1038
+.[0][1040]=1039
+.[0][1041]=1040
+.[0][1042]=1041
+.[0][1043]=1042
+.[0][1044]=1043
+.[0][1045]=1044
+.[0][1046]=1045
+.[0][1047]=1046
+.[0][1048]=1047
+.[0][1049]=1048
+.[0][1050]=1049
+.[0][1051]=1050
+.[0][1052]=1051
+.[0][1053]=1052
+.[0][1054]=1053
+.[0][1055]=1054
+.[0][1056]=1055
+.[0][1057]=1056
+.[0][1058]=1057
+.[0][1059]=1058
+.[0][1060]=1059
+.[0][1061]=1060
+.[0][1062]=1061
+.[0][1063]=1062
+.[0][1064]=1063
+.[0][1065]=1064
+.[0][1066]=1065
+.[0][1067]=1066
+.[0][1068]=1067
+.[0][1069]=1068
+.[0][1070]=1069
+.[0][1071]=1070
+.[0][1072]=1071
+.[0][1073]=1072
+.[0][1074]=1073
+.[0][1075]=1074
+.[0][1076]=1075
+.[0][1077]=1076
+.[0][1078]=1077
+.[0][1079]=1078
+.[0][1080]=1079
+.[0][1081]=1080
+.[0][1082]=1081
+.[0][1083]=1082
+.[0][1084]=1083
+.[0][1085]=1084
+.[0][1086]=1085
+.[0][1087]=1086
+.[0][1088]=1087
+.[0][1089]=1088
+.[0][1090]=1089
+.[0][1091]=1090
+.[0][1092]=1091
+.[0][1093]=1092
+.[0][1094]=1093
+.[0][1095]=1094
+.[0][1096]=1095
+.[0][1097]=1096
+.[0][1098]=1097
+.[0][1099]=1098
+.[0][1100]=1099
+.[0][1101]=1100
+.[0][1102]=1101
+.[0][1103]=1102
+.[0][1104]=1103
+.[0][1105]=1104
+.[0][1106]=1105
+.[0][1107]=1106
+.[0][1108]=1107
+.[0][1109]=1108
+.[0][1110]=1109
+.[0][1111]=1110
+.[0][1112]=1111
+.[0][1113]=1112
+.[0][1114]=1113
+.[0][1115]=1114
+.[0][1116]=1115
+.[0][1117]=1116
+.[0][1118]=1117
+.[0][1119]=1118
+.[0][1120]=1119
+.[0][1121]=1120
+.[0][1122]=1121
+.[0][1123]=1122
+.[0][1124]=1123
+.[0][1125]=1124
+.[0][1126]=1125
+.[0][1127]=1126
+.[0][1128]=1127
+.[0][1129]=1128
+.[0][1130]=1129
+.[0][1131]=1130
+.[0][1132]=1131
+.[0][1133]=1132
+.[0][1134]=1133
+.[0][1135]=1134
+.[0][1136]=1135
+.[0][1137]=1136
+.[0][1138]=1137
+.[0][1139]=1138
+.[0][1140]=1139
+.[0][1141]=1140
+.[0][1142]=1141
+.[0][1143]=1142
+.[0][1144]=1143
+.[0][1145]=1144
+.[0][1146]=1145
+.[0][1147]=1146
+.[0][1148]=1147
+.[0][1149]=1148
+.[0][1150]=1149
+.[0][1151]=1150
+.[0][1152]=1151
+.[0][1153]=1152
+.[0][1154]=1153
+.[0][1155]=1154
+.[0][1156]=1155
+.[0][1157]=1156
+.[0][1158]=1157
+.[0][1159]=1158
+.[0][1160]=1159
+.[0][1161]=1160
+.[0][1162]=1161
+.[0][1163]=1162
+.[0][1164]=1163
+.[0][1165]=1164
+.[0][1166]=1165
+.[0][1167]=1166
+.[0][1168]=1167
+.[0][1169]=1168
+.[0][1170]=1169
+.[0][1171]=1170
+.[0][1172]=1171
+.[0][1173]=1172
+.[0][1174]=1173
+.[0][1175]=1174
+.[0][1176]=1175
+.[0][1177]=1176
+.[0][1178]=1177
+.[0][1179]=1178
+.[0][1180]=1179
+.[0][1181]=1180
+.[0][1182]=1181
+.[0][1183]=1182
+.[0][1184]=1183
+.[0][1185]=1184
+.[0][1186]=1185
+.[0][1187]=1186
+.[0][1188]=1187
+.[0][1189]=1188
+.[0][1190]=1189
+.[0][1191]=1190
+.[0][1192]=1191
+.[0][1193]=1192
+.[0][1194]=1193
+.[0][1195]=1194
+.[0][1196]=1195
+.[0][1197]=1196
+.[0][1198]=1197
+.[0][1199]=1198
+.[0][1200]=1199
+.[0][1201]=1200
+.[0][1202]=1201
+.[0][1203]=1202
+.[0][1204]=1203
+.[0][1205]=1204
+.[0][1206]=1205
+.[0][1207]=1206
+.[0][1208]=1207
+.[0][1209]=1208
+.[0][1210]=1209
+.[0][1211]=1210
+.[0][1212]=1211
+.[0][1213]=1212
+.[0][1214]=1213
+.[0][1215]=1214
+.[0][1216]=1215
+.[0][1217]=1216
+.[0][1218]=1217
+.[0][1219]=1218
+.[0][1220]=1219
+.[0][1221]=1220
+.[0][1222]=1221
+.[0][1223]=1222
+.[0][1224]=1223
+.[0][1225]=1224
+.[0][1226]=1225
+.[0][1227]=1226
+.[0][1228]=1227
+.[0][1229]=1228
+.[0][1230]=1229
+.[0][1231]=1230
+.[0][1232]=1231
+.[0][1233]=1232
+.[0][1234]=1233
+.[0][1235]=1234
+.[0][1236]=1235
+.[0][1237]=1236
+.[0][1238]=1237
+.[0][1239]=1238
+.[0][1240]=1239
+.[0][1241]=1240
+.[0][1242]=1241
+.[0][1243]=1242
+.[0][1244]=1243
+.[0][1245]=1244
+.[0][1246]=1245
+.[0][1247]=1246
+.[0][1248]=1247
+.[0][1249]=1248
+.[0][1250]=1249
+.[0][1251]=1250
+.[0][1252]=1251
+.[0][1253]=1252
+.[0][1254]=1253
+.[0][1255]=1254
+.[0][1256]=1255
+.[0][1257]=1256
+.[0][1258]=1257
+.[0][1259]=1258
+.[0][1260]=1259
+.[0][1261]=1260
+.[0][1262]=1261
+.[0][1263]=1262
+.[0][1264]=1263
+.[0][1265]=1264
+.[0][1266]=1265
+.[0][1267]=1266
+.[0][1268]=1267
+.[0][1269]=1268
+.[0][1270]=1269
+.[0][1271]=1270
+.[0][1272]=1271
+.[0][1273]=1272
+.[0][1274]=1273
+.[0][1275]=1274
+.[0][1276]=1275
+.[0][1277]=1276
+.[0][1278]=1277
+.[0][1279]=1278
+.[0][1280]=1279
+.[0][1281]=1280
+.[0][1282]=1281
+.[0][1283]=1282
+.[0][1284]=1283
+.[0][1285]=1284
+.[0][1286]=1285
+.[0][1287]=1286
+.[0][1288]=1287
+.[0][1289]=1288
+.[0][1290]=1289
+.[0][1291]=1290
+.[0][1292]=1291
+.[0][1293]=1292
+.[0][1294]=1293
+.[0][1295]=1294
+.[0][1296]=1295
+.[0][1297]=1296
+.[0][1298]=1297
+.[0][1299]=1298
+.[0][1300]=1299
+.[0][1301]=1300
+.[0][1302]=1301
+.[0][1303]=1302
+.[0][1304]=1303
+.[0][1305]=1304
+.[0][1306]=1305
+.[0][1307]=1306
+.[0][1308]=1307
+.[0][1309]=1308
+.[0][1310]=1309
+.[0][1311]=1310
+.[0][1312]=1311
+.[0][1313]=1312
+.[0][1314]=1313
+.[0][1315]=1314
+.[0][1316]=1315
+.[0][1317]=1316
+.[0][1318]=1317
+.[0][1319]=1318
+.[0][1320]=1319
+.[0][1321]=1320
+.[0][1322]=1321
+.[0][1323]=1322
+.[0][1324]=1323
+.[0][1325]=1324
+.[0][1326]=1325
+.[0][1327]=1326
+.[0][1328]=1327
+.[0][1329]=1328
+.[0][1330]=1329
+.[0][1331]=1330
+.[0][1332]=1331
+.[0][1333]=1332
+.[0][1334]=1333
+.[0][1335]=1334
+.[0][1336]=1335
+.[0][1337]=1336
+.[0][1338]=1337
+.[0][1339]=1338
+.[0][1340]=1339
+.[0][1341]=1340
+.[0][1342]=1341
+.[0][1343]=1342
+.[0][1344]=1343
+.[0][1345]=1344
+.[0][1346]=1345
+.[0][1347]=1346
+.[0][1348]=1347
+.[0][1349]=1348
+.[0][1350]=1349
+.[0][1351]=1350
+.[0][1352]=1351
+.[0][1353]=1352
+.[0][1354]=1353
+.[0][1355]=1354
+.[0][1356]=1355
+.[0][1357]=1356
+.[0][1358]=1357
+.[0][1359]=1358
+.[0][1360]=1359
+.[0][1361]=1360
+.[0][1362]=1361
+.[0][1363]=1362
+.[0][1364]=1363
+.[0][1365]=1364
+.[0][1366]=1365
+.[0][1367]=1366
+.[0][1368]=1367
+.[0][1369]=1368
+.[0][1370]=1369
+.[0][1371]=1370
+.[0][1372]=1371
+.[0][1373]=1372
+.[0][1374]=1373
+.[0][1375]=1374
+.[0][1376]=1375
+.[0][1377]=1376
+.[0][1378]=1377
+.[0][1379]=1378
+.[0][1380]=1379
+.[0][1381]=1380
+.[0][1382]=1381
+.[0][1383]=1382
+.[0][1384]=1383
+.[0][1385]=1384
+.[0][1386]=1385
+.[0][1387]=1386
+.[0][1388]=1387
+.[0][1389]=1388
+.[0][1390]=1389
+.[0][1391]=1390
+.[0][1392]=1391
+.[0][1393]=1392
+.[0][1394]=1393
+.[0][1395]=1394
+.[0][1396]=1395
+.[0][1397]=1396
+.[0][1398]=1397
+.[0][1399]=1398
+.[0][1400]=1399
+.[0][1401]=1400
+.[0][1402]=1401
+.[0][1403]=1402
+.[0][1404]=1403
+.[0][1405]=1404
+.[0][1406]=1405
+.[0][1407]=1406
+.[0][1408]=1407
+.[0][1409]=1408
+.[0][1410]=1409
+.[0][1411]=1410
+.[0][1412]=1411
+.[0][1413]=1412
+.[0][1414]=1413
+.[0][1415]=1414
+.[0][1416]=1415
+.[0][1417]=1416
+.[0][1418]=1417
+.[0][1419]=1418
+.[0][1420]=1419
+.[0][1421]=1420
+.[0][1422]=1421
+.[0][1423]=1422
+.[0][1424]=1423
+.[0][1425]=1424
+.[0][1426]=1425
+.[0][1427]=1426
+.[0][1428]=1427
+.[0][1429]=1428
+.[0][1430]=1429
+.[0][1431]=1430
+.[0][1432]=1431
+.[0][1433]=1432
+.[0][1434]=1433
+.[0][1435]=1434
+.[0][1436]=1435
+.[0][1437]=1436
+.[0][1438]=1437
+.[0][1439]=1438
+.[0][1440]=1439
+.[0][1441]=1440
+.[0][1442]=1441
+.[0][1443]=1442
+.[0][1444]=1443
+.[0][1445]=1444
+.[0][1446]=1445
+.[0][1447]=1446
+.[0][1448]=1447
+.[0][1449]=1448
+.[0][1450]=1449
+.[0][1451]=1450
+.[0][1452]=1451
+.[0][1453]=1452
+.[0][1454]=1453
+.[0][1455]=1454
+.[0][1456]=1455
+.[0][1457]=1456
+.[0][1458]=1457
+.[0][1459]=1458
+.[0][1460]=1459
+.[0][1461]=1460
+.[0][1462]=1461
+.[0][1463]=1462
+.[0][1464]=1463
+.[0][1465]=1464
+.[0][1466]=1465
+.[0][1467]=1466
+.[0][1468]=1467
+.[0][1469]=1468
+.[0][1470]=1469
+.[0][1471]=1470
+.[0][1472]=1471
+.[0][1473]=1472
+.[0][1474]=1473
+.[0][1475]=1474
+.[0][1476]=1475
+.[0][1477]=1476
+.[0][1478]=1477
+.[0][1479]=1478
+.[0][1480]=1479
+.[0][1481]=1480
+.[0][1482]=1481
+.[0][1483]=1482
+.[0][1484]=1483
+.[0][1485]=1484
+.[0][1486]=1485
+.[0][1487]=1486
+.[0][1488]=1487
+.[0][1489]=1488
+.[0][1490]=1489
+.[0][1491]=1490
+.[0][1492]=1491
+.[0][1493]=1492
+.[0][1494]=1493
+.[0][1495]=1494
+.[0][1496]=1495
+.[0][1497]=1496
+.[0][1498]=1497
+.[0][1499]=1498
+.[0][1500]=1499
+.[0][1501]=1500
+.[0][1502]=1501
+.[0][1503]=1502
+.[0][1504]=1503
+.[0][1505]=1504
+.[0][1506]=1505
+.[0][1507]=1506
+.[0][1508]=1507
+.[0][1509]=1508
+.[0][1510]=1509
+.[0][1511]=1510
+.[0][1512]=1511
+.[0][1513]=1512
+.[0][1514]=1513
+.[0][1515]=1514
+.[0][1516]=1515
+.[0][1517]=1516
+.[0][1518]=1517
+.[0][1519]=1518
+.[0][1520]=1519
+.[0][1521]=1520
+.[0][1522]=1521
+.[0][1523]=1522
+.[0][1524]=1523
+.[0][1525]=1524
+.[0][1526]=1525
+.[0][1527]=1526
+.[0][1528]=1527
+.[0][1529]=1528
+.[0][1530]=1529
+.[0][1531]=1530
+.[0][1532]=1531
+.[0][1533]=1532
+.[0][1534]=1533
+.[0][1535]=1534
+.[0][1536]=1535
+.[0][1537]=1536
+.[0][1538]=1537
+.[0][1539]=1538
+.[0][1540]=1539
+.[0][1541]=1540
+.[0][1542]=1541
+.[0][1543]=1542
+.[0][1544]=1543
+.[0][1545]=1544
+.[0][1546]=1545
+.[0][1547]=1546
+.[0][1548]=1547
+.[0][1549]=1548
+.[0][1550]=1549
+.[0][1551]=1550
+.[0][1552]=1551
+.[0][1553]=1552
+.[0][1554]=1553
+.[0][1555]=1554
+.[0][1556]=1555
+.[0][1557]=1556
+.[0][1558]=1557
+.[0][1559]=1558
+.[0][1560]=1559
+.[0][1561]=1560
+.[0][1562]=1561
+.[0][1563]=1562
+.[0][1564]=1563
+.[0][1565]=1564
+.[0][1566]=1565
+.[0][1567]=1566
+.[0][1568]=1567
+.[0][1569]=1568
+.[0][1570]=1569
+.[0][1571]=1570
+.[0][1572]=1571
+.[0][1573]=1572
+.[0][1574]=1573
+.[0][1575]=1574
+.[0][1576]=1575
+.[0][1577]=1576
+.[0][1578]=1577
+.[0][1579]=1578
+.[0][1580]=1579
+.[0][1581]=1580
+.[0][1582]=1581
+.[0][1583]=1582
+.[0][1584]=1583
+.[0][1585]=1584
+.[0][1586]=1585
+.[0][1587]=1586
+.[0][1588]=1587
+.[0][1589]=1588
+.[0][1590]=1589
+.[0][1591]=1590
+.[0][1592]=1591
+.[0][1593]=1592
+.[0][1594]=1593
+.[0][1595]=1594
+.[0][1596]=1595
+.[0][1597]=1596
+.[0][1598]=1597
+.[0][1599]=1598
+.[0][1600]=1599
+.[0][1601]=1600
+.[0][1602]=1601
+.[0][1603]=1602
+.[0][1604]=1603
+.[0][1605]=1604
+.[0][1606]=1605
+.[0][1607]=1606
+.[0][1608]=1607
+.[0][1609]=1608
+.[0][1610]=1609
+.[0][1611]=1610
+.[0][1612]=1611
+.[0][1613]=1612
+.[0][1614]=1613
+.[0][1615]=1614
+.[0][1616]=1615
+.[0][1617]=1616
+.[0][1618]=1617
+.[0][1619]=1618
+.[0][1620]=1619
+.[0][1621]=1620
+.[0][1622]=1621
+.[0][1623]=1622
+.[0][1624]=1623
+.[0][1625]=1624
+.[0][1626]=1625
+.[0][1627]=1626
+.[0][1628]=1627
+.[0][1629]=1628
+.[0][1630]=1629
+.[0][1631]=1630
+.[0][1632]=1631
+.[0][1633]=1632
+.[0][1634]=1633
+.[0][1635]=1634
+.[0][1636]=1635
+.[0][1637]=1636
+.[0][1638]=1637
+.[0][1639]=1638
+.[0][1640]=1639
+.[0][1641]=1640
+.[0][1642]=1641
+.[0][1643]=1642
+.[0][1644]=1643
+.[0][1645]=1644
+.[0][1646]=1645
+.[0][1647]=1646
+.[0][1648]=1647
+.[0][1649]=1648
+.[0][1650]=1649
+.[0][1651]=1650
+.[0][1652]=1651
+.[0][1653]=1652
+.[0][1654]=1653
+.[0][1655]=1654
+.[0][1656]=1655
+.[0][1657]=1656
+.[0][1658]=1657
+.[0][1659]=1658
+.[0][1660]=1659
+.[0][1661]=1660
+.[0][1662]=1661
+.[0][1663]=1662
+.[0][1664]=1663
+.[0][1665]=1664
+.[0][1666]=1665
+.[0][1667]=1666
+.[0][1668]=1667
+.[0][1669]=1668
+.[0][1670]=1669
+.[0][1671]=1670
+.[0][1672]=1671
+.[0][1673]=1672
+.[0][1674]=1673
+.[0][1675]=1674
+.[0][1676]=1675
+.[0][1677]=1676
+.[0][1678]=1677
+.[0][1679]=1678
+.[0][1680]=1679
+.[0][1681]=1680
+.[0][1682]=1681
+.[0][1683]=1682
+.[0][1684]=1683
+.[0][1685]=1684
+.[0][1686]=1685
+.[0][1687]=1686
+.[0][1688]=1687
+.[0][1689]=1688
+.[0][1690]=1689
+.[0][1691]=1690
+.[0][1692]=1691
+.[0][1693]=1692
+.[0][1694]=1693
+.[0][1695]=1694
+.[0][1696]=1695
+.[0][1697]=1696
+.[0][1698]=1697
+.[0][1699]=1698
+.[0][1700]=1699
+.[0][1701]=1700
+.[0][1702]=1701
+.[0][1703]=1702
+.[0][1704]=1703
+.[0][1705]=1704
+.[0][1706]=1705
+.[0][1707]=1706
+.[0][1708]=1707
+.[0][1709]=1708
+.[0][1710]=1709
+.[0][1711]=1710
+.[0][1712]=1711
+.[0][1713]=1712
+.[0][1714]=1713
+.[0][1715]=1714
+.[0][1716]=1715
+.[0][1717]=1716
+.[0][1718]=1717
+.[0][1719]=1718
+.[0][1720]=1719
+.[0][1721]=1720
+.[0][1722]=1721
+.[0][1723]=1722
+.[0][1724]=1723
+.[0][1725]=1724
+.[0][1726]=1725
+.[0][1727]=1726
+.[0][1728]=1727
+.[0][1729]=1728
+.[0][1730]=1729
+.[0][1731]=1730
+.[0][1732]=1731
+.[0][1733]=1732
+.[0][1734]=1733
+.[0][1735]=1734
+.[0][1736]=1735
+.[0][1737]=1736
+.[0][1738]=1737
+.[0][1739]=1738
+.[0][1740]=1739
+.[0][1741]=1740
+.[0][1742]=1741
+.[0][1743]=1742
+.[0][1744]=1743
+.[0][1745]=1744
+.[0][1746]=1745
+.[0][1747]=1746
+.[0][1748]=1747
+.[0][1749]=1748
+.[0][1750]=1749
+.[0][1751]=1750
+.[0][1752]=1751
+.[0][1753]=1752
+.[0][1754]=1753
+.[0][1755]=1754
+.[0][1756]=1755
+.[0][1757]=1756
+.[0][1758]=1757
+.[0][1759]=1758
+.[0][1760]=1759
+.[0][1761]=1760
+.[0][1762]=1761
+.[0][1763]=1762
+.[0][1764]=1763
+.[0][1765]=1764
+.[0][1766]=1765
+.[0][1767]=1766
+.[0][1768]=1767
+.[0][1769]=1768
+.[0][1770]=1769
+.[0][1771]=1770
+.[0][1772]=1771
+.[0][1773]=1772
+.[0][1774]=1773
+.[0][1775]=1774
+.[0][1776]=1775
+.[0][1777]=1776
+.[0][1778]=1777
+.[0][1779]=1778
+.[0][1780]=1779
+.[0][1781]=1780
+.[0][1782]=1781
+.[0][1783]=1782
+.[0][1784]=1783
+.[0][1785]=1784
+.[0][1786]=1785
+.[0][1787]=1786
+.[0][1788]=1787
+.[0][1789]=1788
+.[0][1790]=1789
+.[0][1791]=1790
+.[0][1792]=1791
+.[0][1793]=1792
+.[0][1794]=1793
+.[0][1795]=1794
+.[0][1796]=1795
+.[0][1797]=1796
+.[0][1798]=1797
+.[0][1799]=1798
+.[0][1800]=1799
+.[0][1801]=1800
+.[0][1802]=1801
+.[0][1803]=1802
+.[0][1804]=1803
+.[0][1805]=1804
+.[0][1806]=1805
+.[0][1807]=1806
+.[0][1808]=1807
+.[0][1809]=1808
+.[0][1810]=1809
+.[0][1811]=1810
+.[0][1812]=1811
+.[0][1813]=1812
+.[0][1814]=1813
+.[0][1815]=1814
+.[0][1816]=1815
+.[0][1817]=1816
+.[0][1818]=1817
+.[0][1819]=1818
+.[0][1820]=1819
+.[0][1821]=1820
+.[0][1822]=1821
+.[0][1823]=1822
+.[0][1824]=1823
+.[0][1825]=1824
+.[0][1826]=1825
+.[0][1827]=1826
+.[0][1828]=1827
+.[0][1829]=1828
+.[0][1830]=1829
+.[0][1831]=1830
+.[0][1832]=1831
+.[0][1833]=1832
+.[0][1834]=1833
+.[0][1835]=1834
+.[0][1836]=1835
+.[0][1837]=1836
+.[0][1838]=1837
+.[0][1839]=1838
+.[0][1840]=1839
+.[0][1841]=1840
+.[0][1842]=1841
+.[0][1843]=1842
+.[0][1844]=1843
+.[0][1845]=1844
+.[0][1846]=1845
+.[0][1847]=1846
+.[0][1848]=1847
+.[0][1849]=1848
+.[0][1850]=1849
+.[0][1851]=1850
+.[0][1852]=1851
+.[0][1853]=1852
+.[0][1854]=1853
+.[0][1855]=1854
+.[0][1856]=1855
+.[0][1857]=1856
+.[0][1858]=1857
+.[0][1859]=1858
+.[0][1860]=1859
+.[0][1861]=1860
+.[0][1862]=1861
+.[0][1863]=1862
+.[0][1864]=1863
+.[0][1865]=1864
+.[0][1866]=1865
+.[0][1867]=1866
+.[0][1868]=1867
+.[0][1869]=1868
+.[0][1870]=1869
+.[0][1871]=1870
+.[0][1872]=1871
+.[0][1873]=1872
+.[0][1874]=1873
+.[0][1875]=1874
+.[0][1876]=1875
+.[0][1877]=1876
+.[0][1878]=1877
+.[0][1879]=1878
+.[0][1880]=1879
+.[0][1881]=1880
+.[0][1882]=1881
+.[0][1883]=1882
+.[0][1884]=1883
+.[0][1885]=1884
+.[0][1886]=1885
+.[0][1887]=1886
+.[0][1888]=1887
+.[0][1889]=1888
+.[0][1890]=1889
+.[0][1891]=1890
+.[0][1892]=1891
+.[0][1893]=1892
+.[0][1894]=1893
+.[0][1895]=1894
+.[0][1896]=1895
+.[0][1897]=1896
+.[0][1898]=1897
+.[0][1899]=1898
+.[0][1900]=1899
+.[0][1901]=1900
+.[0][1902]=1901
+.[0][1903]=1902
+.[0][1904]=1903
+.[0][1905]=1904
+.[0][1906]=1905
+.[0][1907]=1906
+.[0][1908]=1907
+.[0][1909]=1908
+.[0][1910]=1909
+.[0][1911]=1910
+.[0][1912]=1911
+.[0][1913]=1912
+.[0][1914]=1913
+.[0][1915]=1914
+.[0][1916]=1915
+.[0][1917]=1916
+.[0][1918]=1917
+.[0][1919]=1918
+.[0][1920]=1919
+.[0][1921]=1920
+.[0][1922]=1921
+.[0][1923]=1922
+.[0][1924]=1923
+.[0][1925]=1924
+.[0][1926]=1925
+.[0][1927]=1926
+.[0][1928]=1927
+.[0][1929]=1928
+.[0][1930]=1929
+.[0][1931]=1930
+.[0][1932]=1931
+.[0][1933]=1932
+.[0][1934]=1933
+.[0][1935]=1934
+.[0][1936]=1935
+.[0][1937]=1936
+.[0][1938]=1937
+.[0][1939]=1938
+.[0][1940]=1939
+.[0][1941]=1940
+.[0][1942]=1941
+.[0][1943]=1942
+.[0][1944]=1943
+.[0][1945]=1944
+.[0][1946]=1945
+.[0][1947]=1946
+.[0][1948]=1947
+.[0][1949]=1948
+.[0][1950]=1949
+.[0][1951]=1950
+.[0][1952]=1951
+.[0][1953]=1952
+.[0][1954]=1953
+.[0][1955]=1954
+.[0][1956]=1955
+.[0][1957]=1956
+.[0][1958]=1957
+.[0][1959]=1958
+.[0][1960]=1959
+.[0][1961]=1960
+.[0][1962]=1961
+.[0][1963]=1962
+.[0][1964]=1963
+.[0][1965]=1964
+.[0][1966]=1965
+.[0][1967]=1966
+.[0][1968]=1967
+.[0][1969]=1968
+.[0][1970]=1969
+.[0][1971]=1970
+.[0][1972]=1971
+.[0][1973]=1972
+.[0][1974]=1973
+.[0][1975]=1974
+.[0][1976]=1975
+.[0][1977]=1976
+.[0][1978]=1977
+.[0][1979]=1978
+.[0][1980]=1979
+.[0][1981]=1980
+.[0][1982]=1981
+.[0][1983]=1982
+.[0][1984]=1983
+.[0][1985]=1984
+.[0][1986]=1985
+.[0][1987]=1986
+.[0][1988]=1987
+.[0][1989]=1988
+.[0][1990]=1989
+.[0][1991]=1990
+.[0][1992]=1991
+.[0][1993]=1992
+.[0][1994]=1993
+.[0][1995]=1994
+.[0][1996]=1995
+.[0][1997]=1996
+.[0][1998]=1997
+.[0][1999]=1998
+.[0][2000]=1999
+.[0][2001]=2000
+.[0][2002]=2001
+.[0][2003]=2002
+.[0][2004]=2003
+.[0][2005]=2004
+.[0][2006]=2005
+.[0][2007]=2006
+.[0][2008]=2007
+.[0][2009]=2008
+.[0][2010]=2009
+.[0][2011]=2010
+.[0][2012]=2011
+.[0][2013]=2012
+.[0][2014]=2013
+.[0][2015]=2014
+.[0][2016]=2015
+.[0][2017]=2016
+.[0][2018]=2017
+.[0][2019]=2018
+.[0][2020]=2019
+.[0][2021]=2020
+.[0][2022]=2021
+.[0][2023]=2022
+.[0][2024]=2023
+.[0][2025]=2024
+.[0][2026]=2025
+.[0][2027]=2026
+.[0][2028]=2027
+.[0][2029]=2028
+.[0][2030]=2029
+.[0][2031]=2030
+.[0][2032]=2031
+.[0][2033]=2032
+.[0][2034]=2033
+.[0][2035]=2034
+.[0][2036]=2035
+.[0][2037]=2036
+.[0][2038]=2037
+.[0][2039]=2038
+.[0][2040]=2039
+.[0][2041]=2040
+.[0][2042]=2041
+.[0][2043]=2042
+.[0][2044]=2043
+.[0][2045]=2044
+.[0][2046]=2045
+.[0][2047]=2046
+.[0][2048]=2047
+.[0][2049]=2048
+.[0][2050]=2049
+.[0][2051]=2050
+.[0][2052]=2051
+.[0][2053]=2052
+.[0][2054]=2053
+.[0][2055]=2054
+.[0][2056]=2055
+.[0][2057]=2056
+.[0][2058]=2057
+.[0][2059]=2058
+.[0][2060]=2059
+.[0][2061]=2060
+.[0][2062]=2061
+.[0][2063]=2062
+.[0][2064]=2063
+.[0][2065]=2064
+.[0][2066]=2065
+.[0][2067]=2066
+.[0][2068]=2067
+.[0][2069]=2068
+.[0][2070]=2069
+.[0][2071]=2070
+.[0][2072]=2071
+.[0][2073]=2072
+.[0][2074]=2073
+.[0][2075]=2074
+.[0][2076]=2075
+.[0][2077]=2076
+.[0][2078]=2077
+.[0][2079]=2078
+.[0][2080]=2079
+.[0][2081]=2080
+.[0][2082]=2081
+.[0][2083]=2082
+.[0][2084]=2083
+.[0][2085]=2084
+.[0][2086]=2085
+.[0][2087]=2086
+.[0][2088]=2087
+.[0][2089]=2088
+.[0][2090]=2089
+.[0][2091]=2090
+.[0][2092]=2091
+.[0][2093]=2092
+.[0][2094]=2093
+.[0][2095]=2094
+.[0][2096]=2095
+.[0][2097]=2096
+.[0][2098]=2097
+.[0][2099]=2098
+.[0][2100]=2099
+.[0][2101]=2100
+.[0][2102]=2101
+.[0][2103]=2102
+.[0][2104]=2103
+.[0][2105]=2104
+.[0][2106]=2105
+.[0][2107]=2106
+.[0][2108]=2107
+.[0][2109]=2108
+.[0][2110]=2109
+.[0][2111]=2110
+.[0][2112]=2111
+.[0][2113]=2112
+.[0][2114]=2113
+.[0][2115]=2114
+.[0][2116]=2115
+.[0][2117]=2116
+.[0][2118]=2117
+.[0][2119]=2118
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_array_07.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+[["A",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118]
+]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=123456789
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+0123456789
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=-123456789
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+-0123456789
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+.=1.2345678
+
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+1.2345678
+
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.="abcdef"
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+"abcdef"
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=true
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_06.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+true
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=false
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_07.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+false
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// C++ style comment
+.=null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_08.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// C++ style comment
+null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+/* C style comment
+ */
+.=null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_basic_09.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+/* C style comment
+ */
+null
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Comment for array
+.=[]
+// Comment within array
+.[0]="one-element"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_00.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,5 @@
+// Comment for array
+[
+   // Comment within array
+   "one-element"
+]
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,10 @@
+.={}
+// Comment for array
+.test=[]
+// Comment within array
+.test[0]={}
+.test[0].a="aaa"
+.test[1]={}
+.test[1].b="bbb"
+.test[2]={}
+.test[2].c="ccc"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,10 @@
+{
+    "test":
+    // Comment for array
+    [
+       // Comment within array
+       { "a" : "aaa" }, // Comment for a
+       { "b" : "bbb" }, // Comment for b
+       { "c" : "ccc" } // Comment for c
+    ]
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,23 @@
+.={}
+/* C-style comment
+
+    C-style-2 comment */
+.c-test={}
+.c-test.a=1
+/* Internal comment c-style */
+.c-test.b=2
+// C++-style comment
+.cpp-test={}
+// Multiline comment cpp-style
+// Second line
+.cpp-test.c=3
+// Comment before double
+.cpp-test.d=4.1
+// Comment before string
+.cpp-test.e="e-string"
+// Comment before true
+.cpp-test.f=true
+// Comment before false
+.cpp-test.g=false
+// Comment before null
+.cpp-test.h=null
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_comment_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,26 @@
+{
+   /* C-style comment
+
+    C-style-2 comment */
+   "c-test" : {
+      "a" : 1,
+      /* Internal comment c-style */
+      "b" : 2
+   },
+   // C++-style comment
+   "cpp-test" : {
+      // Multiline comment cpp-style
+      // Second line
+      "c" : 3,
+      // Comment before double
+      "d" : 4.1,
+      // Comment before string
+      "e" : "e-string",
+      // Comment before true
+      "f" : true,
+      // Comment before false
+      "g" : false,
+      // Comment before null
+      "h" : null
+   }
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,20 @@
+.={}
+.attribute=[]
+.attribute[0]="random"
+.attribute[1]="short"
+.attribute[2]="bold"
+.attribute[3]=12
+.attribute[4]={}
+.attribute[4].height=7
+.attribute[4].width=64
+.count=1234
+.name={}
+.name.aka="T.E.S.T."
+.name.id=123987
+.test={}
+.test.1={}
+.test.1.2={}
+.test.1.2.3={}
+.test.1.2.3.coord=[]
+.test.1.2.3.coord[0]=1
+.test.1.2.3.coord[1]=2
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_complex_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,17 @@
+{ 
+	"count" : 1234,
+	"name" : { "aka" : "T.E.S.T.", "id" : 123987 },
+	"attribute" : [ 
+		"random", 
+		"short", 
+		"bold", 
+		12, 
+		{ "height" : 7, "width" : 64 } 
+		],
+	"test": { "1" : 
+		{ "2" : 
+			{ "3" :  { "coord" : [ 1,2] } 
+			} 
+		}
+	}
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Max signed integer
+.=2147483647
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Max signed integer
+2147483647
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Min signed integer
+.=-2147483648
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Min signed integer
+-2147483648
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Max unsigned integer
+.=4294967295
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// Max unsigned integer
+4294967295
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// Min unsigned integer
+.=0
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// Min unsigned integer
+0
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=1
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+1
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=9223372036854775808
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_06_64bits.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+9223372036854775808
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=-9223372036854775808
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_07_64bits.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+-9223372036854775808
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.=18446744073709551615
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_integer_08_64bits.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+18446744073709551615
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2122 @@
+.=[]
+.[0]=[]
+.[0][0]="A"
+.[0][1]=0
+.[0][2]=1
+.[0][3]=2
+.[0][4]=3
+.[0][5]=4
+.[0][6]=5
+.[0][7]=6
+.[0][8]=7
+.[0][9]=8
+.[0][10]=9
+.[0][11]=10
+.[0][12]=11
+.[0][13]=12
+.[0][14]=13
+.[0][15]=14
+.[0][16]=15
+.[0][17]=16
+.[0][18]=17
+.[0][19]=18
+.[0][20]=19
+.[0][21]=20
+.[0][22]=21
+.[0][23]=22
+.[0][24]=23
+.[0][25]=24
+.[0][26]=25
+.[0][27]=26
+.[0][28]=27
+.[0][29]=28
+.[0][30]=29
+.[0][31]=30
+.[0][32]=31
+.[0][33]=32
+.[0][34]=33
+.[0][35]=34
+.[0][36]=35
+.[0][37]=36
+.[0][38]=37
+.[0][39]=38
+.[0][40]=39
+.[0][41]=40
+.[0][42]=41
+.[0][43]=42
+.[0][44]=43
+.[0][45]=44
+.[0][46]=45
+.[0][47]=46
+.[0][48]=47
+.[0][49]=48
+.[0][50]=49
+.[0][51]=50
+.[0][52]=51
+.[0][53]=52
+.[0][54]=53
+.[0][55]=54
+.[0][56]=55
+.[0][57]=56
+.[0][58]=57
+.[0][59]=58
+.[0][60]=59
+.[0][61]=60
+.[0][62]=61
+.[0][63]=62
+.[0][64]=63
+.[0][65]=64
+.[0][66]=65
+.[0][67]=66
+.[0][68]=67
+.[0][69]=68
+.[0][70]=69
+.[0][71]=70
+.[0][72]=71
+.[0][73]=72
+.[0][74]=73
+.[0][75]=74
+.[0][76]=75
+.[0][77]=76
+.[0][78]=77
+.[0][79]=78
+.[0][80]=79
+.[0][81]=80
+.[0][82]=81
+.[0][83]=82
+.[0][84]=83
+.[0][85]=84
+.[0][86]=85
+.[0][87]=86
+.[0][88]=87
+.[0][89]=88
+.[0][90]=89
+.[0][91]=90
+.[0][92]=91
+.[0][93]=92
+.[0][94]=93
+.[0][95]=94
+.[0][96]=95
+.[0][97]=96
+.[0][98]=97
+.[0][99]=98
+.[0][100]=99
+.[0][101]=100
+.[0][102]=101
+.[0][103]=102
+.[0][104]=103
+.[0][105]=104
+.[0][106]=105
+.[0][107]=106
+.[0][108]=107
+.[0][109]=108
+.[0][110]=109
+.[0][111]=110
+.[0][112]=111
+.[0][113]=112
+.[0][114]=113
+.[0][115]=114
+.[0][116]=115
+.[0][117]=116
+.[0][118]=117
+.[0][119]=118
+.[0][120]=119
+.[0][121]=120
+.[0][122]=121
+.[0][123]=122
+.[0][124]=123
+.[0][125]=124
+.[0][126]=125
+.[0][127]=126
+.[0][128]=127
+.[0][129]=128
+.[0][130]=129
+.[0][131]=130
+.[0][132]=131
+.[0][133]=132
+.[0][134]=133
+.[0][135]=134
+.[0][136]=135
+.[0][137]=136
+.[0][138]=137
+.[0][139]=138
+.[0][140]=139
+.[0][141]=140
+.[0][142]=141
+.[0][143]=142
+.[0][144]=143
+.[0][145]=144
+.[0][146]=145
+.[0][147]=146
+.[0][148]=147
+.[0][149]=148
+.[0][150]=149
+.[0][151]=150
+.[0][152]=151
+.[0][153]=152
+.[0][154]=153
+.[0][155]=154
+.[0][156]=155
+.[0][157]=156
+.[0][158]=157
+.[0][159]=158
+.[0][160]=159
+.[0][161]=160
+.[0][162]=161
+.[0][163]=162
+.[0][164]=163
+.[0][165]=164
+.[0][166]=165
+.[0][167]=166
+.[0][168]=167
+.[0][169]=168
+.[0][170]=169
+.[0][171]=170
+.[0][172]=171
+.[0][173]=172
+.[0][174]=173
+.[0][175]=174
+.[0][176]=175
+.[0][177]=176
+.[0][178]=177
+.[0][179]=178
+.[0][180]=179
+.[0][181]=180
+.[0][182]=181
+.[0][183]=182
+.[0][184]=183
+.[0][185]=184
+.[0][186]=185
+.[0][187]=186
+.[0][188]=187
+.[0][189]=188
+.[0][190]=189
+.[0][191]=190
+.[0][192]=191
+.[0][193]=192
+.[0][194]=193
+.[0][195]=194
+.[0][196]=195
+.[0][197]=196
+.[0][198]=197
+.[0][199]=198
+.[0][200]=199
+.[0][201]=200
+.[0][202]=201
+.[0][203]=202
+.[0][204]=203
+.[0][205]=204
+.[0][206]=205
+.[0][207]=206
+.[0][208]=207
+.[0][209]=208
+.[0][210]=209
+.[0][211]=210
+.[0][212]=211
+.[0][213]=212
+.[0][214]=213
+.[0][215]=214
+.[0][216]=215
+.[0][217]=216
+.[0][218]=217
+.[0][219]=218
+.[0][220]=219
+.[0][221]=220
+.[0][222]=221
+.[0][223]=222
+.[0][224]=223
+.[0][225]=224
+.[0][226]=225
+.[0][227]=226
+.[0][228]=227
+.[0][229]=228
+.[0][230]=229
+.[0][231]=230
+.[0][232]=231
+.[0][233]=232
+.[0][234]=233
+.[0][235]=234
+.[0][236]=235
+.[0][237]=236
+.[0][238]=237
+.[0][239]=238
+.[0][240]=239
+.[0][241]=240
+.[0][242]=241
+.[0][243]=242
+.[0][244]=243
+.[0][245]=244
+.[0][246]=245
+.[0][247]=246
+.[0][248]=247
+.[0][249]=248
+.[0][250]=249
+.[0][251]=250
+.[0][252]=251
+.[0][253]=252
+.[0][254]=253
+.[0][255]=254
+.[0][256]=255
+.[0][257]=256
+.[0][258]=257
+.[0][259]=258
+.[0][260]=259
+.[0][261]=260
+.[0][262]=261
+.[0][263]=262
+.[0][264]=263
+.[0][265]=264
+.[0][266]=265
+.[0][267]=266
+.[0][268]=267
+.[0][269]=268
+.[0][270]=269
+.[0][271]=270
+.[0][272]=271
+.[0][273]=272
+.[0][274]=273
+.[0][275]=274
+.[0][276]=275
+.[0][277]=276
+.[0][278]=277
+.[0][279]=278
+.[0][280]=279
+.[0][281]=280
+.[0][282]=281
+.[0][283]=282
+.[0][284]=283
+.[0][285]=284
+.[0][286]=285
+.[0][287]=286
+.[0][288]=287
+.[0][289]=288
+.[0][290]=289
+.[0][291]=290
+.[0][292]=291
+.[0][293]=292
+.[0][294]=293
+.[0][295]=294
+.[0][296]=295
+.[0][297]=296
+.[0][298]=297
+.[0][299]=298
+.[0][300]=299
+.[0][301]=300
+.[0][302]=301
+.[0][303]=302
+.[0][304]=303
+.[0][305]=304
+.[0][306]=305
+.[0][307]=306
+.[0][308]=307
+.[0][309]=308
+.[0][310]=309
+.[0][311]=310
+.[0][312]=311
+.[0][313]=312
+.[0][314]=313
+.[0][315]=314
+.[0][316]=315
+.[0][317]=316
+.[0][318]=317
+.[0][319]=318
+.[0][320]=319
+.[0][321]=320
+.[0][322]=321
+.[0][323]=322
+.[0][324]=323
+.[0][325]=324
+.[0][326]=325
+.[0][327]=326
+.[0][328]=327
+.[0][329]=328
+.[0][330]=329
+.[0][331]=330
+.[0][332]=331
+.[0][333]=332
+.[0][334]=333
+.[0][335]=334
+.[0][336]=335
+.[0][337]=336
+.[0][338]=337
+.[0][339]=338
+.[0][340]=339
+.[0][341]=340
+.[0][342]=341
+.[0][343]=342
+.[0][344]=343
+.[0][345]=344
+.[0][346]=345
+.[0][347]=346
+.[0][348]=347
+.[0][349]=348
+.[0][350]=349
+.[0][351]=350
+.[0][352]=351
+.[0][353]=352
+.[0][354]=353
+.[0][355]=354
+.[0][356]=355
+.[0][357]=356
+.[0][358]=357
+.[0][359]=358
+.[0][360]=359
+.[0][361]=360
+.[0][362]=361
+.[0][363]=362
+.[0][364]=363
+.[0][365]=364
+.[0][366]=365
+.[0][367]=366
+.[0][368]=367
+.[0][369]=368
+.[0][370]=369
+.[0][371]=370
+.[0][372]=371
+.[0][373]=372
+.[0][374]=373
+.[0][375]=374
+.[0][376]=375
+.[0][377]=376
+.[0][378]=377
+.[0][379]=378
+.[0][380]=379
+.[0][381]=380
+.[0][382]=381
+.[0][383]=382
+.[0][384]=383
+.[0][385]=384
+.[0][386]=385
+.[0][387]=386
+.[0][388]=387
+.[0][389]=388
+.[0][390]=389
+.[0][391]=390
+.[0][392]=391
+.[0][393]=392
+.[0][394]=393
+.[0][395]=394
+.[0][396]=395
+.[0][397]=396
+.[0][398]=397
+.[0][399]=398
+.[0][400]=399
+.[0][401]=400
+.[0][402]=401
+.[0][403]=402
+.[0][404]=403
+.[0][405]=404
+.[0][406]=405
+.[0][407]=406
+.[0][408]=407
+.[0][409]=408
+.[0][410]=409
+.[0][411]=410
+.[0][412]=411
+.[0][413]=412
+.[0][414]=413
+.[0][415]=414
+.[0][416]=415
+.[0][417]=416
+.[0][418]=417
+.[0][419]=418
+.[0][420]=419
+.[0][421]=420
+.[0][422]=421
+.[0][423]=422
+.[0][424]=423
+.[0][425]=424
+.[0][426]=425
+.[0][427]=426
+.[0][428]=427
+.[0][429]=428
+.[0][430]=429
+.[0][431]=430
+.[0][432]=431
+.[0][433]=432
+.[0][434]=433
+.[0][435]=434
+.[0][436]=435
+.[0][437]=436
+.[0][438]=437
+.[0][439]=438
+.[0][440]=439
+.[0][441]=440
+.[0][442]=441
+.[0][443]=442
+.[0][444]=443
+.[0][445]=444
+.[0][446]=445
+.[0][447]=446
+.[0][448]=447
+.[0][449]=448
+.[0][450]=449
+.[0][451]=450
+.[0][452]=451
+.[0][453]=452
+.[0][454]=453
+.[0][455]=454
+.[0][456]=455
+.[0][457]=456
+.[0][458]=457
+.[0][459]=458
+.[0][460]=459
+.[0][461]=460
+.[0][462]=461
+.[0][463]=462
+.[0][464]=463
+.[0][465]=464
+.[0][466]=465
+.[0][467]=466
+.[0][468]=467
+.[0][469]=468
+.[0][470]=469
+.[0][471]=470
+.[0][472]=471
+.[0][473]=472
+.[0][474]=473
+.[0][475]=474
+.[0][476]=475
+.[0][477]=476
+.[0][478]=477
+.[0][479]=478
+.[0][480]=479
+.[0][481]=480
+.[0][482]=481
+.[0][483]=482
+.[0][484]=483
+.[0][485]=484
+.[0][486]=485
+.[0][487]=486
+.[0][488]=487
+.[0][489]=488
+.[0][490]=489
+.[0][491]=490
+.[0][492]=491
+.[0][493]=492
+.[0][494]=493
+.[0][495]=494
+.[0][496]=495
+.[0][497]=496
+.[0][498]=497
+.[0][499]=498
+.[0][500]=499
+.[0][501]=500
+.[0][502]=501
+.[0][503]=502
+.[0][504]=503
+.[0][505]=504
+.[0][506]=505
+.[0][507]=506
+.[0][508]=507
+.[0][509]=508
+.[0][510]=509
+.[0][511]=510
+.[0][512]=511
+.[0][513]=512
+.[0][514]=513
+.[0][515]=514
+.[0][516]=515
+.[0][517]=516
+.[0][518]=517
+.[0][519]=518
+.[0][520]=519
+.[0][521]=520
+.[0][522]=521
+.[0][523]=522
+.[0][524]=523
+.[0][525]=524
+.[0][526]=525
+.[0][527]=526
+.[0][528]=527
+.[0][529]=528
+.[0][530]=529
+.[0][531]=530
+.[0][532]=531
+.[0][533]=532
+.[0][534]=533
+.[0][535]=534
+.[0][536]=535
+.[0][537]=536
+.[0][538]=537
+.[0][539]=538
+.[0][540]=539
+.[0][541]=540
+.[0][542]=541
+.[0][543]=542
+.[0][544]=543
+.[0][545]=544
+.[0][546]=545
+.[0][547]=546
+.[0][548]=547
+.[0][549]=548
+.[0][550]=549
+.[0][551]=550
+.[0][552]=551
+.[0][553]=552
+.[0][554]=553
+.[0][555]=554
+.[0][556]=555
+.[0][557]=556
+.[0][558]=557
+.[0][559]=558
+.[0][560]=559
+.[0][561]=560
+.[0][562]=561
+.[0][563]=562
+.[0][564]=563
+.[0][565]=564
+.[0][566]=565
+.[0][567]=566
+.[0][568]=567
+.[0][569]=568
+.[0][570]=569
+.[0][571]=570
+.[0][572]=571
+.[0][573]=572
+.[0][574]=573
+.[0][575]=574
+.[0][576]=575
+.[0][577]=576
+.[0][578]=577
+.[0][579]=578
+.[0][580]=579
+.[0][581]=580
+.[0][582]=581
+.[0][583]=582
+.[0][584]=583
+.[0][585]=584
+.[0][586]=585
+.[0][587]=586
+.[0][588]=587
+.[0][589]=588
+.[0][590]=589
+.[0][591]=590
+.[0][592]=591
+.[0][593]=592
+.[0][594]=593
+.[0][595]=594
+.[0][596]=595
+.[0][597]=596
+.[0][598]=597
+.[0][599]=598
+.[0][600]=599
+.[0][601]=600
+.[0][602]=601
+.[0][603]=602
+.[0][604]=603
+.[0][605]=604
+.[0][606]=605
+.[0][607]=606
+.[0][608]=607
+.[0][609]=608
+.[0][610]=609
+.[0][611]=610
+.[0][612]=611
+.[0][613]=612
+.[0][614]=613
+.[0][615]=614
+.[0][616]=615
+.[0][617]=616
+.[0][618]=617
+.[0][619]=618
+.[0][620]=619
+.[0][621]=620
+.[0][622]=621
+.[0][623]=622
+.[0][624]=623
+.[0][625]=624
+.[0][626]=625
+.[0][627]=626
+.[0][628]=627
+.[0][629]=628
+.[0][630]=629
+.[0][631]=630
+.[0][632]=631
+.[0][633]=632
+.[0][634]=633
+.[0][635]=634
+.[0][636]=635
+.[0][637]=636
+.[0][638]=637
+.[0][639]=638
+.[0][640]=639
+.[0][641]=640
+.[0][642]=641
+.[0][643]=642
+.[0][644]=643
+.[0][645]=644
+.[0][646]=645
+.[0][647]=646
+.[0][648]=647
+.[0][649]=648
+.[0][650]=649
+.[0][651]=650
+.[0][652]=651
+.[0][653]=652
+.[0][654]=653
+.[0][655]=654
+.[0][656]=655
+.[0][657]=656
+.[0][658]=657
+.[0][659]=658
+.[0][660]=659
+.[0][661]=660
+.[0][662]=661
+.[0][663]=662
+.[0][664]=663
+.[0][665]=664
+.[0][666]=665
+.[0][667]=666
+.[0][668]=667
+.[0][669]=668
+.[0][670]=669
+.[0][671]=670
+.[0][672]=671
+.[0][673]=672
+.[0][674]=673
+.[0][675]=674
+.[0][676]=675
+.[0][677]=676
+.[0][678]=677
+.[0][679]=678
+.[0][680]=679
+.[0][681]=680
+.[0][682]=681
+.[0][683]=682
+.[0][684]=683
+.[0][685]=684
+.[0][686]=685
+.[0][687]=686
+.[0][688]=687
+.[0][689]=688
+.[0][690]=689
+.[0][691]=690
+.[0][692]=691
+.[0][693]=692
+.[0][694]=693
+.[0][695]=694
+.[0][696]=695
+.[0][697]=696
+.[0][698]=697
+.[0][699]=698
+.[0][700]=699
+.[0][701]=700
+.[0][702]=701
+.[0][703]=702
+.[0][704]=703
+.[0][705]=704
+.[0][706]=705
+.[0][707]=706
+.[0][708]=707
+.[0][709]=708
+.[0][710]=709
+.[0][711]=710
+.[0][712]=711
+.[0][713]=712
+.[0][714]=713
+.[0][715]=714
+.[0][716]=715
+.[0][717]=716
+.[0][718]=717
+.[0][719]=718
+.[0][720]=719
+.[0][721]=720
+.[0][722]=721
+.[0][723]=722
+.[0][724]=723
+.[0][725]=724
+.[0][726]=725
+.[0][727]=726
+.[0][728]=727
+.[0][729]=728
+.[0][730]=729
+.[0][731]=730
+.[0][732]=731
+.[0][733]=732
+.[0][734]=733
+.[0][735]=734
+.[0][736]=735
+.[0][737]=736
+.[0][738]=737
+.[0][739]=738
+.[0][740]=739
+.[0][741]=740
+.[0][742]=741
+.[0][743]=742
+.[0][744]=743
+.[0][745]=744
+.[0][746]=745
+.[0][747]=746
+.[0][748]=747
+.[0][749]=748
+.[0][750]=749
+.[0][751]=750
+.[0][752]=751
+.[0][753]=752
+.[0][754]=753
+.[0][755]=754
+.[0][756]=755
+.[0][757]=756
+.[0][758]=757
+.[0][759]=758
+.[0][760]=759
+.[0][761]=760
+.[0][762]=761
+.[0][763]=762
+.[0][764]=763
+.[0][765]=764
+.[0][766]=765
+.[0][767]=766
+.[0][768]=767
+.[0][769]=768
+.[0][770]=769
+.[0][771]=770
+.[0][772]=771
+.[0][773]=772
+.[0][774]=773
+.[0][775]=774
+.[0][776]=775
+.[0][777]=776
+.[0][778]=777
+.[0][779]=778
+.[0][780]=779
+.[0][781]=780
+.[0][782]=781
+.[0][783]=782
+.[0][784]=783
+.[0][785]=784
+.[0][786]=785
+.[0][787]=786
+.[0][788]=787
+.[0][789]=788
+.[0][790]=789
+.[0][791]=790
+.[0][792]=791
+.[0][793]=792
+.[0][794]=793
+.[0][795]=794
+.[0][796]=795
+.[0][797]=796
+.[0][798]=797
+.[0][799]=798
+.[0][800]=799
+.[0][801]=800
+.[0][802]=801
+.[0][803]=802
+.[0][804]=803
+.[0][805]=804
+.[0][806]=805
+.[0][807]=806
+.[0][808]=807
+.[0][809]=808
+.[0][810]=809
+.[0][811]=810
+.[0][812]=811
+.[0][813]=812
+.[0][814]=813
+.[0][815]=814
+.[0][816]=815
+.[0][817]=816
+.[0][818]=817
+.[0][819]=818
+.[0][820]=819
+.[0][821]=820
+.[0][822]=821
+.[0][823]=822
+.[0][824]=823
+.[0][825]=824
+.[0][826]=825
+.[0][827]=826
+.[0][828]=827
+.[0][829]=828
+.[0][830]=829
+.[0][831]=830
+.[0][832]=831
+.[0][833]=832
+.[0][834]=833
+.[0][835]=834
+.[0][836]=835
+.[0][837]=836
+.[0][838]=837
+.[0][839]=838
+.[0][840]=839
+.[0][841]=840
+.[0][842]=841
+.[0][843]=842
+.[0][844]=843
+.[0][845]=844
+.[0][846]=845
+.[0][847]=846
+.[0][848]=847
+.[0][849]=848
+.[0][850]=849
+.[0][851]=850
+.[0][852]=851
+.[0][853]=852
+.[0][854]=853
+.[0][855]=854
+.[0][856]=855
+.[0][857]=856
+.[0][858]=857
+.[0][859]=858
+.[0][860]=859
+.[0][861]=860
+.[0][862]=861
+.[0][863]=862
+.[0][864]=863
+.[0][865]=864
+.[0][866]=865
+.[0][867]=866
+.[0][868]=867
+.[0][869]=868
+.[0][870]=869
+.[0][871]=870
+.[0][872]=871
+.[0][873]=872
+.[0][874]=873
+.[0][875]=874
+.[0][876]=875
+.[0][877]=876
+.[0][878]=877
+.[0][879]=878
+.[0][880]=879
+.[0][881]=880
+.[0][882]=881
+.[0][883]=882
+.[0][884]=883
+.[0][885]=884
+.[0][886]=885
+.[0][887]=886
+.[0][888]=887
+.[0][889]=888
+.[0][890]=889
+.[0][891]=890
+.[0][892]=891
+.[0][893]=892
+.[0][894]=893
+.[0][895]=894
+.[0][896]=895
+.[0][897]=896
+.[0][898]=897
+.[0][899]=898
+.[0][900]=899
+.[0][901]=900
+.[0][902]=901
+.[0][903]=902
+.[0][904]=903
+.[0][905]=904
+.[0][906]=905
+.[0][907]=906
+.[0][908]=907
+.[0][909]=908
+.[0][910]=909
+.[0][911]=910
+.[0][912]=911
+.[0][913]=912
+.[0][914]=913
+.[0][915]=914
+.[0][916]=915
+.[0][917]=916
+.[0][918]=917
+.[0][919]=918
+.[0][920]=919
+.[0][921]=920
+.[0][922]=921
+.[0][923]=922
+.[0][924]=923
+.[0][925]=924
+.[0][926]=925
+.[0][927]=926
+.[0][928]=927
+.[0][929]=928
+.[0][930]=929
+.[0][931]=930
+.[0][932]=931
+.[0][933]=932
+.[0][934]=933
+.[0][935]=934
+.[0][936]=935
+.[0][937]=936
+.[0][938]=937
+.[0][939]=938
+.[0][940]=939
+.[0][941]=940
+.[0][942]=941
+.[0][943]=942
+.[0][944]=943
+.[0][945]=944
+.[0][946]=945
+.[0][947]=946
+.[0][948]=947
+.[0][949]=948
+.[0][950]=949
+.[0][951]=950
+.[0][952]=951
+.[0][953]=952
+.[0][954]=953
+.[0][955]=954
+.[0][956]=955
+.[0][957]=956
+.[0][958]=957
+.[0][959]=958
+.[0][960]=959
+.[0][961]=960
+.[0][962]=961
+.[0][963]=962
+.[0][964]=963
+.[0][965]=964
+.[0][966]=965
+.[0][967]=966
+.[0][968]=967
+.[0][969]=968
+.[0][970]=969
+.[0][971]=970
+.[0][972]=971
+.[0][973]=972
+.[0][974]=973
+.[0][975]=974
+.[0][976]=975
+.[0][977]=976
+.[0][978]=977
+.[0][979]=978
+.[0][980]=979
+.[0][981]=980
+.[0][982]=981
+.[0][983]=982
+.[0][984]=983
+.[0][985]=984
+.[0][986]=985
+.[0][987]=986
+.[0][988]=987
+.[0][989]=988
+.[0][990]=989
+.[0][991]=990
+.[0][992]=991
+.[0][993]=992
+.[0][994]=993
+.[0][995]=994
+.[0][996]=995
+.[0][997]=996
+.[0][998]=997
+.[0][999]=998
+.[0][1000]=999
+.[0][1001]=1000
+.[0][1002]=1001
+.[0][1003]=1002
+.[0][1004]=1003
+.[0][1005]=1004
+.[0][1006]=1005
+.[0][1007]=1006
+.[0][1008]=1007
+.[0][1009]=1008
+.[0][1010]=1009
+.[0][1011]=1010
+.[0][1012]=1011
+.[0][1013]=1012
+.[0][1014]=1013
+.[0][1015]=1014
+.[0][1016]=1015
+.[0][1017]=1016
+.[0][1018]=1017
+.[0][1019]=1018
+.[0][1020]=1019
+.[0][1021]=1020
+.[0][1022]=1021
+.[0][1023]=1022
+.[0][1024]=1023
+.[0][1025]=1024
+.[0][1026]=1025
+.[0][1027]=1026
+.[0][1028]=1027
+.[0][1029]=1028
+.[0][1030]=1029
+.[0][1031]=1030
+.[0][1032]=1031
+.[0][1033]=1032
+.[0][1034]=1033
+.[0][1035]=1034
+.[0][1036]=1035
+.[0][1037]=1036
+.[0][1038]=1037
+.[0][1039]=1038
+.[0][1040]=1039
+.[0][1041]=1040
+.[0][1042]=1041
+.[0][1043]=1042
+.[0][1044]=1043
+.[0][1045]=1044
+.[0][1046]=1045
+.[0][1047]=1046
+.[0][1048]=1047
+.[0][1049]=1048
+.[0][1050]=1049
+.[0][1051]=1050
+.[0][1052]=1051
+.[0][1053]=1052
+.[0][1054]=1053
+.[0][1055]=1054
+.[0][1056]=1055
+.[0][1057]=1056
+.[0][1058]=1057
+.[0][1059]=1058
+.[0][1060]=1059
+.[0][1061]=1060
+.[0][1062]=1061
+.[0][1063]=1062
+.[0][1064]=1063
+.[0][1065]=1064
+.[0][1066]=1065
+.[0][1067]=1066
+.[0][1068]=1067
+.[0][1069]=1068
+.[0][1070]=1069
+.[0][1071]=1070
+.[0][1072]=1071
+.[0][1073]=1072
+.[0][1074]=1073
+.[0][1075]=1074
+.[0][1076]=1075
+.[0][1077]=1076
+.[0][1078]=1077
+.[0][1079]=1078
+.[0][1080]=1079
+.[0][1081]=1080
+.[0][1082]=1081
+.[0][1083]=1082
+.[0][1084]=1083
+.[0][1085]=1084
+.[0][1086]=1085
+.[0][1087]=1086
+.[0][1088]=1087
+.[0][1089]=1088
+.[0][1090]=1089
+.[0][1091]=1090
+.[0][1092]=1091
+.[0][1093]=1092
+.[0][1094]=1093
+.[0][1095]=1094
+.[0][1096]=1095
+.[0][1097]=1096
+.[0][1098]=1097
+.[0][1099]=1098
+.[0][1100]=1099
+.[0][1101]=1100
+.[0][1102]=1101
+.[0][1103]=1102
+.[0][1104]=1103
+.[0][1105]=1104
+.[0][1106]=1105
+.[0][1107]=1106
+.[0][1108]=1107
+.[0][1109]=1108
+.[0][1110]=1109
+.[0][1111]=1110
+.[0][1112]=1111
+.[0][1113]=1112
+.[0][1114]=1113
+.[0][1115]=1114
+.[0][1116]=1115
+.[0][1117]=1116
+.[0][1118]=1117
+.[0][1119]=1118
+.[0][1120]=1119
+.[0][1121]=1120
+.[0][1122]=1121
+.[0][1123]=1122
+.[0][1124]=1123
+.[0][1125]=1124
+.[0][1126]=1125
+.[0][1127]=1126
+.[0][1128]=1127
+.[0][1129]=1128
+.[0][1130]=1129
+.[0][1131]=1130
+.[0][1132]=1131
+.[0][1133]=1132
+.[0][1134]=1133
+.[0][1135]=1134
+.[0][1136]=1135
+.[0][1137]=1136
+.[0][1138]=1137
+.[0][1139]=1138
+.[0][1140]=1139
+.[0][1141]=1140
+.[0][1142]=1141
+.[0][1143]=1142
+.[0][1144]=1143
+.[0][1145]=1144
+.[0][1146]=1145
+.[0][1147]=1146
+.[0][1148]=1147
+.[0][1149]=1148
+.[0][1150]=1149
+.[0][1151]=1150
+.[0][1152]=1151
+.[0][1153]=1152
+.[0][1154]=1153
+.[0][1155]=1154
+.[0][1156]=1155
+.[0][1157]=1156
+.[0][1158]=1157
+.[0][1159]=1158
+.[0][1160]=1159
+.[0][1161]=1160
+.[0][1162]=1161
+.[0][1163]=1162
+.[0][1164]=1163
+.[0][1165]=1164
+.[0][1166]=1165
+.[0][1167]=1166
+.[0][1168]=1167
+.[0][1169]=1168
+.[0][1170]=1169
+.[0][1171]=1170
+.[0][1172]=1171
+.[0][1173]=1172
+.[0][1174]=1173
+.[0][1175]=1174
+.[0][1176]=1175
+.[0][1177]=1176
+.[0][1178]=1177
+.[0][1179]=1178
+.[0][1180]=1179
+.[0][1181]=1180
+.[0][1182]=1181
+.[0][1183]=1182
+.[0][1184]=1183
+.[0][1185]=1184
+.[0][1186]=1185
+.[0][1187]=1186
+.[0][1188]=1187
+.[0][1189]=1188
+.[0][1190]=1189
+.[0][1191]=1190
+.[0][1192]=1191
+.[0][1193]=1192
+.[0][1194]=1193
+.[0][1195]=1194
+.[0][1196]=1195
+.[0][1197]=1196
+.[0][1198]=1197
+.[0][1199]=1198
+.[0][1200]=1199
+.[0][1201]=1200
+.[0][1202]=1201
+.[0][1203]=1202
+.[0][1204]=1203
+.[0][1205]=1204
+.[0][1206]=1205
+.[0][1207]=1206
+.[0][1208]=1207
+.[0][1209]=1208
+.[0][1210]=1209
+.[0][1211]=1210
+.[0][1212]=1211
+.[0][1213]=1212
+.[0][1214]=1213
+.[0][1215]=1214
+.[0][1216]=1215
+.[0][1217]=1216
+.[0][1218]=1217
+.[0][1219]=1218
+.[0][1220]=1219
+.[0][1221]=1220
+.[0][1222]=1221
+.[0][1223]=1222
+.[0][1224]=1223
+.[0][1225]=1224
+.[0][1226]=1225
+.[0][1227]=1226
+.[0][1228]=1227
+.[0][1229]=1228
+.[0][1230]=1229
+.[0][1231]=1230
+.[0][1232]=1231
+.[0][1233]=1232
+.[0][1234]=1233
+.[0][1235]=1234
+.[0][1236]=1235
+.[0][1237]=1236
+.[0][1238]=1237
+.[0][1239]=1238
+.[0][1240]=1239
+.[0][1241]=1240
+.[0][1242]=1241
+.[0][1243]=1242
+.[0][1244]=1243
+.[0][1245]=1244
+.[0][1246]=1245
+.[0][1247]=1246
+.[0][1248]=1247
+.[0][1249]=1248
+.[0][1250]=1249
+.[0][1251]=1250
+.[0][1252]=1251
+.[0][1253]=1252
+.[0][1254]=1253
+.[0][1255]=1254
+.[0][1256]=1255
+.[0][1257]=1256
+.[0][1258]=1257
+.[0][1259]=1258
+.[0][1260]=1259
+.[0][1261]=1260
+.[0][1262]=1261
+.[0][1263]=1262
+.[0][1264]=1263
+.[0][1265]=1264
+.[0][1266]=1265
+.[0][1267]=1266
+.[0][1268]=1267
+.[0][1269]=1268
+.[0][1270]=1269
+.[0][1271]=1270
+.[0][1272]=1271
+.[0][1273]=1272
+.[0][1274]=1273
+.[0][1275]=1274
+.[0][1276]=1275
+.[0][1277]=1276
+.[0][1278]=1277
+.[0][1279]=1278
+.[0][1280]=1279
+.[0][1281]=1280
+.[0][1282]=1281
+.[0][1283]=1282
+.[0][1284]=1283
+.[0][1285]=1284
+.[0][1286]=1285
+.[0][1287]=1286
+.[0][1288]=1287
+.[0][1289]=1288
+.[0][1290]=1289
+.[0][1291]=1290
+.[0][1292]=1291
+.[0][1293]=1292
+.[0][1294]=1293
+.[0][1295]=1294
+.[0][1296]=1295
+.[0][1297]=1296
+.[0][1298]=1297
+.[0][1299]=1298
+.[0][1300]=1299
+.[0][1301]=1300
+.[0][1302]=1301
+.[0][1303]=1302
+.[0][1304]=1303
+.[0][1305]=1304
+.[0][1306]=1305
+.[0][1307]=1306
+.[0][1308]=1307
+.[0][1309]=1308
+.[0][1310]=1309
+.[0][1311]=1310
+.[0][1312]=1311
+.[0][1313]=1312
+.[0][1314]=1313
+.[0][1315]=1314
+.[0][1316]=1315
+.[0][1317]=1316
+.[0][1318]=1317
+.[0][1319]=1318
+.[0][1320]=1319
+.[0][1321]=1320
+.[0][1322]=1321
+.[0][1323]=1322
+.[0][1324]=1323
+.[0][1325]=1324
+.[0][1326]=1325
+.[0][1327]=1326
+.[0][1328]=1327
+.[0][1329]=1328
+.[0][1330]=1329
+.[0][1331]=1330
+.[0][1332]=1331
+.[0][1333]=1332
+.[0][1334]=1333
+.[0][1335]=1334
+.[0][1336]=1335
+.[0][1337]=1336
+.[0][1338]=1337
+.[0][1339]=1338
+.[0][1340]=1339
+.[0][1341]=1340
+.[0][1342]=1341
+.[0][1343]=1342
+.[0][1344]=1343
+.[0][1345]=1344
+.[0][1346]=1345
+.[0][1347]=1346
+.[0][1348]=1347
+.[0][1349]=1348
+.[0][1350]=1349
+.[0][1351]=1350
+.[0][1352]=1351
+.[0][1353]=1352
+.[0][1354]=1353
+.[0][1355]=1354
+.[0][1356]=1355
+.[0][1357]=1356
+.[0][1358]=1357
+.[0][1359]=1358
+.[0][1360]=1359
+.[0][1361]=1360
+.[0][1362]=1361
+.[0][1363]=1362
+.[0][1364]=1363
+.[0][1365]=1364
+.[0][1366]=1365
+.[0][1367]=1366
+.[0][1368]=1367
+.[0][1369]=1368
+.[0][1370]=1369
+.[0][1371]=1370
+.[0][1372]=1371
+.[0][1373]=1372
+.[0][1374]=1373
+.[0][1375]=1374
+.[0][1376]=1375
+.[0][1377]=1376
+.[0][1378]=1377
+.[0][1379]=1378
+.[0][1380]=1379
+.[0][1381]=1380
+.[0][1382]=1381
+.[0][1383]=1382
+.[0][1384]=1383
+.[0][1385]=1384
+.[0][1386]=1385
+.[0][1387]=1386
+.[0][1388]=1387
+.[0][1389]=1388
+.[0][1390]=1389
+.[0][1391]=1390
+.[0][1392]=1391
+.[0][1393]=1392
+.[0][1394]=1393
+.[0][1395]=1394
+.[0][1396]=1395
+.[0][1397]=1396
+.[0][1398]=1397
+.[0][1399]=1398
+.[0][1400]=1399
+.[0][1401]=1400
+.[0][1402]=1401
+.[0][1403]=1402
+.[0][1404]=1403
+.[0][1405]=1404
+.[0][1406]=1405
+.[0][1407]=1406
+.[0][1408]=1407
+.[0][1409]=1408
+.[0][1410]=1409
+.[0][1411]=1410
+.[0][1412]=1411
+.[0][1413]=1412
+.[0][1414]=1413
+.[0][1415]=1414
+.[0][1416]=1415
+.[0][1417]=1416
+.[0][1418]=1417
+.[0][1419]=1418
+.[0][1420]=1419
+.[0][1421]=1420
+.[0][1422]=1421
+.[0][1423]=1422
+.[0][1424]=1423
+.[0][1425]=1424
+.[0][1426]=1425
+.[0][1427]=1426
+.[0][1428]=1427
+.[0][1429]=1428
+.[0][1430]=1429
+.[0][1431]=1430
+.[0][1432]=1431
+.[0][1433]=1432
+.[0][1434]=1433
+.[0][1435]=1434
+.[0][1436]=1435
+.[0][1437]=1436
+.[0][1438]=1437
+.[0][1439]=1438
+.[0][1440]=1439
+.[0][1441]=1440
+.[0][1442]=1441
+.[0][1443]=1442
+.[0][1444]=1443
+.[0][1445]=1444
+.[0][1446]=1445
+.[0][1447]=1446
+.[0][1448]=1447
+.[0][1449]=1448
+.[0][1450]=1449
+.[0][1451]=1450
+.[0][1452]=1451
+.[0][1453]=1452
+.[0][1454]=1453
+.[0][1455]=1454
+.[0][1456]=1455
+.[0][1457]=1456
+.[0][1458]=1457
+.[0][1459]=1458
+.[0][1460]=1459
+.[0][1461]=1460
+.[0][1462]=1461
+.[0][1463]=1462
+.[0][1464]=1463
+.[0][1465]=1464
+.[0][1466]=1465
+.[0][1467]=1466
+.[0][1468]=1467
+.[0][1469]=1468
+.[0][1470]=1469
+.[0][1471]=1470
+.[0][1472]=1471
+.[0][1473]=1472
+.[0][1474]=1473
+.[0][1475]=1474
+.[0][1476]=1475
+.[0][1477]=1476
+.[0][1478]=1477
+.[0][1479]=1478
+.[0][1480]=1479
+.[0][1481]=1480
+.[0][1482]=1481
+.[0][1483]=1482
+.[0][1484]=1483
+.[0][1485]=1484
+.[0][1486]=1485
+.[0][1487]=1486
+.[0][1488]=1487
+.[0][1489]=1488
+.[0][1490]=1489
+.[0][1491]=1490
+.[0][1492]=1491
+.[0][1493]=1492
+.[0][1494]=1493
+.[0][1495]=1494
+.[0][1496]=1495
+.[0][1497]=1496
+.[0][1498]=1497
+.[0][1499]=1498
+.[0][1500]=1499
+.[0][1501]=1500
+.[0][1502]=1501
+.[0][1503]=1502
+.[0][1504]=1503
+.[0][1505]=1504
+.[0][1506]=1505
+.[0][1507]=1506
+.[0][1508]=1507
+.[0][1509]=1508
+.[0][1510]=1509
+.[0][1511]=1510
+.[0][1512]=1511
+.[0][1513]=1512
+.[0][1514]=1513
+.[0][1515]=1514
+.[0][1516]=1515
+.[0][1517]=1516
+.[0][1518]=1517
+.[0][1519]=1518
+.[0][1520]=1519
+.[0][1521]=1520
+.[0][1522]=1521
+.[0][1523]=1522
+.[0][1524]=1523
+.[0][1525]=1524
+.[0][1526]=1525
+.[0][1527]=1526
+.[0][1528]=1527
+.[0][1529]=1528
+.[0][1530]=1529
+.[0][1531]=1530
+.[0][1532]=1531
+.[0][1533]=1532
+.[0][1534]=1533
+.[0][1535]=1534
+.[0][1536]=1535
+.[0][1537]=1536
+.[0][1538]=1537
+.[0][1539]=1538
+.[0][1540]=1539
+.[0][1541]=1540
+.[0][1542]=1541
+.[0][1543]=1542
+.[0][1544]=1543
+.[0][1545]=1544
+.[0][1546]=1545
+.[0][1547]=1546
+.[0][1548]=1547
+.[0][1549]=1548
+.[0][1550]=1549
+.[0][1551]=1550
+.[0][1552]=1551
+.[0][1553]=1552
+.[0][1554]=1553
+.[0][1555]=1554
+.[0][1556]=1555
+.[0][1557]=1556
+.[0][1558]=1557
+.[0][1559]=1558
+.[0][1560]=1559
+.[0][1561]=1560
+.[0][1562]=1561
+.[0][1563]=1562
+.[0][1564]=1563
+.[0][1565]=1564
+.[0][1566]=1565
+.[0][1567]=1566
+.[0][1568]=1567
+.[0][1569]=1568
+.[0][1570]=1569
+.[0][1571]=1570
+.[0][1572]=1571
+.[0][1573]=1572
+.[0][1574]=1573
+.[0][1575]=1574
+.[0][1576]=1575
+.[0][1577]=1576
+.[0][1578]=1577
+.[0][1579]=1578
+.[0][1580]=1579
+.[0][1581]=1580
+.[0][1582]=1581
+.[0][1583]=1582
+.[0][1584]=1583
+.[0][1585]=1584
+.[0][1586]=1585
+.[0][1587]=1586
+.[0][1588]=1587
+.[0][1589]=1588
+.[0][1590]=1589
+.[0][1591]=1590
+.[0][1592]=1591
+.[0][1593]=1592
+.[0][1594]=1593
+.[0][1595]=1594
+.[0][1596]=1595
+.[0][1597]=1596
+.[0][1598]=1597
+.[0][1599]=1598
+.[0][1600]=1599
+.[0][1601]=1600
+.[0][1602]=1601
+.[0][1603]=1602
+.[0][1604]=1603
+.[0][1605]=1604
+.[0][1606]=1605
+.[0][1607]=1606
+.[0][1608]=1607
+.[0][1609]=1608
+.[0][1610]=1609
+.[0][1611]=1610
+.[0][1612]=1611
+.[0][1613]=1612
+.[0][1614]=1613
+.[0][1615]=1614
+.[0][1616]=1615
+.[0][1617]=1616
+.[0][1618]=1617
+.[0][1619]=1618
+.[0][1620]=1619
+.[0][1621]=1620
+.[0][1622]=1621
+.[0][1623]=1622
+.[0][1624]=1623
+.[0][1625]=1624
+.[0][1626]=1625
+.[0][1627]=1626
+.[0][1628]=1627
+.[0][1629]=1628
+.[0][1630]=1629
+.[0][1631]=1630
+.[0][1632]=1631
+.[0][1633]=1632
+.[0][1634]=1633
+.[0][1635]=1634
+.[0][1636]=1635
+.[0][1637]=1636
+.[0][1638]=1637
+.[0][1639]=1638
+.[0][1640]=1639
+.[0][1641]=1640
+.[0][1642]=1641
+.[0][1643]=1642
+.[0][1644]=1643
+.[0][1645]=1644
+.[0][1646]=1645
+.[0][1647]=1646
+.[0][1648]=1647
+.[0][1649]=1648
+.[0][1650]=1649
+.[0][1651]=1650
+.[0][1652]=1651
+.[0][1653]=1652
+.[0][1654]=1653
+.[0][1655]=1654
+.[0][1656]=1655
+.[0][1657]=1656
+.[0][1658]=1657
+.[0][1659]=1658
+.[0][1660]=1659
+.[0][1661]=1660
+.[0][1662]=1661
+.[0][1663]=1662
+.[0][1664]=1663
+.[0][1665]=1664
+.[0][1666]=1665
+.[0][1667]=1666
+.[0][1668]=1667
+.[0][1669]=1668
+.[0][1670]=1669
+.[0][1671]=1670
+.[0][1672]=1671
+.[0][1673]=1672
+.[0][1674]=1673
+.[0][1675]=1674
+.[0][1676]=1675
+.[0][1677]=1676
+.[0][1678]=1677
+.[0][1679]=1678
+.[0][1680]=1679
+.[0][1681]=1680
+.[0][1682]=1681
+.[0][1683]=1682
+.[0][1684]=1683
+.[0][1685]=1684
+.[0][1686]=1685
+.[0][1687]=1686
+.[0][1688]=1687
+.[0][1689]=1688
+.[0][1690]=1689
+.[0][1691]=1690
+.[0][1692]=1691
+.[0][1693]=1692
+.[0][1694]=1693
+.[0][1695]=1694
+.[0][1696]=1695
+.[0][1697]=1696
+.[0][1698]=1697
+.[0][1699]=1698
+.[0][1700]=1699
+.[0][1701]=1700
+.[0][1702]=1701
+.[0][1703]=1702
+.[0][1704]=1703
+.[0][1705]=1704
+.[0][1706]=1705
+.[0][1707]=1706
+.[0][1708]=1707
+.[0][1709]=1708
+.[0][1710]=1709
+.[0][1711]=1710
+.[0][1712]=1711
+.[0][1713]=1712
+.[0][1714]=1713
+.[0][1715]=1714
+.[0][1716]=1715
+.[0][1717]=1716
+.[0][1718]=1717
+.[0][1719]=1718
+.[0][1720]=1719
+.[0][1721]=1720
+.[0][1722]=1721
+.[0][1723]=1722
+.[0][1724]=1723
+.[0][1725]=1724
+.[0][1726]=1725
+.[0][1727]=1726
+.[0][1728]=1727
+.[0][1729]=1728
+.[0][1730]=1729
+.[0][1731]=1730
+.[0][1732]=1731
+.[0][1733]=1732
+.[0][1734]=1733
+.[0][1735]=1734
+.[0][1736]=1735
+.[0][1737]=1736
+.[0][1738]=1737
+.[0][1739]=1738
+.[0][1740]=1739
+.[0][1741]=1740
+.[0][1742]=1741
+.[0][1743]=1742
+.[0][1744]=1743
+.[0][1745]=1744
+.[0][1746]=1745
+.[0][1747]=1746
+.[0][1748]=1747
+.[0][1749]=1748
+.[0][1750]=1749
+.[0][1751]=1750
+.[0][1752]=1751
+.[0][1753]=1752
+.[0][1754]=1753
+.[0][1755]=1754
+.[0][1756]=1755
+.[0][1757]=1756
+.[0][1758]=1757
+.[0][1759]=1758
+.[0][1760]=1759
+.[0][1761]=1760
+.[0][1762]=1761
+.[0][1763]=1762
+.[0][1764]=1763
+.[0][1765]=1764
+.[0][1766]=1765
+.[0][1767]=1766
+.[0][1768]=1767
+.[0][1769]=1768
+.[0][1770]=1769
+.[0][1771]=1770
+.[0][1772]=1771
+.[0][1773]=1772
+.[0][1774]=1773
+.[0][1775]=1774
+.[0][1776]=1775
+.[0][1777]=1776
+.[0][1778]=1777
+.[0][1779]=1778
+.[0][1780]=1779
+.[0][1781]=1780
+.[0][1782]=1781
+.[0][1783]=1782
+.[0][1784]=1783
+.[0][1785]=1784
+.[0][1786]=1785
+.[0][1787]=1786
+.[0][1788]=1787
+.[0][1789]=1788
+.[0][1790]=1789
+.[0][1791]=1790
+.[0][1792]=1791
+.[0][1793]=1792
+.[0][1794]=1793
+.[0][1795]=1794
+.[0][1796]=1795
+.[0][1797]=1796
+.[0][1798]=1797
+.[0][1799]=1798
+.[0][1800]=1799
+.[0][1801]=1800
+.[0][1802]=1801
+.[0][1803]=1802
+.[0][1804]=1803
+.[0][1805]=1804
+.[0][1806]=1805
+.[0][1807]=1806
+.[0][1808]=1807
+.[0][1809]=1808
+.[0][1810]=1809
+.[0][1811]=1810
+.[0][1812]=1811
+.[0][1813]=1812
+.[0][1814]=1813
+.[0][1815]=1814
+.[0][1816]=1815
+.[0][1817]=1816
+.[0][1818]=1817
+.[0][1819]=1818
+.[0][1820]=1819
+.[0][1821]=1820
+.[0][1822]=1821
+.[0][1823]=1822
+.[0][1824]=1823
+.[0][1825]=1824
+.[0][1826]=1825
+.[0][1827]=1826
+.[0][1828]=1827
+.[0][1829]=1828
+.[0][1830]=1829
+.[0][1831]=1830
+.[0][1832]=1831
+.[0][1833]=1832
+.[0][1834]=1833
+.[0][1835]=1834
+.[0][1836]=1835
+.[0][1837]=1836
+.[0][1838]=1837
+.[0][1839]=1838
+.[0][1840]=1839
+.[0][1841]=1840
+.[0][1842]=1841
+.[0][1843]=1842
+.[0][1844]=1843
+.[0][1845]=1844
+.[0][1846]=1845
+.[0][1847]=1846
+.[0][1848]=1847
+.[0][1849]=1848
+.[0][1850]=1849
+.[0][1851]=1850
+.[0][1852]=1851
+.[0][1853]=1852
+.[0][1854]=1853
+.[0][1855]=1854
+.[0][1856]=1855
+.[0][1857]=1856
+.[0][1858]=1857
+.[0][1859]=1858
+.[0][1860]=1859
+.[0][1861]=1860
+.[0][1862]=1861
+.[0][1863]=1862
+.[0][1864]=1863
+.[0][1865]=1864
+.[0][1866]=1865
+.[0][1867]=1866
+.[0][1868]=1867
+.[0][1869]=1868
+.[0][1870]=1869
+.[0][1871]=1870
+.[0][1872]=1871
+.[0][1873]=1872
+.[0][1874]=1873
+.[0][1875]=1874
+.[0][1876]=1875
+.[0][1877]=1876
+.[0][1878]=1877
+.[0][1879]=1878
+.[0][1880]=1879
+.[0][1881]=1880
+.[0][1882]=1881
+.[0][1883]=1882
+.[0][1884]=1883
+.[0][1885]=1884
+.[0][1886]=1885
+.[0][1887]=1886
+.[0][1888]=1887
+.[0][1889]=1888
+.[0][1890]=1889
+.[0][1891]=1890
+.[0][1892]=1891
+.[0][1893]=1892
+.[0][1894]=1893
+.[0][1895]=1894
+.[0][1896]=1895
+.[0][1897]=1896
+.[0][1898]=1897
+.[0][1899]=1898
+.[0][1900]=1899
+.[0][1901]=1900
+.[0][1902]=1901
+.[0][1903]=1902
+.[0][1904]=1903
+.[0][1905]=1904
+.[0][1906]=1905
+.[0][1907]=1906
+.[0][1908]=1907
+.[0][1909]=1908
+.[0][1910]=1909
+.[0][1911]=1910
+.[0][1912]=1911
+.[0][1913]=1912
+.[0][1914]=1913
+.[0][1915]=1914
+.[0][1916]=1915
+.[0][1917]=1916
+.[0][1918]=1917
+.[0][1919]=1918
+.[0][1920]=1919
+.[0][1921]=1920
+.[0][1922]=1921
+.[0][1923]=1922
+.[0][1924]=1923
+.[0][1925]=1924
+.[0][1926]=1925
+.[0][1927]=1926
+.[0][1928]=1927
+.[0][1929]=1928
+.[0][1930]=1929
+.[0][1931]=1930
+.[0][1932]=1931
+.[0][1933]=1932
+.[0][1934]=1933
+.[0][1935]=1934
+.[0][1936]=1935
+.[0][1937]=1936
+.[0][1938]=1937
+.[0][1939]=1938
+.[0][1940]=1939
+.[0][1941]=1940
+.[0][1942]=1941
+.[0][1943]=1942
+.[0][1944]=1943
+.[0][1945]=1944
+.[0][1946]=1945
+.[0][1947]=1946
+.[0][1948]=1947
+.[0][1949]=1948
+.[0][1950]=1949
+.[0][1951]=1950
+.[0][1952]=1951
+.[0][1953]=1952
+.[0][1954]=1953
+.[0][1955]=1954
+.[0][1956]=1955
+.[0][1957]=1956
+.[0][1958]=1957
+.[0][1959]=1958
+.[0][1960]=1959
+.[0][1961]=1960
+.[0][1962]=1961
+.[0][1963]=1962
+.[0][1964]=1963
+.[0][1965]=1964
+.[0][1966]=1965
+.[0][1967]=1966
+.[0][1968]=1967
+.[0][1969]=1968
+.[0][1970]=1969
+.[0][1971]=1970
+.[0][1972]=1971
+.[0][1973]=1972
+.[0][1974]=1973
+.[0][1975]=1974
+.[0][1976]=1975
+.[0][1977]=1976
+.[0][1978]=1977
+.[0][1979]=1978
+.[0][1980]=1979
+.[0][1981]=1980
+.[0][1982]=1981
+.[0][1983]=1982
+.[0][1984]=1983
+.[0][1985]=1984
+.[0][1986]=1985
+.[0][1987]=1986
+.[0][1988]=1987
+.[0][1989]=1988
+.[0][1990]=1989
+.[0][1991]=1990
+.[0][1992]=1991
+.[0][1993]=1992
+.[0][1994]=1993
+.[0][1995]=1994
+.[0][1996]=1995
+.[0][1997]=1996
+.[0][1998]=1997
+.[0][1999]=1998
+.[0][2000]=1999
+.[0][2001]=2000
+.[0][2002]=2001
+.[0][2003]=2002
+.[0][2004]=2003
+.[0][2005]=2004
+.[0][2006]=2005
+.[0][2007]=2006
+.[0][2008]=2007
+.[0][2009]=2008
+.[0][2010]=2009
+.[0][2011]=2010
+.[0][2012]=2011
+.[0][2013]=2012
+.[0][2014]=2013
+.[0][2015]=2014
+.[0][2016]=2015
+.[0][2017]=2016
+.[0][2018]=2017
+.[0][2019]=2018
+.[0][2020]=2019
+.[0][2021]=2020
+.[0][2022]=2021
+.[0][2023]=2022
+.[0][2024]=2023
+.[0][2025]=2024
+.[0][2026]=2025
+.[0][2027]=2026
+.[0][2028]=2027
+.[0][2029]=2028
+.[0][2030]=2029
+.[0][2031]=2030
+.[0][2032]=2031
+.[0][2033]=2032
+.[0][2034]=2033
+.[0][2035]=2034
+.[0][2036]=2035
+.[0][2037]=2036
+.[0][2038]=2037
+.[0][2039]=2038
+.[0][2040]=2039
+.[0][2041]=2040
+.[0][2042]=2041
+.[0][2043]=2042
+.[0][2044]=2043
+.[0][2045]=2044
+.[0][2046]=2045
+.[0][2047]=2046
+.[0][2048]=2047
+.[0][2049]=2048
+.[0][2050]=2049
+.[0][2051]=2050
+.[0][2052]=2051
+.[0][2053]=2052
+.[0][2054]=2053
+.[0][2055]=2054
+.[0][2056]=2055
+.[0][2057]=2056
+.[0][2058]=2057
+.[0][2059]=2058
+.[0][2060]=2059
+.[0][2061]=2060
+.[0][2062]=2061
+.[0][2063]=2062
+.[0][2064]=2063
+.[0][2065]=2064
+.[0][2066]=2065
+.[0][2067]=2066
+.[0][2068]=2067
+.[0][2069]=2068
+.[0][2070]=2069
+.[0][2071]=2070
+.[0][2072]=2071
+.[0][2073]=2072
+.[0][2074]=2073
+.[0][2075]=2074
+.[0][2076]=2075
+.[0][2077]=2076
+.[0][2078]=2077
+.[0][2079]=2078
+.[0][2080]=2079
+.[0][2081]=2080
+.[0][2082]=2081
+.[0][2083]=2082
+.[0][2084]=2083
+.[0][2085]=2084
+.[0][2086]=2085
+.[0][2087]=2086
+.[0][2088]=2087
+.[0][2089]=2088
+.[0][2090]=2089
+.[0][2091]=2090
+.[0][2092]=2091
+.[0][2093]=2092
+.[0][2094]=2093
+.[0][2095]=2094
+.[0][2096]=2095
+.[0][2097]=2096
+.[0][2098]=2097
+.[0][2099]=2098
+.[0][2100]=2099
+.[0][2101]=2100
+.[0][2102]=2101
+.[0][2103]=2102
+.[0][2104]=2103
+.[0][2105]=2104
+.[0][2106]=2105
+.[0][2107]=2106
+.[0][2108]=2107
+.[0][2109]=2108
+.[0][2110]=2109
+.[0][2111]=2110
+.[0][2112]=2111
+.[0][2113]=2112
+.[0][2114]=2113
+.[0][2115]=2114
+.[0][2116]=2115
+.[0][2117]=2116
+.[0][2118]=2117
+.[0][2119]=2118
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_large_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+[["A",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118]
+]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.={}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.={}
+.count=1234
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{ "count" : 1234 }
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+.={}
+.attribute="random"
+.count=1234
+.name="test"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,5 @@
+{ 
+	"count" : 1234,
+	"name" : "test",
+	"attribute" : "random"
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.={}
+.=1234
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_object_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+{ 
+	"" : 1234
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,11 @@
+/* A comment
+   at the beginning of the file.
+ */
+.={}
+.first=1
+/* Comment before 'second'
+ */
+.second=2
+/* A comment at 
+   the end of the file.
+ */
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_preserve_comment_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,14 @@
+/* A comment
+   at the beginning of the file.
+ */
+{
+   "first" : 1, // comment after 'first' on the same line
+
+/* Comment before 'second'
+ */
+   "second" : 2
+}
+
+/* A comment at 
+   the end of the file.
+ */
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// 2^33 => out of integer range, switch to double
+.=8589934592
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// 2^33 => out of integer range, switch to double
+8589934592
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -2^32 => out of signed integer range, switch to double
+.=-4294967295
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -2^32 => out of signed integer range, switch to double
+-4294967295
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -2^32 => out of signed integer range, switch to double
+.=-4294967295
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -2^32 => out of signed integer range, switch to double
+-4294967295
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// 1.2345678
+.=1.2345678
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// 1.2345678
+12345678e-7
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// 1234567.8
+.=1234567.8
+
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// 1234567.8
+0.12345678e7
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// -1.2345678
+.=-1.2345678
+
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_06.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -1.2345678
+-12345678e-7
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// -1234567.8
+.=-1234567.8
+
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_07.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+// -1234567.8
+-0.12345678e7
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 32-bit integer range, switch to double in 32-bit mode. Length the
+// same as UINT_MAX in base 10 and digit less than UINT_MAX's last digit in
+// order to catch a bug in the parsing code.
+.=4300000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_08.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 32-bit integer range, switch to double in 32-bit mode. Length the
+// same as UINT_MAX in base 10 and digit less than UINT_MAX's last digit in
+// order to catch a bug in the parsing code.
+4300000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 64-bit integer range, switch to double in all modes. Length the same
+// as ULONG_MAX in base 10 and digit less than ULONG_MAX's last digit in order
+// to catch a bug in the parsing code.
+.=1.9e+19
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_09.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 64-bit integer range, switch to double in all modes. Length the same
+// as ULONG_MAX in base 10 and digit less than ULONG_MAX's last digit in order
+// to catch a bug in the parsing code.
+19000000000000000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 32-bit signed integer range, switch to double in all modes. Length
+// the same as INT_MIN in base 10 and digit less than INT_MIN's last digit in
+// order to catch a bug in the parsing code.
+.=-2200000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_10.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 32-bit signed integer range, switch to double in all modes. Length
+// the same as INT_MIN in base 10 and digit less than INT_MIN's last digit in
+// order to catch a bug in the parsing code.
+-2200000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 64-bit signed integer range, switch to double in all modes. Length
+// the same as LONG_MIN in base 10 and digit less than LONG_MIN's last digit in
+// order to catch a bug in the parsing code.
+.=-9.3e+18
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_11.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,4 @@
+// Out of 64-bit signed integer range, switch to double in all modes. Length
+// the same as LONG_MIN in base 10 and digit less than LONG_MIN's last digit in
+// order to catch a bug in the parsing code.
+-9300000000000000001
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// 2^64 -> switch to double.
+.=1.844674407370955e+19
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_real_12.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+// 2^64 -> switch to double.
+18446744073709551616
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="http://jsoncpp.sourceforge.net/"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"http:\/\/jsoncpp.sourceforge.net\/"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.=""abc\def""
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+"\"abc\\def\""
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="a"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_01.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"\u0061"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="Â¢"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_02.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"\u00A2"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="â¬"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_03.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"\u20AC"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+.="ð"
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_04.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"\uD834\uDD1E"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.expected polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.expected
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.expected	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.expected	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+.="ZaÅ¼Ã³ÅÄ gÄÅlÄ jaÅºÅ"
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/data/test_string_unicode_05.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"ZaÅ¼Ã³ÅÄ gÄÅlÄ jaÅºÅ"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/generate_expected.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/generate_expected.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/generate_expected.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/generate_expected.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,17 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from __future__ import print_function
+import glob
+import os.path
+for path in glob.glob('*.json'):
+    text = file(path,'rt').read()
+    target = os.path.splitext(path)[0] + '.expected'
+    if os.path.exists(target):
+        print('skipping:', target)
+    else:
+        print('creating:', target)
+        file(target,'wt').write(text)
+
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail10.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail10.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail10.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail10.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Extra value after close": true} "misplaced quoted value"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail11.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail11.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail11.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail11.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Illegal expression": 1 + 2}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail12.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail12.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail12.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail12.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Illegal invocation": alert()}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail13.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail13.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail13.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail13.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Numbers cannot have leading zeroes": 013}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail14.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail14.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail14.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail14.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Numbers cannot be hex": 0x14}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail15.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail15.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail15.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail15.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Illegal backslash escape: \x15"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail16.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail16.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail16.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail16.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[\naked]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail17.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail17.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail17.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail17.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Illegal backslash escape: \017"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail18.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail18.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail18.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail18.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[[[[[[[[[[[[[[[[[[[["Too deep"]]]]]]]]]]]]]]]]]]]]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail19.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail19.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail19.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail19.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Missing colon" null}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail1.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail1.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail1.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail1.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+"A JSON payload should be an object or array, not a string."
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail20.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail20.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail20.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail20.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Double colon":: null}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail21.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail21.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail21.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail21.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Comma instead of colon", null}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail22.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail22.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail22.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail22.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Colon instead of comma": false]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail23.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail23.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail23.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail23.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Bad value", truth]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail24.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail24.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail24.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail24.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+['single quote']
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail25.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail25.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail25.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail25.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["	tab	character	in	string	"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail26.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail26.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail26.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail26.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["tab\   character\   in\  string\  "]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail27.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail27.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail27.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail27.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+["line
+break"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail28.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail28.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail28.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail28.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,2 @@
+["line\
+break"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail29.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail29.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail29.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail29.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[0e]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail2.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail2.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail2.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail2.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Unclosed array"
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail30.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail30.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail30.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail30.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[0e+]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail31.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail31.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail31.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail31.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[0e+-1]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail32.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail32.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail32.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail32.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Comma instead if closing brace": true,
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail33.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail33.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail33.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail33.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["mismatch"}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail3.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail3.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail3.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail3.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{unquoted_key: "keys must be quoted"}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail4.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail4.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail4.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail4.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["extra comma",]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail5.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail5.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail5.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail5.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["double extra comma",,]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail6.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail6.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail6.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail6.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[   , "<-- missing value"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail7.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail7.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail7.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail7.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Comma after the close"],
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail8.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail8.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail8.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail8.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+["Extra close"]]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail9.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail9.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail9.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/fail9.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+{"Extra comma": true,}
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass1.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass1.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass1.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass1.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,58 @@
+[
+    "JSON Test Pattern pass1",
+    {"object with 1 member":["array with 1 element"]},
+    {},
+    [],
+    -42,
+    true,
+    false,
+    null,
+    {
+        "integer": 1234567890,
+        "real": -9876.543210,
+        "e": 0.123456789e-12,
+        "E": 1.234567890E+34,
+        "":  23456789012E66,
+        "zero": 0,
+        "one": 1,
+        "space": " ",
+        "quote": "\"",
+        "backslash": "\\",
+        "controls": "\b\f\n\r\t",
+        "slash": "/ & \/",
+        "alpha": "abcdefghijklmnopqrstuvwyz",
+        "ALPHA": "ABCDEFGHIJKLMNOPQRSTUVWYZ",
+        "digit": "0123456789",
+        "0123456789": "digit",
+        "special": "`1~!@#$%^&*()_+-={':[,]}|;.</>?",
+        "hex": "\u0123\u4567\u89AB\uCDEF\uabcd\uef4A",
+        "true": true,
+        "false": false,
+        "null": null,
+        "array":[  ],
+        "object":{  },
+        "address": "50 St. James Street",
+        "url": "http://www.JSON.org/",
+        "comment": "// /* <!-- --",
+        "# -- --> */": " ",
+        " s p a c e d " :[1,2 , 3
+
+,
+
+4 , 5        ,          6           ,7        ],"compact":[1,2,3,4,5,6,7],
+        "jsontext": "{\"object with 1 member\":[\"array with 1 element\"]}",
+        "quotes": "&#34; \u0022 %22 0x22 034 &#x22;",
+        "\/\\\"\uCAFE\uBABE\uAB98\uFCDE\ubcda\uef4A\b\f\n\r\t`1~!@#$%^&*()_+-=[]{}|;:',./<>?"
+: "A key can be any string"
+    },
+    0.5 ,98.6
+,
+99.44
+,
+
+1066,
+1e1,
+0.1e1,
+1e-1,
+1e00,2e+00,2e-00
+,"rosebud"]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass2.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass2.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass2.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass2.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+[[[[[[[[[[[[[[[[[[["Not too deep"]]]]]]]]]]]]]]]]]]]
\ Dosya sonunda yenisatÄ±r yok.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass3.json polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass3.json
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass3.json	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/pass3.json	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,6 @@
+{
+    "JSON Test Pattern pass3": {
+        "The outermost value": "must be an object or array.",
+        "In this test": "It is an object."
+    }
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/readme.txt polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/readme.txt
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/readme.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/jsonchecker/readme.txt	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,3 @@
+Test suite from http://json.org/JSON_checker/.
+
+If the JSON_checker is working correctly, it must accept all of the pass*.json files and reject all of the fail*.json files.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/pyjsontestrunner.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/pyjsontestrunner.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/pyjsontestrunner.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/pyjsontestrunner.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,71 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+"""Simple implementation of a json test runner to run the test against
+json-py."""
+
+from __future__ import print_function
+import sys
+import os.path
+import json
+import types
+
+if len(sys.argv) != 2:
+    print("Usage: %s input-json-file", sys.argv[0])
+    sys.exit(3)
+    
+input_path = sys.argv[1]
+base_path = os.path.splitext(input_path)[0]
+actual_path = base_path + '.actual'
+rewrite_path = base_path + '.rewrite'
+rewrite_actual_path = base_path + '.actual-rewrite'
+
+def valueTreeToString(fout, value, path = '.'):
+    ty = type(value) 
+    if ty  is types.DictType:
+        fout.write('%s={}\n' % path)
+        suffix = path[-1] != '.' and '.' or ''
+        names = value.keys()
+        names.sort()
+        for name in names:
+            valueTreeToString(fout, value[name], path + suffix + name)
+    elif ty is types.ListType:
+        fout.write('%s=[]\n' % path)
+        for index, childValue in zip(xrange(0,len(value)), value):
+            valueTreeToString(fout, childValue, path + '[%d]' % index)
+    elif ty is types.StringType:
+        fout.write('%s="%s"\n' % (path,value))
+    elif ty is types.IntType:
+        fout.write('%s=%d\n' % (path,value))
+    elif ty is types.FloatType:
+        fout.write('%s=%.16g\n' % (path,value))
+    elif value is True:
+        fout.write('%s=true\n' % path)
+    elif value is False:
+        fout.write('%s=false\n' % path)
+    elif value is None:
+        fout.write('%s=null\n' % path)
+    else:
+        assert False and "Unexpected value type"
+        
+def parseAndSaveValueTree(input, actual_path):
+    root = json.loads(input)
+    fout = file(actual_path, 'wt')
+    valueTreeToString(fout, root)
+    fout.close()
+    return root
+
+def rewriteValueTree(value, rewrite_path):
+    rewrite = json.dumps(value)
+    #rewrite = rewrite[1:-1]  # Somehow the string is quoted ! jsonpy bug ?
+    file(rewrite_path, 'wt').write(rewrite + '\n')
+    return rewrite
+    
+input = file(input_path, 'rt').read()
+root = parseAndSaveValueTree(input, actual_path)
+rewrite = rewriteValueTree(json.write(root), rewrite_path)
+rewrite_root = parseAndSaveValueTree(rewrite, rewrite_actual_path)
+
+sys.exit(0)
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/runjsontests.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/runjsontests.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/runjsontests.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/runjsontests.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,174 @@
+# Copyright 2007 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from __future__ import print_function
+from __future__ import unicode_literals
+from io import open
+from glob import glob
+import sys
+import os
+import os.path
+import optparse
+
+VALGRIND_CMD = 'valgrind --tool=memcheck --leak-check=yes --undef-value-errors=yes '
+
+def getStatusOutput(cmd):
+    """
+    Return int, unicode (for both Python 2 and 3).
+    Note: os.popen().close() would return None for 0.
+    """
+    print(cmd, file=sys.stderr)
+    pipe = os.popen(cmd)
+    process_output = pipe.read()
+    try:
+        # We have been using os.popen(). When we read() the result
+        # we get 'str' (bytes) in py2, and 'str' (unicode) in py3.
+        # Ugh! There must be a better way to handle this.
+        process_output = process_output.decode('utf-8')
+    except AttributeError:
+        pass  # python3
+    status = pipe.close()
+    return status, process_output
+def compareOutputs(expected, actual, message):
+    expected = expected.strip().replace('\r','').split('\n')
+    actual = actual.strip().replace('\r','').split('\n')
+    diff_line = 0
+    max_line_to_compare = min(len(expected), len(actual))
+    for index in range(0,max_line_to_compare):
+        if expected[index].strip() != actual[index].strip():
+            diff_line = index + 1
+            break
+    if diff_line == 0 and len(expected) != len(actual):
+        diff_line = max_line_to_compare+1
+    if diff_line == 0:
+        return None
+    def safeGetLine(lines, index):
+        index += -1
+        if index >= len(lines):
+            return ''
+        return lines[index].strip()
+    return """  Difference in %s at line %d:
+  Expected: '%s'
+  Actual:   '%s'
+""" % (message, diff_line,
+       safeGetLine(expected,diff_line),
+       safeGetLine(actual,diff_line))
+        
+def safeReadFile(path):
+    try:
+        return open(path, 'rt', encoding = 'utf-8').read()
+    except IOError as e:
+        return '<File "%s" is missing: %s>' % (path,e)
+
+def runAllTests(jsontest_executable_path, input_dir = None,
+                 use_valgrind=False, with_json_checker=False,
+                 writerClass='StyledWriter'):
+    if not input_dir:
+        input_dir = os.path.join(os.getcwd(), 'data')
+    tests = glob(os.path.join(input_dir, '*.json'))
+    if with_json_checker:
+        test_jsonchecker = glob(os.path.join(input_dir, '../jsonchecker', '*.json'))
+    else:
+        test_jsonchecker = []
+    failed_tests = []
+    valgrind_path = use_valgrind and VALGRIND_CMD or ''
+    for input_path in tests + test_jsonchecker:
+        expect_failure = os.path.basename(input_path).startswith('fail')
+        is_json_checker_test = (input_path in test_jsonchecker) or expect_failure
+        print('TESTING:', input_path, end=' ')
+        options = is_json_checker_test and '--json-checker' or ''
+        options += ' --json-writer %s'%writerClass
+        cmd = '%s%s %s "%s"' % (            valgrind_path, jsontest_executable_path, options,
+            input_path)
+        status, process_output = getStatusOutput(cmd)
+        if is_json_checker_test:
+            if expect_failure:
+                if not status:
+                    print('FAILED')
+                    failed_tests.append((input_path, 'Parsing should have failed:\n%s' %
+                                          safeReadFile(input_path)))
+                else:
+                    print('OK')
+            else:
+                if status:
+                    print('FAILED')
+                    failed_tests.append((input_path, 'Parsing failed:\n' + process_output))
+                else:
+                    print('OK')
+        else:
+            base_path = os.path.splitext(input_path)[0]
+            actual_output = safeReadFile(base_path + '.actual')
+            actual_rewrite_output = safeReadFile(base_path + '.actual-rewrite')
+            open(base_path + '.process-output', 'wt', encoding = 'utf-8').write(process_output)
+            if status:
+                print('parsing failed')
+                failed_tests.append((input_path, 'Parsing failed:\n' + process_output))
+            else:
+                expected_output_path = os.path.splitext(input_path)[0] + '.expected'
+                expected_output = open(expected_output_path, 'rt', encoding = 'utf-8').read()
+                detail = (compareOutputs(expected_output, actual_output, 'input')
+                            or compareOutputs(expected_output, actual_rewrite_output, 'rewrite'))
+                if detail:
+                    print('FAILED')
+                    failed_tests.append((input_path, detail))
+                else:
+                    print('OK')
+
+    if failed_tests:
+        print()
+        print('Failure details:')
+        for failed_test in failed_tests:
+            print('* Test', failed_test[0])
+            print(failed_test[1])
+            print()
+        print('Test results: %d passed, %d failed.' % (len(tests)-len(failed_tests),
+                                                       len(failed_tests)))
+        return 1
+    else:
+        print('All %d tests passed.' % len(tests))
+        return 0
+
+def main():
+    from optparse import OptionParser
+    parser = OptionParser(usage="%prog [options] <path to jsontestrunner.exe> [test case directory]")
+    parser.add_option("--valgrind",
+                  action="store_true", dest="valgrind", default=False,
+                  help="run all the tests using valgrind to detect memory leaks")
+    parser.add_option("-c", "--with-json-checker",
+                  action="store_true", dest="with_json_checker", default=False,
+                  help="run all the tests from the official JSONChecker test suite of json.org")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+
+    if len(args) < 1 or len(args) > 2:
+        parser.error('Must provides at least path to jsontestrunner executable.')
+        sys.exit(1)
+
+    jsontest_executable_path = os.path.normpath(os.path.abspath(args[0]))
+    if len(args) > 1:
+        input_path = os.path.normpath(os.path.abspath(args[1]))
+    else:
+        input_path = None
+    status = runAllTests(jsontest_executable_path, input_path,
+                         use_valgrind=options.valgrind,
+                         with_json_checker=options.with_json_checker,
+                         writerClass='StyledWriter')
+    if status:
+        sys.exit(status)
+    status = runAllTests(jsontest_executable_path, input_path,
+                         use_valgrind=options.valgrind,
+                         with_json_checker=options.with_json_checker,
+                         writerClass='StyledStreamWriter')
+    if status:
+        sys.exit(status)
+    status = runAllTests(jsontest_executable_path, input_path,
+                         use_valgrind=options.valgrind,
+                         with_json_checker=options.with_json_checker,
+                         writerClass='BuiltStyledStreamWriter')
+    if status:
+        sys.exit(status)
+
+if __name__ == '__main__':
+    main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/rununittests.py polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/rununittests.py
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/rununittests.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/test/rununittests.py	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,84 @@
+# Copyright 2009 Baptiste Lepilleur
+# Distributed under MIT license, or public domain if desired and
+# recognized in your jurisdiction.
+# See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
+
+from __future__ import print_function
+from __future__ import unicode_literals
+from io import open
+from glob import glob
+import sys
+import os
+import os.path
+import subprocess
+import optparse
+
+VALGRIND_CMD = 'valgrind --tool=memcheck --leak-check=yes --undef-value-errors=yes'
+
+class TestProxy(object):
+    def __init__(self, test_exe_path, use_valgrind=False):
+        self.test_exe_path = os.path.normpath(os.path.abspath(test_exe_path))
+        self.use_valgrind = use_valgrind
+
+    def run(self, options):
+        if self.use_valgrind:
+            cmd = VALGRIND_CMD.split()
+        else:
+            cmd = []
+        cmd.extend([self.test_exe_path, '--test-auto'] + options)
+        try:
+            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+        except:
+            print(cmd)
+            raise
+        stdout = process.communicate()[0]
+        if process.returncode:
+            return False, stdout
+        return True, stdout
+
+def runAllTests(exe_path, use_valgrind=False):
+    test_proxy = TestProxy(exe_path, use_valgrind=use_valgrind)
+    status, test_names = test_proxy.run(['--list-tests'])
+    if not status:
+        print("Failed to obtain unit tests list:\n" + test_names, file=sys.stderr)
+        return 1
+    test_names = [name.strip() for name in test_names.decode('utf-8').strip().split('\n')]
+    failures = []
+    for name in test_names:
+        print('TESTING %s:' % name, end=' ')
+        succeed, result = test_proxy.run(['--test', name])
+        if succeed:
+            print('OK')
+        else:
+            failures.append((name, result))
+            print('FAILED')
+    failed_count = len(failures)
+    pass_count = len(test_names) - failed_count
+    if failed_count:
+        print()
+        for name, result in failures:
+            print(result)
+        print('%d/%d tests passed (%d failure(s))' % (            pass_count, len(test_names), failed_count))
+        return 1
+    else:
+        print('All %d tests passed' % len(test_names))
+        return 0
+
+def main():
+    from optparse import OptionParser
+    parser = OptionParser(usage="%prog [options] <path to test_lib_json.exe>")
+    parser.add_option("--valgrind",
+                  action="store_true", dest="valgrind", default=False,
+                  help="run all the tests using valgrind to detect memory leaks")
+    parser.enable_interspersed_args()
+    options, args = parser.parse_args()
+
+    if len(args) != 1:
+        parser.error('Must provides at least path to test_lib_json executable.')
+        sys.exit(1)
+
+    exit_code = runAllTests(args[0], use_valgrind=options.valgrind)
+    sys.exit(exit_code)
+
+if __name__ == '__main__':
+    main()
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/travis.sh polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/travis.sh
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/travis.sh	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/travis.sh	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,31 @@
+#!/usr/bin/env sh
+# This is called by `.travis.yml` via Travis CI.
+# Travis supplies $TRAVIS_OS_NAME.
+#  http://docs.travis-ci.com/user/multi-os/
+# Our .travis.yml also defines:
+#   - SHARED_LIB=ON/OFF
+#   - STATIC_LIB=ON/OFF
+#   - CMAKE_PKG=ON/OFF
+#   - BUILD_TYPE=release/debug
+#   - VERBOSE_MAKE=false/true
+#   - VERBOSE (set or not)
+
+# -e: fail on error
+# -v: show commands
+# -x: show expanded commands
+set -vex
+
+env | sort
+
+cmake -DJSONCPP_WITH_CMAKE_PACKAGE=$CMAKE_PKG -DBUILD_SHARED_LIBS=$SHARED_LIB -DCMAKE_BUILD_TYPE=$BUILD_TYPE -DCMAKE_VERBOSE_MAKEFILE=$VERBOSE_MAKE .
+make
+cmake -DJSONCPP_WITH_CMAKE_PACKAGE=$CMAKE_PKG -DBUILD_SHARED_LIBS=$SHARED_LIB -DCMAKE_BUILD_TYPE=$BUILD_TYPE -DCMAKE_VERBOSE_MAKEFILE=$VERBOSE_MAKE -DJSONCPP_USE_SECURE_MEMORY=1 .
+make
+
+# Python is not available in Travis for osx.
+#  https://github.com/travis-ci/travis-ci/issues/2320
+if [ "$TRAVIS_OS_NAME" != "osx" ]
+then
+  make jsoncpp_check
+  valgrind --error-exitcode=42 --leak-check=full ./src/test_lib_json/jsoncpp_test
+fi
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.travis.yml polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.travis.yml
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/.travis.yml	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/.travis.yml	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,43 @@
+# Build matrix / environment variable are explained on:
+# http://about.travis-ci.org/docs/user/build-configuration/
+# This file can be validated on:
+# http://lint.travis-ci.org/
+# See also
+# http://stackoverflow.com/questions/22111549/travis-ci-with-clang-3-4-and-c11/30925448#30925448
+# to allow C++11, though we are not yet building with -std=c++11
+
+install:
+# /usr/bin/gcc is 4.6 always, but gcc-X.Y is available.
+- if [ "$CXX" = "g++" ]; then export CXX="g++-4.9" CC="gcc-4.9"; fi
+# /usr/bin/clang is our version already, and clang-X.Y does not exist.
+#- if [ "$CXX" = "clang++" ]; then export CXX="clang++-3.7" CC="clang-3.7"; fi
+- echo ${PATH}
+- ls /usr/local
+- ls /usr/local/bin
+- export PATH=/usr/local/bin:/usr/bin:${PATH}
+- echo ${CXX}
+- ${CXX} --version
+- which valgrind
+addons:
+  apt:
+    sources:
+    - ubuntu-toolchain-r-test
+    packages:
+    - gcc-4.9
+    - g++-4.9
+    - clang
+    - valgrind
+os:
+  - linux
+language: cpp
+compiler:
+  - gcc
+  - clang
+script: ./travis.sh
+env:
+  matrix:
+    - SHARED_LIB=ON  STATIC_LIB=ON CMAKE_PKG=ON  BUILD_TYPE=release VERBOSE_MAKE=false
+    - SHARED_LIB=OFF STATIC_LIB=ON CMAKE_PKG=OFF BUILD_TYPE=debug   VERBOSE_MAKE=true VERBOSE
+notifications:
+  email: false
+sudo: false
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/version polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/version
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/version	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/version	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+1.7.7
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/version.in polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/version.in
--- polybar-3.2.1.orig/lib/i3ipcpp/libs/jsoncpp-1.7.7/version.in	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/libs/jsoncpp-1.7.7/version.in	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1 @@
+@JSONCPP_VERSION@
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/README.md polybar-3.2.1/lib/i3ipcpp/README.md
--- polybar-3.2.1.orig/lib/i3ipcpp/README.md	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/README.md	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,129 @@
+[![License](http://img.shields.io/:license-mit-blue.svg)](http://doge.mit-license.org)
+
+i3ipc++
+=======
+An implementation of i3 IPC in C++11.
+
+## Requirements
+
+* cmake (>= 3.0)
+* C++11 compiler
+* sigc++ 2.0
+* jsoncpp
+
+## Using
+Yet the only way of using is to add this repo as a submodule
+
+```bash
+git submodule add https://github.com/drmgc/i3ipcpp.git ./i3ipc++/
+```
+
+Then just type this in your `CMakeLists.txt`:
+
+```cmake
+...
+add_subdirectory(i3ipc++)
+
+include_directories(${I3IPCpp_INCLUDE_DIRS})
+link_directories(${I3IPCpp_LIBRARY_DIRS})
+...
+```
+
+And then just link:
+
+```cmake
+...
+target_link_libraries(someapp ${I3IPCpp_LIBRARIES})
+...
+```
+
+## Usage
+
+See also examples in `examples/` directory.
+
+### Connecting
+
+```c++
+#include <i3ipc++/ipc.hpp>
+
+i3ipc::connection  conn;
+```
+
+The connection will be established automaticly.
+
+### Event handling
+
+First of all you need to declare the events you want to handle. As example we want to handle an binding and workspace events:
+```c++
+conn.subscribe(i3ipc::ET_WORKSPACE | i3ipc::ET_BINDING);
+```
+
+Then we need to connect to the signal handlers:
+```c++
+// Handler of WORKSPACE EVENT
+conn.signal_workspace_event.connect([](const i3ipc::workspace_event_t&  ev) {
+	std::cout << "workspace_event: " << (char)ev.type << std::endl;
+	if (ev.current) {
+		std::cout << "\tSwitched to #" << ev.current->num << " - \"" << ev.current->name << '"' << std::endl;
+	}
+});
+
+// Handler of binding event
+conn.signal_binding_event.connect([](const i3ipc::binding_t&  b) {
+	std::cout << "binding_event:" << std::endl
+		<< "\tcommand = \"" << b.command << '"' << std::endl
+		<< "\tinput_code = " << b.input_code << std::endl
+		<< "\tsymbol = " << b.symbol << std::endl
+		<< "\tinput_type = " << static_cast<char>(b.input_type) << std::endl
+		<< "\tevent_state_mask =" << std::endl;
+	for (const std::string& s : b.event_state_mask) {
+		std::cout << "\t\t\"" << s << '"' << std::endl;
+	}
+});
+```
+
+Then we starting the event-handling loop
+```c++
+while (true) {
+	conn.handle_event();
+}
+```
+
+**Note:** If you want to interract with event_socket or just want to prepare manually you can call `conn.connect_event_socket()` (if you want to reconnect `conn.connect_event_socket(true)`), but if by default `connect_event_socket()` called on first `handle_event()` call.
+
+### Requesting
+
+Also you can request some data from i3, as example barconfigs:
+```c++
+std::vector<std::string>  bar_configs = conn.get_bar_configs_list();
+```
+
+And then do with them something:
+```c++
+for (auto&  name : bar_configs) {
+	std::shared_ptr<i3ipc::bar_config_t>  bc = conn.get_bar_config(name);
+
+	// ... handling
+}
+```
+
+### Sending commands
+
+And, of course, you can command i3:
+```c++
+if (!conn.send_command("exit")) {
+	throw std::string("Failed to exit via command");
+}
+```
+
+## Version i3 support
+It is written according to the *current* specification, so some of new features in IPC can be not-implemented. If there is some of them, please notice at issues page.
+
+## Documentation
+The latest documentation you can find [**here**](http://drmgc.github.io/docs/api-ref/i3ipc++/latest/)
+
+## Licensing
+This library is licensed under under the MIT license, but it also uses [`JsonCpp`](https://github.com/open-source-parsers/jsoncpp) (*only for parsing i3's replies*) and my header-only library [`auss`](https://github.com/drmgc/auss)
+
+## Backward compatibility note
+While version is `0.x` there can be a lack of backward compatibility between minor releases, please see release notes.
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/src/ipc.cpp polybar-3.2.1/lib/i3ipcpp/src/ipc.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/src/ipc.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/src/ipc.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,630 @@
+#include <cstdio>
+#include <cstring>
+#include <stdexcept>
+#include <iostream>
+
+#include <json/json.h>
+#include <auss.hpp>
+
+#include "i3ipc++/ipc-util.hpp"
+#include "i3ipc++/ipc.hpp"
+#include "i3ipc++/log.hpp"
+
+namespace i3ipc {
+
+// For log.hpp
+std::vector<std::ostream*>  g_logging_outs = {
+	&std::cout,
+};
+std::vector<std::ostream*>  g_logging_err_outs = {
+	&std::cerr,
+};
+
+#define IPC_JSON_READ(ROOT) \
+{ \
+	Json::CharReaderBuilder b; \
+	Json::CharReader* reader(b.newCharReader()); \
+	JSONCPP_STRING error; \
+	if(!reader->parse(buf->payload, buf->payload + buf->header->size, &ROOT, &error)) { \
+		throw invalid_reply_payload_error(auss_t() << "Failed to parse reply on \"" i3IPC_TYPE_STR "\": " << error); \
+	} \
+}
+
+#define IPC_JSON_ASSERT_TYPE(OBJ, OBJ_DESCR, TYPE_CHECK, TYPE_NAME) \
+	{\
+		if (!(OBJ).TYPE_CHECK()) { \
+			throw invalid_reply_payload_error(auss_t() << "Failed to parse reply on \"" i3IPC_TYPE_STR "\": " OBJ_DESCR " expected to be " TYPE_NAME); \
+		} \
+	}
+#define IPC_JSON_ASSERT_TYPE_OBJECT(OBJ, OBJ_DESCR) IPC_JSON_ASSERT_TYPE(OBJ, OBJ_DESCR, isObject, "an object")
+#define IPC_JSON_ASSERT_TYPE_ARRAY(OBJ, OBJ_DESCR) IPC_JSON_ASSERT_TYPE(OBJ, OBJ_DESCR, isArray, "an array")
+#define IPC_JSON_ASSERT_TYPE_BOOL(OBJ, OBJ_DESCR) IPC_JSON_ASSERT_TYPE(OBJ, OBJ_DESCR, isBool, "a bool")
+#define IPC_JSON_ASSERT_TYPE_INT(OBJ, OBJ_DESCR) IPC_JSON_ASSERT_TYPE(OBJ, OBJ_DESCR, isInt, "an integer")
+
+
+inline rect_t  parse_rect_from_json(const Json::Value&  value) {
+	rect_t r{};
+	r.x = value["x"].asUInt();
+	r.y = value["y"].asUInt();
+	r.width = value["width"].asUInt();
+	r.height = value["height"].asUInt();
+	return r;
+}
+
+
+static std::shared_ptr<container_t>  parse_container_from_json(const Json::Value&  o) {
+#define i3IPC_TYPE_STR "PARSE CONTAINER FROM JSON"
+	if (o.isNull())
+		return std::shared_ptr<container_t>();
+	std::shared_ptr<container_t>  container (new container_t());
+	IPC_JSON_ASSERT_TYPE_OBJECT(o, "o")
+
+	container->id = o["id"].asUInt64();
+	container->xwindow_id= o["window"].asUInt64();
+	container->name = o["name"].asString();
+	container->type = o["type"].asString();
+	container->current_border_width = o["current_border_width"].asInt();
+	container->percent = o["percent"].asFloat();
+	container->rect = parse_rect_from_json(o["rect"]);
+	container->window_rect = parse_rect_from_json(o["window_rect"]);
+	container->deco_rect = parse_rect_from_json(o["deco_rect"]);
+	container->geometry = parse_rect_from_json(o["geometry"]);
+	container->urgent = o["urgent"].asBool();
+	container->focused = o["focused"].asBool();
+
+	container->border = BorderStyle::UNKNOWN;
+	std::string  border = o["border"].asString();
+	if (border == "normal") {
+		container->border = BorderStyle::NORMAL;
+	} else if (border == "none") {
+		container->border = BorderStyle::NONE;
+	} else if (border == "pixel") {
+		container->border = BorderStyle::PIXEL;
+	} else if (border == "1pixel") {
+		container->border = BorderStyle::ONE_PIXEL;
+	} else {
+		container->border_raw = border;
+		I3IPC_WARN("Got a unknown \"border\" property: \"" << border << "\". Perhaps its neccessary to update i3ipc++. If you are using latest, note maintainer about this")
+	}
+
+	container->layout = ContainerLayout::UNKNOWN;
+	std::string  layout = o["layout"].asString();
+
+	if (layout == "splith") {
+		container->layout = ContainerLayout::SPLIT_H;
+	} else if (layout == "splitv") {
+		container->layout = ContainerLayout::SPLIT_V;
+	} else if (layout == "stacked") {
+		container->layout = ContainerLayout::STACKED;
+	} else if (layout == "tabbed") {
+		container->layout = ContainerLayout::TABBED;
+	} else if (layout == "dockarea") {
+		container->layout = ContainerLayout::DOCKAREA;
+	} else if (layout == "output") {
+		container->layout = ContainerLayout::OUTPUT;
+	} else {
+		container->layout_raw = border;
+		I3IPC_WARN("Got a unknown \"layout\" property: \"" << layout << "\". Perhaps its neccessary to update i3ipc++. If you are using latest, note maintainer about this")
+	}
+
+	Json::Value  nodes = o["nodes"];
+	if (!nodes.isNull()) {
+		IPC_JSON_ASSERT_TYPE_ARRAY(nodes, "nodes")
+		for (Json::ArrayIndex  i = 0; i < nodes.size(); i++) {
+			container->nodes.push_back(parse_container_from_json(nodes[i]));
+		}
+	}
+
+	return container;
+#undef i3IPC_TYPE_STR
+}
+
+static std::shared_ptr<workspace_t>  parse_workspace_from_json(const Json::Value&  value) {
+	if (value.isNull())
+		return std::shared_ptr<workspace_t>();
+	Json::Value  num = value["num"];
+	Json::Value  name = value["name"];
+	Json::Value  visible = value["visible"];
+	Json::Value  focused = value["focused"];
+	Json::Value  urgent = value["urgent"];
+	Json::Value  rect = value["rect"];
+	Json::Value  output = value["output"];
+
+	std::shared_ptr<workspace_t>  p (new workspace_t());
+	p->num = num.asInt();
+	p->name = name.asString();
+	p->visible = visible.asBool();
+	p->focused = focused.asBool();
+	p->urgent = urgent.asBool();
+	p->rect = parse_rect_from_json(rect);
+	p->output = output.asString();
+	return p;
+}
+
+static std::shared_ptr<output_t>  parse_output_from_json(const Json::Value&  value) {
+	if (value.isNull())
+		return std::shared_ptr<output_t>();
+	Json::Value  name = value["name"];
+	Json::Value  active = value["active"];
+	Json::Value  current_workspace = value["current_workspace"];
+	Json::Value  rect = value["rect"];
+
+	std::shared_ptr<output_t>  p (new output_t());
+	p->name = name.asString();
+	p->active = active.asBool();
+	p->current_workspace = (current_workspace.isNull() ? std::string() : current_workspace.asString());
+	p->rect = parse_rect_from_json(rect);
+	return p;
+}
+
+static std::shared_ptr<binding_t>  parse_binding_from_json(const Json::Value&  value) {
+#define i3IPC_TYPE_STR "PARSE BINDING FROM JSON"
+	if (value.isNull())
+		return std::shared_ptr<binding_t>();
+	IPC_JSON_ASSERT_TYPE_OBJECT(value, "binding")
+	std::shared_ptr<binding_t>  b (new binding_t());
+
+	b->command = value["command"].asString();
+	b->symbol = value["symbol"].asString();
+	b->input_code = value["input_code"].asInt();
+
+	Json::Value input_type = value["input_type"].asString();
+	if (input_type == "keyboard") {
+		b->input_type = InputType::KEYBOARD;
+	} else if (input_type == "mouse") {
+		b->input_type = InputType::MOUSE;
+	} else {
+		b->input_type = InputType::UNKNOWN;
+	}
+
+	Json::Value  esm_arr = value["event_state_mask"];
+	IPC_JSON_ASSERT_TYPE_ARRAY(esm_arr, "event_state_mask")
+
+	b->event_state_mask.resize(esm_arr.size());
+
+	for (Json::ArrayIndex  i = 0; i < esm_arr.size(); i++) {
+		b->event_state_mask[i] = esm_arr[i].asString();
+	}
+
+	return b;
+#undef i3IPC_TYPE_STR
+}
+
+static std::shared_ptr<mode_t>  parse_mode_from_json(const Json::Value&  value) {
+	if (value.isNull())
+		return std::shared_ptr<mode_t>();
+	Json::Value  change = value["change"];
+	Json::Value  pango_markup = value["pango_markup"];
+
+	std::shared_ptr<mode_t>  p (new mode_t());
+	p->change = change.asString();
+	p->pango_markup = pango_markup.asBool();
+	return p;
+}
+
+
+static std::shared_ptr<bar_config_t>  parse_bar_config_from_json(const Json::Value&  value) {
+#define i3IPC_TYPE_STR "PARSE BAR CONFIG FROM JSON"
+	if (value.isNull())
+		return std::shared_ptr<bar_config_t>();
+	IPC_JSON_ASSERT_TYPE_OBJECT(value, "(root)")
+	std::shared_ptr<bar_config_t>  bc (new bar_config_t());
+
+	bc->id = value["id"].asString();
+	bc->status_command = value["status_command"].asString();
+	bc->font = value["font"].asString();
+	bc->workspace_buttons = value["workspace_buttons"].asBool();
+	bc->binding_mode_indicator = value["binding_mode_indicator"].asBool();
+	bc->verbose = value["verbose"].asBool();
+
+	std::string  mode = value["mode"].asString();
+	if (mode == "dock") {
+		bc->mode = BarMode::DOCK;
+	} else if (mode == "hide") {
+		bc->mode = BarMode::HIDE;
+	} else {
+		bc->mode = BarMode::UNKNOWN;
+		I3IPC_WARN("Got a unknown \"mode\" property: \"" << mode << "\". Perhaps its neccessary to update i3ipc++. If you are using latest, note maintainer about this")
+	}
+
+	std::string  position = value["position"].asString();
+	if (position == "top") {
+		bc->position = Position::TOP;
+	} else if (mode == "bottom") {
+		bc->position = Position::BOTTOM;
+	} else {
+		bc->position = Position::UNKNOWN;
+		I3IPC_WARN("Got a unknown \"position\" property: \"" << position << "\". Perhaps its neccessary to update i3ipc++. If you are using latest, note maintainer about this")
+	}
+
+	Json::Value  colors = value["colors"];
+	IPC_JSON_ASSERT_TYPE_OBJECT(value, "colors")
+	auto  colors_list = colors.getMemberNames();
+	for (auto&  m : colors_list) {
+		bc->colors[m] = std::stoul(colors[m].asString().substr(1), nullptr, 16);
+	}
+
+	return bc;
+#undef i3IPC_TYPE_STR
+}
+
+
+std::string  get_socketpath() {
+	std::string  str;
+	{
+		auss_t  str_buf;
+		FILE*  in;
+		char  buf[512] = {0};
+		if (!(in = popen("i3 --get-socketpath", "r"))) {
+			throw errno_error("Failed to get socket path");
+		}
+
+		while (fgets(buf, sizeof(buf), in) != nullptr) {
+			str_buf << buf;
+		}
+		pclose(in);
+		str = str_buf;
+	}
+	if (str.back() == '\n') {
+		str.pop_back();
+	}
+	return str;
+}
+
+
+connection::connection(const std::string&  socket_path) : m_main_socket(i3_connect(socket_path)), m_event_socket(-1), m_subscriptions(0), m_socket_path(socket_path) {
+#define i3IPC_TYPE_STR "i3's event"
+	on_event = [this](EventType  event_type, const std::shared_ptr<const buf_t>&  buf) {
+		switch (event_type) {
+		case ET_WORKSPACE: {
+			workspace_event_t  ev;
+			Json::Value  root;
+			IPC_JSON_READ(root);
+			std::string  change = root["change"].asString();
+			if (change == "focus") {
+				ev.type = WorkspaceEventType::FOCUS;
+			} else if (change == "init") {
+				ev.type = WorkspaceEventType::INIT;
+			} else if (change == "empty") {
+				ev.type = WorkspaceEventType::EMPTY;
+			} else if (change == "urgent") {
+				ev.type = WorkspaceEventType::URGENT;
+			} else if (change == "rename") {
+				ev.type = WorkspaceEventType::RENAME;
+			} else if (change == "reload") {
+				ev.type = WorkspaceEventType::RELOAD;
+			} else if (change == "restored") {
+				ev.type = WorkspaceEventType::RESTORED;
+			} else {
+				I3IPC_WARN("Unknown workspace event type " << change)
+				break;
+			}
+			I3IPC_DEBUG("WORKSPACE " << change)
+
+			Json::Value  current = root["current"];
+			Json::Value  old = root["old"];
+
+			if (!current.isNull()) {
+				ev.current = parse_workspace_from_json(current);
+			}
+			if (!old.isNull()) {
+				ev.old = parse_workspace_from_json(old);
+			}
+
+			if (on_workspace_event) {
+				on_workspace_event(ev);
+			}
+			break;
+		}
+		case ET_OUTPUT:
+			I3IPC_DEBUG("OUTPUT")
+			if (on_output_event) {
+				on_output_event();
+			}
+			break;
+		case ET_MODE: {
+			I3IPC_DEBUG("MODE")
+			Json::Value  root;
+			IPC_JSON_READ(root);
+			std::shared_ptr<mode_t>  mode_data = parse_mode_from_json(root);
+			if (on_mode_event) {
+				on_mode_event(*mode_data);
+			}
+			break;
+		}
+		case ET_WINDOW: {
+			window_event_t  ev;
+			Json::Value  root;
+			IPC_JSON_READ(root);
+			std::string  change = root["change"].asString();
+			if (change == "new") {
+				ev.type = WindowEventType::NEW;
+			} else if (change == "close") {
+				ev.type = WindowEventType::CLOSE;
+			} else if (change == "focus") {
+				ev.type = WindowEventType::FOCUS;
+			} else if (change == "title") {
+				ev.type = WindowEventType::TITLE;
+			} else if (change == "fullscreen_mode") {
+				ev.type = WindowEventType::FULLSCREEN_MODE;
+			} else if (change == "move") {
+				ev.type = WindowEventType::MOVE;
+			} else if (change == "floating") {
+				ev.type = WindowEventType::FLOATING;
+			} else if (change == "urgent") {
+				ev.type = WindowEventType::URGENT;
+			}
+			I3IPC_DEBUG("WINDOW " << change)
+
+			Json::Value  container = root["container"];
+			if (!container.isNull()) {
+				ev.container = parse_container_from_json(container);
+			}
+
+			if (on_window_event) {
+				on_window_event(ev);
+			}
+			break;
+		}
+		case ET_BARCONFIG_UPDATE: {
+			I3IPC_DEBUG("BARCONFIG_UPDATE")
+			Json::Value  root;
+			IPC_JSON_READ(root);
+			std::shared_ptr<bar_config_t>  barconf = parse_bar_config_from_json(root);
+			if (on_barconfig_update_event) {
+				on_barconfig_update_event(*barconf);
+			}
+			break;
+		}
+		case ET_BINDING: {
+			Json::Value  root;
+			IPC_JSON_READ(root);
+			std::string  change = root["change"].asString();
+			if (change != "run") {
+				I3IPC_WARN("Got \"" << change << "\" in field \"change\" of binding_event. Expected \"run\"")
+			}
+
+			Json::Value  binding_json = root["binding"];
+			std::shared_ptr<binding_t>  bptr;
+			if (!binding_json.isNull()) {
+				bptr = parse_binding_from_json(binding_json);
+			}
+
+			if (!bptr) {
+				I3IPC_ERR("Failed to parse field \"binding\" from binding_event")
+			} else {
+				I3IPC_DEBUG("BINDING " << bptr->symbol);
+				if (on_binding_event) {
+					on_binding_event(*bptr);
+				}
+			}
+			break;
+		}
+		};
+	};
+#undef i3IPC_TYPE_STR
+}
+connection::~connection() {
+	i3_disconnect(m_main_socket);
+	if (m_event_socket > 0)
+		this->disconnect_event_socket();
+}
+
+
+void  connection::connect_event_socket(const bool  reconnect) {
+	if (m_event_socket > 0) {
+		if (reconnect) {
+			this->disconnect_event_socket();
+		} else {
+			I3IPC_ERR("Trying to initialize event socket secondary")
+			return;
+		}
+	}
+	m_event_socket = i3_connect(m_socket_path);
+	this->subscribe(m_subscriptions);
+}
+
+
+void  connection::disconnect_event_socket() {
+	if (m_event_socket <= 0) {
+		I3IPC_WARN("Trying to disconnect non-connected event socket")
+		return;
+	}
+	i3_disconnect(m_event_socket);
+}
+
+
+bool connection::handle_event() {
+	if (m_event_socket <= 0) {
+		this->connect_event_socket();
+	}
+
+	auto buf = i3_recv(m_event_socket);
+
+	if (buf && this->on_event) {
+		this->on_event(static_cast<EventType>(1 << (buf->header->type & 0x7f)), std::static_pointer_cast<const buf_t>(buf));
+	} else if (buf) {
+		return true;
+	}
+	return false;
+}
+
+
+bool  connection::subscribe(const int32_t  events) {
+#define i3IPC_TYPE_STR "SUBSCRIBE"
+	if (m_event_socket <= 0) {
+		m_subscriptions |= events;
+		return true;
+	}
+	std::string  payload;
+	{
+		auss_t  payload_auss;
+		if (events & static_cast<int32_t>(ET_WORKSPACE)) {
+			payload_auss << "\"workspace\",";
+		}
+		if (events & static_cast<int32_t>(ET_OUTPUT)) {
+			payload_auss << "\"output\",";
+		}
+		if (events & static_cast<int32_t>(ET_MODE)) {
+			payload_auss << "\"mode\",";
+		}
+		if (events & static_cast<int32_t>(ET_WINDOW)) {
+			payload_auss << "\"window\",";
+		}
+		if (events & static_cast<int32_t>(ET_BARCONFIG_UPDATE)) {
+			payload_auss << "\"barconfig_update\",";
+		}
+		if (events & static_cast<int32_t>(ET_BINDING)) {
+			payload_auss << "\"binding\",";
+		}
+		payload = payload_auss;
+		if (payload.empty()) {
+			return true;
+		}
+		payload.pop_back();
+	}
+	I3IPC_DEBUG("i3 IPC subscriptions: " << payload)
+
+	auto  buf = i3_msg(m_event_socket, ClientMessageType::SUBSCRIBE, auss_t() << '[' << payload << ']');
+	Json::Value  root;
+	IPC_JSON_READ(root)
+
+	m_subscriptions |= events;
+
+	return root["success"].asBool();
+#undef i3IPC_TYPE_STR
+}
+
+
+version_t  connection::get_version() const {
+#define i3IPC_TYPE_STR "GET_VERSION"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_VERSION);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	IPC_JSON_ASSERT_TYPE_OBJECT(root, "root")
+
+	version_t v{};
+	v.human_readable = root["human_readable"].asString();
+	v.loaded_config_file_name = root["loaded_config_file_name"].asString();
+	v.major = root["major"].asUInt();
+	v.minor = root["minor"].asUInt();
+	v.patch = root["patch"].asUInt();
+	return v;
+#undef i3IPC_TYPE_STR
+}
+
+
+std::shared_ptr<container_t>  connection::get_tree() const {
+#define i3IPC_TYPE_STR "GET_TREE"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_TREE);
+	Json::Value  root;
+	IPC_JSON_READ(root);
+	return parse_container_from_json(root);
+#undef i3IPC_TYPE_STR
+}
+
+
+std::vector< std::shared_ptr<output_t> >  connection::get_outputs() const {
+#define i3IPC_TYPE_STR "GET_OUTPUTS"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_OUTPUTS);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	IPC_JSON_ASSERT_TYPE_ARRAY(root, "root")
+
+	std::vector< std::shared_ptr<output_t> >  outputs;
+
+	for (auto w : root) {
+		outputs.push_back(parse_output_from_json(w));
+	}
+
+	return outputs;
+#undef i3IPC_TYPE_STR
+}
+
+
+std::vector< std::shared_ptr<workspace_t> >  connection::get_workspaces() const {
+#define i3IPC_TYPE_STR "GET_WORKSPACES"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_WORKSPACES);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	IPC_JSON_ASSERT_TYPE_ARRAY(root, "root")
+
+	std::vector< std::shared_ptr<workspace_t> >  workspaces;
+
+	for (auto w : root) {
+		workspaces.push_back(parse_workspace_from_json(w));
+	}
+
+	return workspaces;
+#undef i3IPC_TYPE_STR
+}
+
+
+std::vector<std::string>  connection::get_bar_configs_list() const {
+#define i3IPC_TYPE_STR "GET_BAR_CONFIG (get_bar_configs_list)"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_BAR_CONFIG);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	IPC_JSON_ASSERT_TYPE_ARRAY(root, "root")
+
+	std::vector<std::string>  l;
+
+	for (auto w : root) {
+		l.push_back(w.asString());
+	}
+
+	return l;
+#undef i3IPC_TYPE_STR
+}
+
+
+std::shared_ptr<bar_config_t>  connection::get_bar_config(const std::string&  name) const {
+#define i3IPC_TYPE_STR "GET_BAR_CONFIG"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::GET_BAR_CONFIG, name);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	return parse_bar_config_from_json(root);
+#undef i3IPC_TYPE_STR
+}
+
+
+bool  connection::send_command(const std::string&  command) const {
+#define i3IPC_TYPE_STR "COMMAND"
+	auto  buf = i3_msg(m_main_socket, ClientMessageType::COMMAND, command);
+	Json::Value  root;
+	IPC_JSON_READ(root)
+	IPC_JSON_ASSERT_TYPE_ARRAY(root, "root")
+	Json::Value  payload = root[0];
+	IPC_JSON_ASSERT_TYPE_OBJECT(payload, " first item of root")
+
+	if (payload["success"].asBool()) {
+		return true;
+	} else {
+		Json::Value  error = payload["error"];
+		if (!error.isNull()) {
+			I3IPC_ERR("Failed to execute command: " << error.asString())
+		}
+		return false;
+	}
+#undef i3IPC_TYPE_STR
+}
+
+int32_t  connection::get_main_socket_fd() { return m_main_socket; }
+
+int32_t  connection::get_event_socket_fd() { return m_event_socket; }
+
+
+const version_t&  get_version() {
+#define I3IPC_VERSION_MAJOR  0
+#define I3IPC_VERSION_MINOR  4
+#define I3IPC_VERSION_PATCH  0
+	static version_t v{};
+	v.human_readable = auss_t() << I3IPC_VERSION_MAJOR << '.' << I3IPC_VERSION_MINOR << '.' << I3IPC_VERSION_PATCH;
+	v.loaded_config_file_name = std::string();
+	v.major = I3IPC_VERSION_MAJOR;
+	v.minor = I3IPC_VERSION_MINOR;
+	v.patch = I3IPC_VERSION_PATCH;
+	return v;
+}
+
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/src/ipc-util.cpp polybar-3.2.1/lib/i3ipcpp/src/ipc-util.cpp
--- polybar-3.2.1.orig/lib/i3ipcpp/src/ipc-util.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/src/ipc-util.cpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,172 @@
+extern "C" {
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <errno.h>
+}
+
+#include <cstring>
+#include <ios>
+
+#include <auss.hpp>
+
+#include "i3ipc++/ipc-util.hpp"
+
+namespace i3ipc {
+
+static std::string  format_errno(const std::string&  msg = std::string()) {
+	auss_t  a;
+	if (msg.size() > 0)
+		a << msg << ": ";
+	a << "errno " << errno << " (" << strerror(errno) << ')';
+	return a;
+}
+
+errno_error::errno_error() : ipc_error(format_errno()) {}
+errno_error::errno_error(const std::string&  msg) : ipc_error(format_errno(msg)) {}
+
+static const std::string  g_i3_ipc_magic = "i3-ipc";
+
+buf_t::buf_t(uint32_t  payload_size) : size(sizeof(header_t) + payload_size) {
+	data = new uint8_t[size];
+	header = (header_t*)data;
+	payload = (char*)(data + sizeof(header_t));
+	strncpy(header->magic, g_i3_ipc_magic.c_str(), sizeof(header->magic));
+	header->size = payload_size;
+	header->type = 0x0;
+}
+buf_t::~buf_t() {
+	delete[] data;
+}
+
+void  buf_t::realloc_payload_to_header() {
+	uint8_t*  new_data = new uint8_t[sizeof(header_t) + header->size];
+	memcpy(new_data, header, sizeof(header_t));
+	delete[] data;
+	data = new_data;
+	header = (header_t*)data;
+	payload = (char*)(data + sizeof(header_t));
+}
+
+
+int32_t  i3_connect(const std::string&  socket_path) {
+	int32_t  sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (sockfd == -1) {
+		throw errno_error("Could not create a socket");
+	}
+
+	(void)fcntl(sockfd, F_SETFD, FD_CLOEXEC); // What for?
+
+	struct sockaddr_un addr;
+	memset(&addr, 0, sizeof(struct sockaddr_un));
+	addr.sun_family = AF_LOCAL;
+	strncpy(addr.sun_path, socket_path.c_str(), sizeof(addr.sun_path) - 1);
+	if (connect(sockfd, (const struct sockaddr*)&addr, sizeof(struct sockaddr_un)) < 0) {
+		throw errno_error("Failed to connect to i3");
+	}
+
+	return sockfd;
+}
+
+
+void  i3_disconnect(const int32_t  sockfd) {
+	close(sockfd);
+}
+
+
+std::shared_ptr<buf_t>  i3_pack(const ClientMessageType  type, const std::string&  payload) {
+	buf_t*  buff = new buf_t(payload.length());
+	buff->header->type = static_cast<uint32_t>(type);
+	strncpy(buff->payload, payload.c_str(), buff->header->size);
+	return std::shared_ptr<buf_t>(buff);
+}
+
+ssize_t  writeall(int  fd, const uint8_t*  buf, size_t  count) {
+	size_t written = 0;
+	ssize_t n = 0;
+
+	while (written < count) {
+		n = write(fd, buf + written, count - written);
+		if (n == -1) {
+			if (errno == EINTR || errno == EAGAIN)
+				continue;
+			return n;
+		}
+		written += (size_t)n;
+	}
+
+	return written;
+}
+
+ssize_t  swrite(int  fd, const uint8_t*  buf, size_t  count) {
+	ssize_t n;
+
+	n = writeall(fd, buf, count);
+	if (n == -1)
+		throw errno_error(auss_t() << "Failed to write " << std::hex << fd);
+	else
+		return n;
+}
+
+void   i3_send(const int32_t  sockfd, const buf_t&  buff) {
+	swrite(sockfd, buff.data, buff.size);
+}
+
+std::shared_ptr<buf_t>   i3_recv(const int32_t  sockfd) {
+	auto buff = std::make_shared<buf_t>(0);
+	const uint32_t  header_size = sizeof(header_t);
+
+	{
+		uint8_t*  header = (uint8_t*)buff->header;
+		uint32_t  readed = 0;
+		while (readed < header_size) {
+			int  n = read(sockfd, header + readed, header_size - readed);
+			if (n == -1) {
+				throw errno_error(auss_t() << "Failed to read header from socket 0x" << std::hex << sockfd);
+			}
+			if (n == 0) {
+				throw eof_error("Unexpected EOF while reading header");
+			}
+
+			readed += n;
+		}
+	}
+
+	if (g_i3_ipc_magic != std::string(buff->header->magic, g_i3_ipc_magic.length())) {
+		throw invalid_header_error("Invalid magic in reply");
+	}
+
+	buff->realloc_payload_to_header();
+
+	{
+		uint32_t  readed = 0;
+		int n;
+		while (readed < buff->header->size) {
+			if ((n = read(sockfd, buff->payload + readed, buff->header->size - readed)) == -1) {
+				if (errno == EINTR || errno == EAGAIN)
+					continue;
+				throw errno_error(auss_t() << "Failed to read payload from socket 0x" << std::hex << sockfd);
+			}
+
+			readed += n;
+		}
+	}
+
+	return buff;
+}
+
+
+std::shared_ptr<buf_t>  i3_msg(const int32_t  sockfd, const ClientMessageType  type, const std::string&  payload) {
+	auto  send_buff = i3_pack(type, payload);
+	i3_send(sockfd, *send_buff);
+	auto  recv_buff = i3_recv(sockfd);
+	if (send_buff->header->type != recv_buff->header->type) {
+		throw invalid_header_error(auss_t() << "Invalid reply type: Expected 0x" << std::hex << send_buff->header->type << ", got 0x" << recv_buff->header->type);
+	}
+	return recv_buff;
+}
+
+}
diff -Nuar polybar-3.2.1.orig/lib/i3ipcpp/test/test_ipc.hpp polybar-3.2.1/lib/i3ipcpp/test/test_ipc.hpp
--- polybar-3.2.1.orig/lib/i3ipcpp/test/test_ipc.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/i3ipcpp/test/test_ipc.hpp	2017-12-03 19:05:22.000000000 +0300
@@ -0,0 +1,28 @@
+#include <iostream>
+
+#include <auss.hpp>
+
+#include "ipc-util.hpp"
+
+#include <cxxtest/TestSuite.h>
+
+class testsuite_ipc_util : public CxxTest::TestSuite {
+public:
+	void test_pack() {
+		{
+			using namespace i3ipc;
+			auto  buff = i3_pack(ClientMessageType::COMMAND, "exit");
+			auss_t  auss;
+			auss << std::hex;
+			for (uint32_t  i = 0; i < buff->size; i++) {
+				if (buff->data[i] < 0x10) {
+					auss << '0';
+				}
+				auss << static_cast<uint32_t>(buff->data[i]) << ' ';
+			}
+			std::string  str = auss;
+			str.pop_back();
+			TS_ASSERT_EQUALS(str, "69 33 2d 69 70 63 04 00 00 00 00 00 00 00 65 78 69 74")
+		}
+	}
+};
diff -Nuar polybar-3.2.1.orig/lib/xpp/cmake/FindX11_XCB.cmake polybar-3.2.1/lib/xpp/cmake/FindX11_XCB.cmake
--- polybar-3.2.1.orig/lib/xpp/cmake/FindX11_XCB.cmake	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/cmake/FindX11_XCB.cmake	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,31 @@
+# - Try to find libX11-xcb
+# Once done this will define
+#
+# X11_XCB_FOUND - system has libX11-xcb
+# X11_XCB_LIBRARIES - Link these to use libX11-xcb
+# X11_XCB_INCLUDE_DIR - the libX11-xcb include dir
+# X11_XCB_DEFINITIONS - compiler switches required for using libX11-xcb
+
+# Copyright (c) 2011 Fredrik HÃ¶glund <fredrik@kde.org>
+# Copyright (c) 2008 Helio Chissini de Castro, <helio@kde.org>
+# Copyright (c) 2007 Matthias Kretz, <kretz@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+IF (NOT WIN32)
+  # use pkg-config to get the directories and then use these values
+  # in the FIND_PATH() and FIND_LIBRARY() calls
+  FIND_PACKAGE(PkgConfig)
+  PKG_CHECK_MODULES(PKG_X11_XCB QUIET x11-xcb)
+
+  SET(X11_XCB_DEFINITIONS ${PKG_X11_XCB_CFLAGS})
+
+  FIND_PATH(X11_XCB_INCLUDE_DIR NAMES X11/Xlib-xcb.h HINTS ${PKG_X11_XCB_INCLUDE_DIRS})
+  FIND_LIBRARY(X11_XCB_LIBRARIES NAMES X11-xcb HINTS ${PKG_X11_XCB_LIBRARY_DIRS})
+
+  include(FindPackageHandleStandardArgs)
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(X11_XCB DEFAULT_MSG X11_XCB_LIBRARIES X11_XCB_INCLUDE_DIR)
+
+  MARK_AS_ADVANCED(X11_XCB_INCLUDE_DIR X11_XCB_LIBRARIES)
+ENDIF (NOT WIN32)
diff -Nuar polybar-3.2.1.orig/lib/xpp/cmake/FindXCB.cmake polybar-3.2.1/lib/xpp/cmake/FindXCB.cmake
--- polybar-3.2.1.orig/lib/xpp/cmake/FindXCB.cmake	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/cmake/FindXCB.cmake	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,250 @@
+# Try to find XCB on a Unix system
+#
+# This will define:
+#
+#   XCB_FOUND        - True if xcb is available
+#   XCB_LIBRARIES    - Link these to use xcb
+#   XCB_INCLUDE_DIRS - Include directory for xcb
+#   XCB_DEFINITIONS  - Compiler flags for using xcb
+#
+# In addition the following more fine grained variables will be defined:
+#
+#   XCB_XCB_FOUND        XCB_XCB_INCLUDE_DIR        XCB_XCB_LIBRARY
+#   XCB_UTIL_FOUND       XCB_UTIL_INCLUDE_DIR       XCB_UTIL_LIBRARY
+#   XCB_COMPOSITE_FOUND  XCB_COMPOSITE_INCLUDE_DIR  XCB_COMPOSITE_LIBRARY
+#   XCB_DAMAGE_FOUND     XCB_DAMAGE_INCLUDE_DIR     XCB_DAMAGE_LIBRARY
+#   XCB_XFIXES_FOUND     XCB_XFIXES_INCLUDE_DIR     XCB_XFIXES_LIBRARY
+#   XCB_RENDER_FOUND     XCB_RENDER_INCLUDE_DIR     XCB_RENDER_LIBRARY
+#   XCB_RANDR_FOUND      XCB_RANDR_INCLUDE_DIR      XCB_RANDR_LIBRARY
+#   XCB_SHAPE_FOUND      XCB_SHAPE_INCLUDE_DIR      XCB_SHAPE_LIBRARY
+#   XCB_DRI2_FOUND       XCB_DRI2_INCLUDE_DIR       XCB_DRI2_LIBRARY
+#   XCB_GLX_FOUND        XCB_GLX_INCLUDE_DIR        XCB_GLX_LIBRARY
+#   XCB_SHM_FOUND        XCB_SHM_INCLUDE_DIR        XCB_SHM_LIBRARY
+#   XCB_XV_FOUND         XCB_XV_INCLUDE_DIR         XCB_XV_LIBRARY
+#   XCB_SYNC_FOUND       XCB_SYNC_INCLUDE_DIR       XCB_SYNC_LIBRARY
+#   XCB_XTEST_FOUND      XCB_XTEST_INCLUDE_DIR      XCB_XTEST_LIBRARY
+#   XCB_ICCCM_FOUND      XCB_ICCCM_INCLUDE_DIR      XCB_ICCCM_LIBRARY
+#   XCB_EWMH_FOUND       XCB_EWMH_INCLUDE_DIR       XCB_EWMH_LIBRARY
+#   XCB_IMAGE_FOUND      XCB_IMAGE_INCLUDE_DIR      XCB_IMAGE_LIBRARY
+#   XCB_RENDERUTIL_FOUND XCB_RENDERUTIL_INCLUDE_DIR XCB_RENDERUTIL_LIBRARY
+#   XCB_KEYSYMS_FOUND    XCB_KEYSYMS_INCLUDE_DIR    XCB_KEYSYMS_LIBRARY
+#
+# Copyright (c) 2011 Fredrik HÃ¶glund <fredrik@kde.org>
+# Copyright (c) 2013 Martin GrÃ¤Ãlin <mgraesslin@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+set(knownComponents XCB
+                    COMPOSITE
+                    DAMAGE
+                    DRI2
+                    EWMH
+                    GLX
+                    ICCCM
+                    IMAGE
+                    KEYSYMS
+                    RANDR
+                    RENDER
+                    RENDERUTIL
+                    SHAPE
+                    SHM
+                    SYNC
+                    UTIL
+                    XFIXES
+                    XTEST
+                    XV
+                    XINERAMA
+                    XKB)
+
+unset(unknownComponents)
+
+set(pkgConfigModules)
+set(requiredComponents)
+
+if (XCB_FIND_COMPONENTS)
+  set(comps ${XCB_FIND_COMPONENTS})
+else()
+  set(comps ${knownComponents})
+endif()
+
+# iterate through the list of requested components, and check that we know them all.
+# If not, fail.
+foreach(comp ${comps})
+    list(FIND knownComponents ${comp} index )
+    if("${index}" STREQUAL "-1")
+        list(APPEND unknownComponents "${comp}")
+    else()
+        if("${comp}" STREQUAL "XCB")
+            list(APPEND pkgConfigModules "xcb")
+        elseif("${comp}" STREQUAL "COMPOSITE")
+            list(APPEND pkgConfigModules "xcb-composite")
+        elseif("${comp}" STREQUAL "DAMAGE")
+            list(APPEND pkgConfigModules "xcb-damage")
+        elseif("${comp}" STREQUAL "DRI2")
+            list(APPEND pkgConfigModules "xcb-dri2")
+        elseif("${comp}" STREQUAL "EWMH")
+            list(APPEND pkgConfigModules "xcb-ewmh")
+        elseif("${comp}" STREQUAL "GLX")
+            list(APPEND pkgConfigModules "xcb-glx")
+        elseif("${comp}" STREQUAL "ICCCM")
+            list(APPEND pkgConfigModules "xcb-icccm")
+        elseif("${comp}" STREQUAL "IMAGE")
+            list(APPEND pkgConfigModules "xcb-image")
+        elseif("${comp}" STREQUAL "KEYSYMS")
+            list(APPEND pkgConfigModules "xcb-keysyms")
+        elseif("${comp}" STREQUAL "RANDR")
+            list(APPEND pkgConfigModules "xcb-randr")
+        elseif("${comp}" STREQUAL "RENDER")
+            list(APPEND pkgConfigModules "xcb-render")
+        elseif("${comp}" STREQUAL "RENDERUTIL")
+            list(APPEND pkgConfigModules "xcb-renderutil")
+        elseif("${comp}" STREQUAL "SHAPE")
+            list(APPEND pkgConfigModules "xcb-shape")
+        elseif("${comp}" STREQUAL "SHM")
+            list(APPEND pkgConfigModules "xcb-shm")
+        elseif("${comp}" STREQUAL "SYNC")
+            list(APPEND pkgConfigModules "xcb-sync")
+        elseif("${comp}" STREQUAL "UTIL")
+            list(APPEND pkgConfigModules "xcb-util")
+        elseif("${comp}" STREQUAL "XFIXES")
+            list(APPEND pkgConfigModules "xcb-xfixes")
+        elseif("${comp}" STREQUAL "XTEST")
+            list(APPEND pkgConfigModules "xcb-xtest")
+        elseif("${comp}" STREQUAL "XV")
+            list(APPEND pkgConfigModules "xcb-xv")
+        elseif("${comp}" STREQUAL "XINERAMA")
+            list(APPEND pkgConfigModules "xcb-xinerama")
+        elseif("${comp}" STREQUAL "XKB")
+            list(APPEND pkgConfigModules "xcb-xkb")
+        endif()
+    endif()
+endforeach()
+
+
+if(DEFINED unknownComponents)
+   set(msgType STATUS)
+   if(XCB_FIND_REQUIRED)
+      set(msgType FATAL_ERROR)
+   endif()
+   if(NOT XCB_FIND_QUIETLY)
+      message(${msgType} "XCB: requested unknown components ${unknownComponents}")
+   endif()
+   return()
+endif()
+
+macro(_XCB_HANDLE_COMPONENT _comp)
+    set(_header )
+    set(_lib )
+    if("${_comp}" STREQUAL "XCB")
+        set(_header "xcb/xcb.h")
+        set(_lib "xcb")
+    elseif("${_comp}" STREQUAL "COMPOSITE")
+        set(_header "xcb/composite.h")
+        set(_lib "xcb-composite")
+    elseif("${_comp}" STREQUAL "DAMAGE")
+        set(_header "xcb/damage.h")
+        set(_lib "xcb-damage")
+    elseif("${_comp}" STREQUAL "DRI2")
+        set(_header "xcb/dri2.h")
+        set(_lib "xcb-dri2")
+    elseif("${_comp}" STREQUAL "EWMH")
+        set(_header "xcb/xcb_ewmh.h")
+        set(_lib "xcb-ewmh")
+    elseif("${_comp}" STREQUAL "GLX")
+        set(_header "xcb/glx.h")
+        set(_lib "xcb-glx")
+    elseif("${_comp}" STREQUAL "ICCCM")
+        set(_header "xcb/xcb_icccm.h")
+        set(_lib "xcb-icccm")
+    elseif("${_comp}" STREQUAL "IMAGE")
+        set(_header "xcb/xcb_image.h")
+        set(_lib "xcb-image")
+    elseif("${_comp}" STREQUAL "KEYSYMS")
+        set(_header "xcb/xcb_keysyms.h")
+        set(_lib "xcb-keysyms")
+    elseif("${_comp}" STREQUAL "RANDR")
+        set(_header "xcb/randr.h")
+        set(_lib "xcb-randr")
+    elseif("${_comp}" STREQUAL "RENDER")
+        set(_header "xcb/render.h")
+        set(_lib "xcb-render")
+    elseif("${_comp}" STREQUAL "RENDERUTIL")
+        set(_header "xcb/xcb_renderutil.h")
+        set(_lib "xcb-render-util")
+    elseif("${_comp}" STREQUAL "SHAPE")
+        set(_header "xcb/shape.h")
+        set(_lib "xcb-shape")
+    elseif("${_comp}" STREQUAL "SHM")
+        set(_header "xcb/shm.h")
+        set(_lib "xcb-shm")
+    elseif("${_comp}" STREQUAL "SYNC")
+        set(_header "xcb/sync.h")
+        set(_lib "xcb-sync")
+    elseif("${_comp}" STREQUAL "UTIL")
+        set(_header "xcb/xcb_util.h")
+        set(_lib "xcb-util")
+    elseif("${_comp}" STREQUAL "XFIXES")
+        set(_header "xcb/xfixes.h")
+        set(_lib "xcb-xfixes")
+    elseif("${_comp}" STREQUAL "XTEST")
+        set(_header "xcb/xtest.h")
+        set(_lib "xcb-xtest")
+    elseif("${_comp}" STREQUAL "XV")
+        set(_header "xcb/xv.h")
+        set(_lib "xcb-xv")
+    elseif("${_comp}" STREQUAL "XINERAMA")
+        set(_header "xcb/xinerama.h")
+        set(_lib "xcb-xinerama")
+    elseif("${_comp}" STREQUAL "XKB")
+        set(_header "xcb/xkb.h")
+        set(_lib "xcb-xkb")
+    endif()
+
+    find_path(XCB_${_comp}_INCLUDE_DIR NAMES ${_header} HINTS ${PKG_XCB_INCLUDE_DIRS})
+    find_library(XCB_${_comp}_LIBRARY NAMES ${_lib} HINTS ${PKG_XCB_LIBRARY_DIRS})
+
+    if(XCB_${_comp}_INCLUDE_DIR AND XCB_${_comp}_LIBRARY)
+        list(APPEND XCB_INCLUDE_DIRS ${XCB_${_comp}_INCLUDE_DIR})
+        list(APPEND XCB_LIBRARIES ${XCB_${_comp}_LIBRARY})
+        if (NOT XCB_FIND_QUIETLY)
+            message(STATUS "XCB[${_comp}]: Found component ${_comp}")
+        endif()
+    endif()
+
+    if(XCB_FIND_REQUIRED_${_comp})
+        list(APPEND requiredComponents XCB_${_comp}_FOUND)
+    endif()
+
+    find_package_handle_standard_args(XCB_${_comp} DEFAULT_MSG XCB_${_comp}_LIBRARY XCB_${_comp}_INCLUDE_DIR)
+
+    mark_as_advanced(XCB_${_comp}_LIBRARY XCB_${_comp}_INCLUDE_DIR)
+
+    # compatibility for old variable naming
+    set(XCB_${_comp}_INCLUDE_DIRS ${XCB_${_comp}_INCLUDE_DIR})
+    set(XCB_${_comp}_LIBRARIES ${XCB_${_comp}_LIBRARY})
+endmacro()
+
+IF (NOT WIN32)
+    include(FindPackageHandleStandardArgs)
+    # Use pkg-config to get the directories and then use these values
+    # in the FIND_PATH() and FIND_LIBRARY() calls
+    find_package(PkgConfig)
+    pkg_check_modules(PKG_XCB QUIET ${pkgConfigModules})
+
+    set(XCB_DEFINITIONS ${PKG_XCB_CFLAGS})
+
+    foreach(comp ${comps})
+        _xcb_handle_component(${comp})
+    endforeach()
+
+    if(XCB_INCLUDE_DIRS)
+        list(REMOVE_DUPLICATES XCB_INCLUDE_DIRS)
+    endif()
+
+    find_package_handle_standard_args(XCB DEFAULT_MSG XCB_LIBRARIES XCB_INCLUDE_DIRS ${requiredComponents})
+
+    # compatibility for old variable naming
+    set(XCB_INCLUDE_DIR ${XCB_INCLUDE_DIRS})
+
+ENDIF (NOT WIN32)
diff -Nuar polybar-3.2.1.orig/lib/xpp/CMakeLists.txt polybar-3.2.1/lib/xpp/CMakeLists.txt
--- polybar-3.2.1.orig/lib/xpp/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/CMakeLists.txt	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,178 @@
+cmake_minimum_required(VERSION 3.0 FATAL_ERROR)
+project(xpp)
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${PROJECT_SOURCE_DIR}/cmake)
+
+#
+# Process dependencies
+#
+find_package(PkgConfig)
+pkg_check_modules(XCBPROTO REQUIRED xcb-proto)
+
+find_package(PythonInterp 2.7 REQUIRED)
+find_package(XCB REQUIRED XCB ICCCM EWMH UTIL IMAGE)
+
+if(NOT PYTHON_EXECUTABLE)
+  message(FATAL_ERROR "Missing PYTHON_EXECUTABLE")
+endif()
+
+set(XPP_INCLUDE_DIRS
+  ${PROJECT_SOURCE_DIR}/include
+  ${XCB_XCB_INCLUDE_DIR}
+  ${XCB_EWMH_INCLUDE_DIR}
+  ${XCB_ICCCM_INCLUDE_DIR}
+  ${XCB_UTIL_INCLUDE_DIR}
+  ${XCB_IMAGE_INCLUDE_DIR})
+set(XPP_LIBRARIES
+  ${XCB_XCB_LIBRARY}
+  ${XCB_EWMH_LIBRARY}
+  ${XCB_ICCCM_LIBRARY}
+  ${XCB_UTIL_LIBRARY}
+  ${XCB_IMAGE_LIBRARY})
+
+#
+# Loop through a hardcoded list of python executables to locate the python module "xcbgen"
+#
+foreach(CURRENT_EXECUTABLE python2 python3 python)
+  message(STATUS "Searching for xcbgen with " ${CURRENT_EXECUTABLE})
+
+  execute_process(COMMAND "${CURRENT_EXECUTABLE}" "-c"
+    "import re,xcbgen;print(re.compile('/xcbgen/__init__.py.*').sub('',xcbgen.__file__))"
+    RESULT_VARIABLE _xcbgen_status
+    OUTPUT_VARIABLE _xcbgen_location
+    ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+  # When a shell script returns successfully its return code is 0
+  if(_xcbgen_status EQUAL 0)
+    set(PYTHON_XCBGEN "${_xcbgen_location}" CACHE STRING "Location of python module: xcbgen ")
+    message(STATUS "Found xcbgen in " ${PYTHON_XCBGEN})
+    break()
+  endif()
+
+endforeach(CURRENT_EXECUTABLE)
+
+if(NOT PYTHON_XCBGEN)
+  message(FATAL_ERROR "Missing required python module: xcbgen")
+endif()
+
+#
+# Include XCB libs depending on what protos we build
+#
+if(NOT XCB_PROTOS)
+  set(XCB_PROTOS
+    "bigreq"
+    "composite"
+    "damage"
+    "dpms"
+    "dri2"
+    "dri3"
+    "glx"
+    "present"
+    "randr"
+    "record"
+    "render"
+    "res"
+    "screensaver"
+    "shape"
+    "shm"
+    "sync"
+    "xc_misc"
+    "xevie"
+    "xf86dri"
+    "xfixes"
+    "xinerama"
+    "xinput"
+    "xkb"
+    "xprint"
+    "xproto"
+    "xselinux"
+    "xtest"
+    "xv"
+    "xvmc")
+endif()
+
+if(";${XCB_PROTOS};" MATCHES ";randr;")
+  find_package(XCB REQUIRED RANDR)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_RANDR_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_RANDR_LIBRARY})
+endif()
+if(";${XCB_PROTOS};" MATCHES ";render;")
+  find_package(XCB REQUIRED RENDER)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_RENDER_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_RENDER_LIBRARY})
+endif()
+if(";${XCB_PROTOS};" MATCHES ";damage;")
+  find_package(XCB REQUIRED DAMAGE)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_DAMAGE_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_DAMAGE_LIBRARY})
+endif()
+if(";${XCB_PROTOS};" MATCHES ";sync;")
+  find_package(XCB REQUIRED SYNC)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_SYNC_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_SYNC_LIBRARY})
+endif()
+if(";${XCB_PROTOS};" MATCHES ";composite;")
+  find_package(XCB REQUIRED COMPOSITE)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_COMPOSITE_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_COMPOSITE_LIBRARY})
+endif()
+if(";${XCB_PROTOS};" MATCHES ";xkb;")
+  find_package(XCB REQUIRED XKB)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} ${XCB_XKB_INCLUDE_DIR})
+  set(XPP_LIBRARIES ${XPP_LIBRARIES} ${XCB_XKB_LIBRARY})
+endif()
+
+set(PROTO_LIST)
+
+if(NOT XCBPROTO_PREFIX)
+  set(XCBPROTO_PREFIX /usr)
+endif()
+file(GLOB PROTO_LIST_RAW RELATIVE ${XCBPROTO_PREFIX}/share/xcb ${XCBPROTO_PREFIX}/share/xcb/*.xml)
+
+#
+# Filter glob
+#
+foreach(PROTO_RAW ${PROTO_LIST_RAW})
+  string(REGEX REPLACE "(^xf86vidmode.xml|^ge.xml|.xml)\$" "" PROTO ${PROTO_RAW})
+  if(PROTO AND ";${XCB_PROTOS};" MATCHES ";${PROTO};")
+    message(STATUS "${PROJECT_NAME}: including xcb proto ${PROTO_RAW}")
+    set(PROTO_LIST ${PROTO_LIST} ${PROTO})
+  endif()
+endforeach(PROTO_RAW)
+
+#
+# Create project lib and commands
+#
+file(GLOB_RECURSE HEADER_FILES ${PROJECT_SOURCE_DIR}/include/*.hpp)
+add_library(${PROJECT_NAME} ${HEADER_FILES})
+
+target_include_directories(${PROJECT_NAME} PUBLIC ${XPP_INCLUDE_DIRS})
+target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/include/xpp)
+target_link_libraries(${PROJECT_NAME} PRIVATE ${XPP_LIBRARIES})
+
+target_compile_options(${PROJECT_NAME} PRIVATE -std=c++14 -Wall -Wpedantic)
+target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Debug>:-g3 -DDEBUG>)
+target_compile_options(${PROJECT_NAME} PRIVATE $<$<CONFIG:Release>:-O3 -Wno-unused-variable>)
+target_compile_options(${PROJECT_NAME} PUBLIC ${X11_XCB_DEFINITIONS} ${XCB_DEFINITIONS})
+
+set_target_properties(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE CXX)
+
+#
+# Add commands
+#
+foreach(PROTO ${PROTO_LIST})
+  string(REGEX REPLACE "proto\$" "" PROTO_OUTPUT ${PROTO})
+  add_custom_command(TARGET ${PROJECT_NAME} PRE_BUILD
+    COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/generators/cpp_client.py -p "${PYTHON_XCBGEN}"
+    ${XCBPROTO_PREFIX}/share/xcb/${PROTO}.xml > ${PROJECT_SOURCE_DIR}/include/xpp/proto/${PROTO_OUTPUT}.hpp)
+endforeach(PROTO)
+
+#
+# Export lists to the parent scope if there are any
+#
+get_directory_property(HAS_PARENT PARENT_DIRECTORY)
+
+if(HAS_PARENT)
+  set(XPP_INCLUDE_DIRS ${XPP_INCLUDE_DIRS} PARENT_SCOPE)
+  set(XPP_LIBRARIES ${PROJECT_NAME} PARENT_SCOPE)
+endif()
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/accessor.py polybar-3.2.1/lib/xpp/generators/accessor.py
--- polybar-3.2.1.orig/lib/xpp/generators/accessor.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/accessor.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,126 @@
+from resource_classes import _resource_classes
+
+_templates = {}
+
+_templates['iter_fixed'] = \
+"""\
+xpp::generic::iterator<Connection,
+                       %s,
+                       SIGNATURE(%s_%s),
+                       SIGNATURE(%s_%s_length)>\
+"""
+
+_templates['iter_variable'] = \
+"""\
+xpp::generic::iterator<Connection,
+                       %s,
+                       SIGNATURE(%s_next),
+                       SIGNATURE(%s_sizeof),
+                       SIGNATURE(%s_%s_iterator)>\
+"""
+
+_templates['list'] = \
+"""\
+    xpp::generic::list<Connection,
+                       %s_reply_t,
+                       %s
+                      >
+    %s(void)
+    {
+      return xpp::generic::list<Connection,
+                                %s_reply_t,
+                                %s
+                               >(%s);
+    }\
+"""
+
+_templates['string_accessor'] = \
+'''\
+    std::string
+    %s(void)
+    {
+      return std::string(%s_%s(this->get().get()),
+                         %s_%s_length(this->get().get()));
+    }
+'''
+
+def _string_accessor(member, c_name):
+    return _templates['string_accessor'] % \
+            (member, c_name, member, c_name, member)
+
+class Accessor(object):
+    def __init__(self, is_fixed=False, is_string=False, is_variable=False, \
+                 member="", c_type="", return_type="", iter_name="", c_name=""):
+
+        self.is_fixed = is_fixed
+        self.is_string = is_string
+        self.is_variable = is_variable
+
+        self.member = member
+        self.c_type = c_type
+        self.return_type = return_type
+        self.iter_name = iter_name
+        self.c_name = c_name
+
+        self.object_type = self.c_type.replace("xcb_", "").replace("_t", "").upper()
+
+        if self.c_type == "void":
+          self.return_type = "Type"
+        elif self.object_type in _resource_classes:
+          self.return_type = self.member.capitalize()
+        else:
+          self.return_type = self.c_type
+
+    def __str__(self):
+        if self.is_fixed:
+            return self.list(self.iter_fixed())
+        elif self.is_variable:
+            return self.list(self.iter_variable())
+        elif self.is_string:
+            return self.string()
+        else:
+            return ""
+
+
+    def iter_fixed(self):
+        return_type = self.return_type
+
+        return _templates['iter_fixed'] \
+                % (return_type,
+                   self.c_name, self.member,
+                   self.c_name, self.member)
+
+
+    def iter_variable(self):
+        return _templates['iter_variable'] \
+                % (self.c_type,
+                   self.iter_name,
+                   self.iter_name,
+                   self.c_name, self.member)
+
+
+    def list(self, iterator):
+        template = "    template<typename Type" if self.c_type == "void" else ""
+
+        # template<typename Children = xcb_window_t>
+        if self.object_type in _resource_classes:
+          template += ", " if template != "" else "    template<typename "
+          template += self.member.capitalize() + " = " + self.c_type
+
+        template += ">\n" if template != "" else ""
+
+        c_tor_params = "this->m_c, this->get()"
+
+        fst_iterator = "\n                       ".join(iterator.split('\n'))
+        snd_iterator = "\n                                ".join(iterator.split('\n'))
+
+        return template + _templates['list'] \
+                % (self.c_name,
+                   fst_iterator,
+                   self.member,
+                   self.c_name,
+                   snd_iterator,
+                   c_tor_params)
+
+    def string(self):
+        return _string_accessor(self.member, self.c_name)
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cpp_client.py polybar-3.2.1/lib/xpp/generators/cpp_client.py
--- polybar-3.2.1.orig/lib/xpp/generators/cpp_client.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cpp_client.py	2018-11-30 20:15:15.122926140 +0300
@@ -0,0 +1,3194 @@
+#!/usr/bin/env python
+# vim: set ts=4 sws=4 sw=4:
+
+from xml.etree.cElementTree import *
+from os.path import basename
+from functools import reduce
+import getopt
+import os
+import sys
+import errno
+import time
+import re
+import collections
+
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext
+
+from cppevent import CppEvent
+from cpperror import CppError
+from accessor import Accessor
+from parameter import Parameter
+from cpprequest import CppRequest
+from objectclass import ObjectClass
+from interfaceclass import InterfaceClass
+from extensionclass import ExtensionClass
+from resource_classes import _resource_classes
+
+_cpp_request_names = []
+_cpp_request_objects = {}
+
+# see c_open()
+_interface_class = InterfaceClass()
+
+_cpp_events = []
+_cpp_errors = []
+
+_object_classes = {}
+
+for i, v in enumerate(_resource_classes):
+    _object_classes[i] = ObjectClass(v)
+
+        # , "render" : collections.OrderedDict( \
+        #         {
+        #         } )
+        # , "xinerama" : collections.OrderedDict( \
+        #         {
+        #         } )
+
+# Jump to the bottom of this file for the main routine
+
+# Some hacks to make the API more readable, and to keep backwards compability
+_cname_re = re.compile('([A-Z0-9][a-z]+|[A-Z0-9]+(?![a-z])|[a-z]+)')
+_cname_special_cases = {'DECnet':'decnet'}
+
+_extension_special_cases = ['XPrint', 'XCMisc', 'BigRequests']
+
+_xcb_includes = \
+    { "xproto" : "xcb.h"
+    }
+
+
+_cplusplus_annoyances = {'class' : '_class',
+                         'new'   : '_new',
+                         'delete': '_delete',
+                         'explicit': '_explicit'}
+_c_keywords = {'default' : '_default'}
+
+_hlines = []
+_hlevel = 0
+_clines = []
+_clevel = 0
+_ns = None
+
+# global variable to keep track of serializers and
+# switch data types due to weird dependencies
+finished_serializers = []
+finished_sizeof = []
+finished_switch = []
+
+# keeps enum objects so that we can refer to them when generating manpages.
+enums = {}
+
+manpaths = False
+
+def _get_xcb_include(ns):
+    # return _xcb_includes.get(ns, _ns.ext_name.lower()) + ".h"
+    return _xcb_includes.get(ns, _ns.file.replace(".xml", ".h"))
+
+# def get_namespace(_ns):
+#     if _ns.is_ext:
+#         return get_ext_name(_ns.ext_name)
+#     else:
+#         return "x"
+
+def _h(fmt, *args):
+    '''
+    Writes the given line to the header file.
+    '''
+    _hlines[_hlevel].append(fmt % args)
+
+def _c(fmt, *args):
+    '''
+    Writes the given line to the source file.
+    '''
+    _clines[_clevel].append(fmt % args)
+
+def _hc(fmt, *args):
+    '''
+    Writes the given line to both the header and source files.
+    '''
+    _h(fmt, *args)
+    _c(fmt, *args)
+
+# XXX See if this level thing is really necessary.
+def _h_setlevel(idx):
+    '''
+    Changes the array that header lines are written to.
+    Supports writing different sections of the header file.
+    '''
+    global _hlevel
+    while len(_hlines) <= idx:
+        _hlines.append([])
+    _hlevel = idx
+
+def _c_setlevel(idx):
+    '''
+    Changes the array that source lines are written to.
+    Supports writing to different sections of the source file.
+    '''
+    global _clevel
+    while len(_clines) <= idx:
+        _clines.append([])
+    _clevel = idx
+
+
+def _cpp(str):
+    '''
+    Checks for certain C++ reserved words and fixes them.
+    '''
+    if str in _cplusplus_annoyances:
+        return _cplusplus_annoyances[str]
+    elif str in _c_keywords:
+        return  _c_keywords[str]
+    else:
+        return str
+
+
+def _n(list):
+    '''
+    Does C-name conversion on a tuple of strings.
+    Different behavior depending on length of tuple, extension/not extension, etc.
+    Basically C-name converts the individual pieces, then joins with underscores.
+    '''
+    if len(list) == 1:
+        parts = list
+    elif len(list) == 2:
+        parts = [list[0], _n_item(list[1])]
+    elif _ns.is_ext:
+        parts = [list[0], _ext(list[1])] + [_n_item(i) for i in list[2:]]
+    else:
+        parts = [list[0]] + [_n_item(i) for i in list[1:]]
+    return '_'.join(parts).lower()
+
+def _t(list):
+    '''
+    Does C-name conversion on a tuple of strings representing a type.
+    Same as _n but adds a "_t" on the end.
+    '''
+    if len(list) == 1:
+        parts = list
+    elif len(list) == 2:
+        parts = [list[0], _n_item(list[1]), 't']
+    elif _ns.is_ext:
+        parts = [list[0], _ext(list[1])] + [_n_item(i) for i in list[2:]] + ['t']
+    else:
+        parts = [list[0]] + [_n_item(i) for i in list[1:]] + ['t']
+    return '_'.join(parts).lower()
+
+
+def c_open(self):
+    '''
+    Exported function that handles module open.
+    Opens the files and writes out the auto-generated comment,
+    header file includes, etc.
+    '''
+    global _ns
+    _ns = self.namespace
+    # _ns.header = "test"
+    _ns.c_ext_global_name = _n(_ns.prefix + ('id',))
+
+    _interface_class.set_namespace(_ns)
+
+    # Build the type-name collision avoidance table used by c_enum
+    build_collision_table()
+
+    _h_setlevel(0)
+    _c_setlevel(0)
+
+    # sys.stderr.write("#include <vector>\n")
+    # sys.stderr.write("#include \"../request.hpp\"\n")
+    # sys.stderr.write("#include \"../iterator.hpp\"\n")
+    # sys.stderr.write("#include \"../core/value_iterator.hpp\"\n")
+
+    # _h('#ifndef EXPORT_%s_MIXINS', get_namespace(_ns).upper())
+    _h('#ifndef XPP_%s_HPP', get_namespace(_ns).upper())
+    _h('#define XPP_%s_HPP', get_namespace(_ns).upper())
+    _h('')
+    _h('#include <string>')
+    _h('#include <vector>')
+    _h('')
+
+    _h('#include <xcb/' + _get_xcb_include(_ns.header.lower()) + '>')
+
+    _h('')
+
+    _h('#include "../generic.hpp"')
+
+    # if not _ns.is_ext:
+    #     _h('#include "xproto-stub.hpp"')
+    # _h('#include "../core/generic/resource.hpp"')
+    _h('')
+    _h('namespace xpp { namespace %s {' % get_namespace(_ns))
+    # _h('class window;')
+    # _h('namespace %s {', get_namespace(_ns))
+    # _h('')
+
+def c_close(self):
+    '''
+    Exported function that handles module close.
+    Writes out all the stored content lines, then closes the files.
+    '''
+
+    _h('')
+    _h(ExtensionClass(_ns).make_class())
+
+
+    for cpp_event in _cpp_events:
+        _h(cpp_event.make_class())
+
+    _h('')
+
+    for cpp_error in _cpp_errors:
+        _h(cpp_error.make_class())
+
+    _h('')
+
+    for name in _cpp_request_names:
+        _h("%s", _cpp_request_objects[name].make_class())
+
+    _h('')
+
+    for key in _object_classes:
+        _h(_object_classes[key].make_inline())
+        # sys.stderr.write(_object_classes[key].make_inline())
+
+
+
+    _h('')
+    _h(_interface_class.make_proto())
+    # sys.stderr.write(_interface_class.make_proto())
+
+    _h('')
+    # _h('}; // namespace xpp')
+    _h("} } // namespace xpp::%s" % get_namespace(_ns))
+
+    _h('')
+    _h('#endif // XPP_%s_HPP', get_namespace(_ns).upper())
+
+    # Write header file
+    hfile = sys.stdout
+    for list in _hlines:
+        for line in list:
+            hfile.write(line)
+            hfile.write('\n')
+    # hfile.close()
+
+    # cfile = sys.stderr
+    # for list in _clines:
+    #     for line in list:
+    #         cfile.write(line)
+    #         cfile.write('\n')
+
+def build_collision_table():
+    global namecount
+    namecount = {}
+
+    for v in module.types.values():
+        name = _t(v[0])
+        namecount[name] = (namecount.get(name) or 0) + 1
+
+def c_enum(self, name):
+    '''
+    Exported function that handles enum declarations.
+    '''
+
+    enums[name] = self
+
+    tname = _t(name)
+    if namecount[tname] > 1:
+        tname = _t(name + ('enum',))
+
+    _h_setlevel(0)
+    _h('')
+    _h('typedef enum %s {', tname)
+
+    count = len(self.values)
+
+    for (enam, eval) in self.values:
+        count = count - 1
+        equals = ' = ' if eval != '' else ''
+        comma = ',' if count > 0 else ''
+        doc = ''
+        if hasattr(self, "doc") and self.doc and enam in self.doc.fields:
+            doc = '\n/**< %s */\n' % self.doc.fields[enam]
+        _h('    %s%s%s%s%s', _n(name + (enam,)).upper(), equals, eval, comma, doc)
+
+    _h('} %s;', tname)
+
+def _c_type_setup(self, name, postfix):
+    '''
+    Sets up all the C-related state by adding additional data fields to
+    all Field and Type objects.  Here is where we figure out most of our
+    variable and function names.
+
+    Recurses into child fields and list member types.
+    '''
+    # Do all the various names in advance
+
+    self.c_type = _t(name + postfix)
+    self.c_wiretype = 'char' if self.c_type == 'void' else self.c_type
+
+    self.c_iterator_type = _t(name + ('iterator',))
+    self.c_next_name = _n(name + ('next',))
+    self.c_end_name = _n(name + ('end',))
+
+    self.c_request_name = _n(name)
+    self.c_checked_name = _n(name)
+    self.c_unchecked_name = _n(name)
+    # self.c_checked_name = _n(name + ('checked',))
+    # self.c_unchecked_name = _n(name + ('unchecked',))
+    self.c_reply_name = _n(name + ('reply',))
+    self.c_reply_type = _t(name + ('reply',))
+    self.c_cookie_type = _t(name + ('cookie',))
+    self.c_reply_fds_name = _n(name + ('reply_fds',))
+
+    self.need_aux = False
+    self.need_serialize = False
+    self.need_sizeof = False
+
+    self.c_aux_name = _n(name + ('aux',))
+    self.c_aux_checked_name = _n(name)
+    self.c_aux_unchecked_name = _n(name)
+    # self.c_aux_checked_name = _n(name + ('aux', 'checked'))
+    # self.c_aux_unchecked_name = _n(name + ('aux', 'unchecked'))
+    self.c_serialize_name = _n(name + ('serialize',))
+    self.c_unserialize_name = _n(name + ('unserialize',))
+    self.c_unpack_name = _n(name + ('unpack',))
+    self.c_sizeof_name = _n(name + ('sizeof',))
+
+    # special case: structs where variable size fields are followed by fixed size fields
+    self.var_followed_by_fixed_fields = False
+
+    if self.is_switch:
+        self.need_serialize = True
+        self.c_container = 'struct'
+        for bitcase in self.bitcases:
+            bitcase.c_field_name = _cpp(bitcase.field_name)
+            bitcase_name = bitcase.field_type if bitcase.type.has_name else name
+            _c_type_setup(bitcase.type, bitcase_name, ())
+
+    elif self.is_container:
+
+        self.c_container = 'union' if self.is_union else 'struct'
+        prev_varsized_field = None
+        prev_varsized_offset = 0
+        first_field_after_varsized = None
+
+        for field in self.fields:
+            _c_type_setup(field.type, field.field_type, ())
+            if field.type.is_list:
+                _c_type_setup(field.type.member, field.field_type, ())
+                if (field.type.nmemb is None):
+                    self.need_sizeof = True
+
+            field.c_field_type = _t(field.field_type)
+            field.c_field_const_type = ('' if field.type.nmemb == 1 else 'const ') + field.c_field_type
+            field.c_field_name = _cpp(field.field_name)
+            field.c_subscript = '[%d]' % field.type.nmemb if (field.type.nmemb and field.type.nmemb > 1) else ''
+            field.c_pointer = ' ' if field.type.nmemb == 1 else '*'
+
+            # correct the c_pointer field for variable size non-list types
+            if not field.type.fixed_size() and field.c_pointer == ' ':
+                field.c_pointer = '*'
+            if field.type.is_list and not field.type.member.fixed_size():
+                field.c_pointer = '*'
+
+            if field.type.is_switch:
+                field.c_pointer = '*'
+                field.c_field_const_type = 'const ' + field.c_field_type
+                self.need_aux = True
+            elif not field.type.fixed_size() and not field.type.is_bitcase:
+                self.need_sizeof = True
+
+            field.c_iterator_type = _t(field.field_type + ('iterator',))      # xcb_fieldtype_iterator_t
+            field.c_iterator_name = _n(name + (field.field_name, 'iterator')) # xcb_container_field_iterator
+            field.c_accessor_name = _n(name + (field.field_name,))            # xcb_container_field
+            field.c_length_name = _n(name + (field.field_name, 'length'))     # xcb_container_field_length
+            field.c_end_name = _n(name + (field.field_name, 'end'))           # xcb_container_field_end
+
+            field.prev_varsized_field = prev_varsized_field
+            field.prev_varsized_offset = prev_varsized_offset
+
+            if prev_varsized_offset == 0:
+                first_field_after_varsized = field
+            field.first_field_after_varsized = first_field_after_varsized
+
+            if field.type.fixed_size():
+                prev_varsized_offset += field.type.size
+                # special case: intermixed fixed and variable size fields
+                if prev_varsized_field is not None and not field.type.is_pad and field.wire:
+                    if not self.is_union:
+                        self.need_serialize = True
+                        self.var_followed_by_fixed_fields = True
+            else:
+                self.last_varsized_field = field
+                prev_varsized_field = field
+                prev_varsized_offset = 0
+
+            if self.var_followed_by_fixed_fields:
+                if field.type.fixed_size():
+                    field.prev_varsized_field = None
+
+    if self.need_serialize:
+        # when _unserialize() is wanted, create _sizeof() as well for consistency reasons
+        self.need_sizeof = True
+
+    # as switch does never appear at toplevel,
+    # continue here with type construction
+    if self.is_switch:
+        if self.c_type not in finished_switch:
+            finished_switch.append(self.c_type)
+            # special: switch C structs get pointer fields for variable-sized members
+            _c_complex(self)
+            for bitcase in self.bitcases:
+                bitcase_name = bitcase.type.name if bitcase.type.has_name else name
+                _c_accessors(bitcase.type, bitcase_name, bitcase_name)
+                # no list with switch as element, so no call to
+                # _c_iterator(field.type, field_name) necessary
+
+    if not self.is_bitcase:
+        if self.need_serialize:
+            if self.c_serialize_name not in finished_serializers:
+                finished_serializers.append(self.c_serialize_name)
+                _c_serialize('serialize', self)
+
+                # _unpack() and _unserialize() are only needed for special cases:
+                #   switch -> unpack
+                #   special cases -> unserialize
+                if self.is_switch or self.var_followed_by_fixed_fields:
+                    _c_serialize('unserialize', self)
+
+        # if self.need_sizeof:
+        #     if self.c_sizeof_name not in finished_sizeof:
+        #         if not module.namespace.is_ext or self.name[:2] == module.namespace.prefix:
+        #             finished_sizeof.append(self.c_sizeof_name)
+        #             _c_serialize('sizeof', self)
+# _c_type_setup()
+
+def _c_helper_absolute_name(prefix, field=None):
+    """
+    turn prefix, which is a list of tuples (name, separator, Type obj) into a string
+    representing a valid name in C (based on the context)
+    if field is not None, append the field name as well
+    """
+    prefix_str = ''
+    for name, sep, obj in prefix:
+        prefix_str += name
+        if '' == sep:
+            sep = '->'
+            if ((obj.is_bitcase and obj.has_name) or     # named bitcase
+                (obj.is_switch and len(obj.parents)>1)):
+                sep = '.'
+        prefix_str += sep
+    if field is not None:
+        prefix_str += _cpp(field.field_name)
+    return prefix_str
+# _c_absolute_name
+
+def _c_helper_field_mapping(complex_type, prefix, flat=False):
+    """
+    generate absolute names, based on prefix, for all fields starting from complex_type
+    if flat == True, nested complex types are not taken into account
+    """
+    all_fields = {}
+    if complex_type.is_switch:
+        for b in complex_type.bitcases:
+            if b.type.has_name:
+                switch_name, switch_sep, switch_type = prefix[-1]
+                bitcase_prefix = prefix + [(b.type.name[-1], '.', b.type)]
+            else:
+                bitcase_prefix = prefix
+
+            if (True==flat and not b.type.has_name) or False==flat:
+                all_fields.update(_c_helper_field_mapping(b.type, bitcase_prefix, flat))
+    else:
+        for f in complex_type.fields:
+            fname = _c_helper_absolute_name(prefix, f)
+            if f.field_name in all_fields:
+                raise Exception("field name %s has been registered before" % f.field_name)
+
+            all_fields[f.field_name] = (fname, f)
+            if f.type.is_container and flat==False:
+                if f.type.is_bitcase and not f.type.has_name:
+                    new_prefix = prefix
+                elif f.type.is_switch and len(f.type.parents)>1:
+                    # nested switch gets another separator
+                    new_prefix = prefix+[(f.c_field_name, '.', f.type)]
+                else:
+                    new_prefix = prefix+[(f.c_field_name, '->', f.type)]
+                all_fields.update(_c_helper_field_mapping(f.type, new_prefix, flat))
+
+    return all_fields
+# _c_field_mapping()
+
+def _c_helper_resolve_field_names (prefix):
+    """
+    get field names for all objects in the prefix array
+    """
+    all_fields = {}
+    tmp_prefix = []
+    # look for fields in the remaining containers
+    for idx, p in enumerate(prefix):
+        name, sep, obj = p
+        if ''==sep:
+            # sep can be preset in prefix, if not, make a sensible guess
+            sep = '.' if (obj.is_switch or obj.is_bitcase) else '->'
+            # exception: 'toplevel' object (switch as well!) always have sep '->'
+            sep = '->' if idx<1 else sep
+        if not obj.is_bitcase or (obj.is_bitcase and obj.has_name):
+            tmp_prefix.append((name, sep, obj))
+        all_fields.update(_c_helper_field_mapping(obj, tmp_prefix, flat=True))
+
+    return all_fields
+# _c_helper_resolve_field_names
+
+def get_expr_fields(self):
+    """
+    get the Fields referenced by switch or list expression
+    """
+    def get_expr_field_names(expr):
+        if expr.op is None:
+            if expr.lenfield_name is not None:
+                return [expr.lenfield_name]
+            else:
+                # constant value expr
+                return []
+        else:
+            if expr.op == '~':
+                return get_expr_field_names(expr.rhs)
+            elif expr.op == 'popcount':
+                return get_expr_field_names(expr.rhs)
+            elif expr.op == 'sumof':
+                # sumof expr references another list,
+                # we need that list's length field here
+                field = None
+                for f in expr.lenfield_parent.fields:
+                    if f.field_name == expr.lenfield_name:
+                        field = f
+                        break
+                if field is None:
+                    raise Exception("list field '%s' referenced by sumof not found" % expr.lenfield_name)
+                # referenced list + its length field
+                return [expr.lenfield_name] + get_expr_field_names(field.type.expr)
+            elif expr.op == 'enumref':
+                return []
+            else:
+                return get_expr_field_names(expr.lhs) + get_expr_field_names(expr.rhs)
+    # get_expr_field_names()
+
+    # resolve the field names with the parent structure(s)
+    unresolved_fields_names = get_expr_field_names(self.expr)
+
+    # construct prefix from self
+    prefix = [('', '', p) for p in self.parents]
+    if self.is_container:
+        prefix.append(('', '', self))
+
+    all_fields = _c_helper_resolve_field_names (prefix)
+    resolved_fields_names = list(filter(lambda x: x in all_fields.keys(), unresolved_fields_names))
+    if len(unresolved_fields_names) != len(resolved_fields_names):
+        raise Exception("could not resolve all fields for %s" % self.name)
+
+    resolved_fields = [all_fields[n][1] for n in resolved_fields_names]
+    return resolved_fields
+# get_expr_fields()
+
+def resolve_expr_fields(complex_obj):
+    """
+    find expr fields appearing in complex_obj and descendents that cannot be resolved within complex_obj
+    these are normally fields that need to be given as function parameters
+    """
+    all_fields = []
+    expr_fields = []
+    unresolved = []
+
+    for field in complex_obj.fields:
+        all_fields.append(field)
+        if field.type.is_switch or field.type.is_list:
+            expr_fields += get_expr_fields(field.type)
+        if field.type.is_container:
+            expr_fields += resolve_expr_fields(field.type)
+
+    # try to resolve expr fields
+    for e in expr_fields:
+        if e not in all_fields and e not in unresolved:
+            unresolved.append(e)
+    return unresolved
+# resolve_expr_fields()
+
+def get_serialize_params(context, self, buffer_var='_buffer', aux_var='_aux'):
+    """
+    functions like _serialize(), _unserialize(), and _unpack() sometimes need additional parameters:
+    E.g. in order to unpack switch, extra parameters might be needed to evaluate the switch
+    expression. This function tries to resolve all fields within a structure, and returns the
+    unresolved fields as the list of external parameters.
+    """
+    def add_param(params, param):
+        if param not in params:
+            params.append(param)
+
+    # collect all fields into param_fields
+    param_fields = []
+    wire_fields = []
+
+    for field in self.fields:
+        if field.visible:
+            # the field should appear as a parameter in the function call
+            param_fields.append(field)
+        if field.wire and not field.auto:
+            if field.type.fixed_size() and not self.is_switch:
+                # field in the xcb_out structure
+                wire_fields.append(field)
+        # fields like 'pad0' are skipped!
+
+    # in case of switch, parameters always contain any fields referenced in the switch expr
+    # we do not need any variable size fields here, as the switch data type contains both
+    # fixed and variable size fields
+    if self.is_switch:
+        param_fields = get_expr_fields(self)
+
+    # _serialize()/_unserialize()/_unpack() function parameters
+    # note: don't use set() for params, it is unsorted
+    params = []
+
+    # 1. the parameter for the void * buffer
+    if  'serialize' == context:
+        params.append(('void', '**', buffer_var))
+    elif context in ('unserialize', 'unpack', 'sizeof'):
+        params.append(('const void', '*', buffer_var))
+
+    # 2. any expr fields that cannot be resolved within self and descendants
+    unresolved_fields = resolve_expr_fields(self)
+    for f in unresolved_fields:
+        add_param(params, (f.c_field_type, '', f.c_field_name))
+
+    # 3. param_fields contain the fields necessary to evaluate the switch expr or any other fields
+    #    that do not appear in the data type struct
+    for p in param_fields:
+        if self.is_switch:
+            typespec = p.c_field_const_type
+            pointerspec = p.c_pointer
+            add_param(params, (typespec, pointerspec, p.c_field_name))
+        else:
+            if p.visible and not p.wire and not p.auto:
+                typespec = p.c_field_type
+                pointerspec = ''
+                add_param(params, (typespec, pointerspec, p.c_field_name))
+
+    # 4. aux argument
+    if 'serialize' == context:
+        add_param(params, ('const %s' % self.c_type, '*', aux_var))
+    elif 'unserialize' == context:
+        add_param(params, ('%s' % self.c_type, '**', aux_var))
+    elif 'unpack' == context:
+        add_param(params, ('%s' % self.c_type, '*', aux_var))
+
+    # 5. switch contains all variable size fields as struct members
+    #    for other data types though, these have to be supplied separately
+    #    this is important for the special case of intermixed fixed and
+    #    variable size fields
+    if not self.is_switch and 'serialize' == context:
+        for p in param_fields:
+            if not p.type.fixed_size():
+                add_param(params, (p.c_field_const_type, '*', p.c_field_name))
+
+    return (param_fields, wire_fields, params)
+# get_serialize_params()
+
+def _c_serialize_helper_insert_padding(context, code_lines, space, postpone):
+    code_lines.append('%s    /* insert padding */' % space)
+    code_lines.append('%s    xcb_pad = -xcb_block_len & (xcb_align_to - 1);' % space)
+#    code_lines.append('%s    printf("automatically inserting padding: %%%%d\\n", xcb_pad);' % space)
+    code_lines.append('%s    xcb_buffer_len += xcb_block_len + xcb_pad;' % space)
+
+    if not postpone:
+        code_lines.append('%s    if (0 != xcb_pad) {' % space)
+
+        if 'serialize' == context:
+            code_lines.append('%s        xcb_parts[xcb_parts_idx].iov_base = xcb_pad0;' % space)
+            code_lines.append('%s        xcb_parts[xcb_parts_idx].iov_len = xcb_pad;' % space)
+            code_lines.append('%s        xcb_parts_idx++;' % space)
+        elif context in ('unserialize', 'unpack', 'sizeof'):
+            code_lines.append('%s        xcb_tmp += xcb_pad;' % space)
+
+        code_lines.append('%s        xcb_pad = 0;' % space)
+        code_lines.append('%s    }' % space)
+
+    code_lines.append('%s    xcb_block_len = 0;' % space)
+
+    # keep tracking of xcb_parts entries for serialize
+    return 1
+# _c_serialize_helper_insert_padding()
+
+def _c_serialize_helper_switch(context, self, complex_name,
+                               code_lines, temp_vars,
+                               space, prefix):
+    count = 0
+    switch_expr = _c_accessor_get_expr(self.expr, None)
+
+    for b in self.bitcases:
+        len_expr = len(b.type.expr)
+        for n, expr in enumerate(b.type.expr):
+            bitcase_expr = _c_accessor_get_expr(expr, None)
+            # only one <enumref> in the <bitcase>
+            if len_expr == 1:
+                code_lines.append('    if(%s & %s) {' % (switch_expr, bitcase_expr))
+            # multiple <enumref> in the <bitcase>
+            elif n == 0: # first
+                code_lines.append('    if((%s & %s) ||' % (switch_expr, bitcase_expr))
+            elif len_expr == (n + 1): # last
+                code_lines.append('       (%s & %s)) {' % (switch_expr, bitcase_expr))
+            else: # between first and last
+                code_lines.append('       (%s & %s) ||' % (switch_expr, bitcase_expr))
+
+        b_prefix = prefix
+        if b.type.has_name:
+            b_prefix = prefix + [(b.c_field_name, '.', b.type)]
+
+        count += _c_serialize_helper_fields(context, b.type,
+                                            code_lines, temp_vars,
+                                            "%s    " % space,
+                                            b_prefix,
+                                            is_bitcase = True)
+        code_lines.append('    }')
+
+#    if 'serialize' == context:
+#        count += _c_serialize_helper_insert_padding(context, code_lines, space, False)
+#    elif context in ('unserialize', 'unpack', 'sizeof'):
+#        # padding
+#        code_lines.append('%s    xcb_pad = -xcb_block_len & 3;' % space)
+#        code_lines.append('%s    xcb_buffer_len += xcb_block_len + xcb_pad;' % space)
+
+    return count
+# _c_serialize_helper_switch
+
+def _c_serialize_helper_switch_field(context, self, field, c_switch_variable, prefix):
+    """
+    handle switch by calling _serialize() or _unpack(), depending on context
+    """
+    # switch is handled by this function as a special case
+    param_fields, wire_fields, params = get_serialize_params(context, self)
+    field_mapping = _c_helper_field_mapping(self, prefix)
+    prefix_str = _c_helper_absolute_name(prefix)
+
+    # find the parameters that need to be passed to _serialize()/_unpack():
+    # all switch expr fields must be given as parameters
+    args = get_expr_fields(field.type)
+    # length fields for variable size types in switch, normally only some of need
+    # need to be passed as parameters
+    switch_len_fields = resolve_expr_fields(field.type)
+
+    # a switch field at this point _must_ be a bitcase field
+    # we require that bitcases are "self-contiguous"
+    bitcase_unresolved = resolve_expr_fields(self)
+    if len(bitcase_unresolved) != 0:
+        raise Exception('unresolved fields within bitcase is not supported at this point')
+
+    # get the C names for the parameters
+    c_field_names = ''
+    for a in switch_len_fields:
+        c_field_names += "%s, " % field_mapping[a.c_field_name][0]
+    for a in args:
+        c_field_names += "%s, " % field_mapping[a.c_field_name][0]
+
+    # call _serialize()/_unpack() to determine the actual size
+    if 'serialize' == context:
+        length = "%s(&%s, %s&%s%s)" % (field.type.c_serialize_name, c_switch_variable,
+                                       c_field_names, prefix_str, field.c_field_name)
+    elif context in ('unserialize', 'unpack'):
+        length = "%s(xcb_tmp, %s&%s%s)" % (field.type.c_unpack_name,
+                                           c_field_names, prefix_str, field.c_field_name)
+
+    return length
+# _c_serialize_helper_switch_field()
+
+def _c_serialize_helper_list_field(context, self, field,
+                                   code_lines, temp_vars,
+                                   space, prefix):
+    """
+    helper function to cope with lists of variable length
+    """
+    expr = field.type.expr
+    prefix_str = _c_helper_absolute_name(prefix)
+    param_fields, wire_fields, params = get_serialize_params('sizeof', self)
+    param_names = [p[2] for p in params]
+
+    expr_fields_names = [f.field_name for f in get_expr_fields(field.type)]
+    resolved = list(filter(lambda x: x in param_names, expr_fields_names))
+    unresolved = list(filter(lambda x: x not in param_names, expr_fields_names))
+
+    field_mapping = {}
+    for r in resolved:
+        field_mapping[r] = (r, None)
+
+    if len(unresolved)>0:
+        tmp_prefix = prefix
+        if len(tmp_prefix)==0:
+            raise Exception("found an empty prefix while resolving expr field names for list %s",
+                            field.c_field_name)
+
+        field_mapping.update(_c_helper_resolve_field_names(prefix))
+        resolved += list(filter(lambda x: x in field_mapping, unresolved))
+        unresolved = list(filter(lambda x: x not in field_mapping, unresolved))
+        if len(unresolved)>0:
+            raise Exception('could not resolve the length fields required for list %s' % field.c_field_name)
+
+    list_length = _c_accessor_get_expr(expr, field_mapping)
+
+    # default: list with fixed size elements
+    length = '%s * sizeof(%s)' % (list_length, field.type.member.c_wiretype)
+
+    # list with variable-sized elements
+    if not field.type.member.fixed_size():
+        length = ''
+        if context in ('unserialize', 'sizeof', 'unpack'):
+            int_i = '    unsigned int i;'
+            xcb_tmp_len = '    unsigned int xcb_tmp_len;'
+            if int_i not in temp_vars:
+                temp_vars.append(int_i)
+            if xcb_tmp_len not in temp_vars:
+                temp_vars.append(xcb_tmp_len)
+            # loop over all list elements and call sizeof repeatedly
+            # this should be a bit faster than using the iterators
+            code_lines.append("%s    for(i=0; i<%s; i++) {" % (space, list_length))
+            code_lines.append("%s        xcb_tmp_len = %s(xcb_tmp);" %
+                              (space, field.type.c_sizeof_name))
+            code_lines.append("%s        xcb_block_len += xcb_tmp_len;" % space)
+            code_lines.append("%s        xcb_tmp += xcb_tmp_len;" % space)
+            code_lines.append("%s    }" % space)
+
+        elif 'serialize' == context:
+            code_lines.append('%s    xcb_parts[xcb_parts_idx].iov_len = 0;' % space)
+            code_lines.append('%s    xcb_tmp = (char *) %s%s;' % (space, prefix_str, field.c_field_name))
+            code_lines.append('%s    for(i=0; i<%s; i++) { ' % (space, list_length))
+            code_lines.append('%s        xcb_block_len = %s(xcb_tmp);' % (space, field.type.c_sizeof_name))
+            code_lines.append('%s        xcb_parts[xcb_parts_idx].iov_len += xcb_block_len;' % space)
+            code_lines.append('%s    }' % space)
+            code_lines.append('%s    xcb_block_len = xcb_parts[xcb_parts_idx].iov_len;' % space)
+
+    return length
+# _c_serialize_helper_list_field()
+
+def _c_serialize_helper_fields_fixed_size(context, self, field,
+                                          code_lines, temp_vars,
+                                          space, prefix):
+    # keep the C code a bit more readable by giving the field name
+    if not self.is_bitcase:
+        code_lines.append('%s    /* %s.%s */' % (space, self.c_type, field.c_field_name))
+    else:
+        scoped_name = [p[2].c_type if idx==0 else p[0] for idx, p in enumerate(prefix)]
+        typename = reduce(lambda x,y: "%s.%s" % (x, y), scoped_name)
+        code_lines.append('%s    /* %s.%s */' % (space, typename, field.c_field_name))
+
+    abs_field_name = _c_helper_absolute_name(prefix, field)
+    # default for simple cases: call sizeof()
+    length = "sizeof(%s)" % field.c_field_type
+
+    if context in ('unserialize', 'unpack', 'sizeof'):
+        # default: simple cast
+        value = '    %s = *(%s *)xcb_tmp;' % (abs_field_name, field.c_field_type)
+
+        # padding - we could probably just ignore it
+        if field.type.is_pad and field.type.nmemb > 1:
+            value = ''
+            for i in range(field.type.nmemb):
+                code_lines.append('%s    %s[%d] = *(%s *)xcb_tmp;' %
+                                  (space, abs_field_name, i, field.c_field_type))
+            # total padding = sizeof(pad0) * nmemb
+            length += " * %d" % field.type.nmemb
+
+        if field.type.is_list:
+            # no such case in the protocol, cannot be tested and therefore ignored for now
+            raise Exception('list with fixed number of elemens unhandled in _unserialize()')
+
+    elif 'serialize' == context:
+        value = '    xcb_parts[xcb_parts_idx].iov_base = (char *) '
+
+        if field.type.is_expr:
+            # need to register a temporary variable for the expression in case we know its type
+            if field.type.c_type is None:
+                raise Exception("type for field '%s' (expression '%s') unkown" %
+                                (field.field_name, _c_accessor_get_expr(field.type.expr)))
+
+            temp_vars.append('    %s xcb_expr_%s = %s;' % (field.type.c_type, _cpp(field.field_name),
+                                                           _c_accessor_get_expr(field.type.expr, prefix)))
+            value += "&xcb_expr_%s;" % _cpp(field.field_name)
+
+        elif field.type.is_pad:
+            if field.type.nmemb == 1:
+                value += "&xcb_pad;"
+            else:
+                # we could also set it to 0, see definition of xcb_send_request()
+                value = '    xcb_parts[xcb_parts_idx].iov_base = xcb_pad0;'
+                length += "*%d" % field.type.nmemb
+
+        else:
+            # non-list type with fixed size
+            if field.type.nmemb == 1:
+                value += "&%s;" % (abs_field_name)
+
+            # list with nmemb (fixed size) elements
+            else:
+                value += '%s;' % (abs_field_name)
+                length = '%d' % field.type.nmemb
+
+    return (value, length)
+# _c_serialize_helper_fields_fixed_size()
+
+def _c_serialize_helper_fields_variable_size(context, self, field,
+                                             code_lines, temp_vars,
+                                             space, prefix):
+    prefix_str = _c_helper_absolute_name(prefix)
+
+    if context in ('unserialize', 'unpack', 'sizeof'):
+        value = ''
+        var_field_name = 'xcb_tmp'
+
+        # special case: intermixed fixed and variable size fields
+        if self.var_followed_by_fixed_fields and 'unserialize' == context:
+            value = '    %s = (%s *)xcb_tmp;' % (field.c_field_name, field.c_field_type)
+            temp_vars.append('    %s *%s;' % (field.type.c_type, field.c_field_name))
+        # special case: switch
+        if 'unpack' == context:
+            value = '    %s%s = (%s *)xcb_tmp;' % (prefix_str, field.c_field_name, field.c_field_type)
+
+    elif 'serialize' == context:
+        # variable size fields appear as parameters to _serialize() if the
+        # 'toplevel' container is not a switch
+        prefix_string = prefix_str if prefix[0][2].is_switch else ''
+        var_field_name = "%s%s" % (prefix_string, field.c_field_name)
+        value = '    xcb_parts[xcb_parts_idx].iov_base = (char *) %s;' % var_field_name
+
+    length = ''
+
+    code_lines.append('%s    /* %s */' % (space, field.c_field_name))
+
+    if field.type.is_list:
+        if value != '':
+            # in any context, list is already a pointer, so the default assignment is ok
+            code_lines.append("%s%s" % (space, value))
+            value = ''
+        length = _c_serialize_helper_list_field(context, self, field,
+                                                code_lines, temp_vars,
+                                                space, prefix)
+
+    elif field.type.is_switch:
+        value = ''
+        if context == 'serialize':
+            # the _serialize() function allocates the correct amount memory if given a NULL pointer
+            value = '    xcb_parts[xcb_parts_idx].iov_base = (char *)0;'
+        length = _c_serialize_helper_switch_field(context, self, field,
+                                                  'xcb_parts[xcb_parts_idx].iov_base',
+                                                  prefix)
+
+    else:
+        # in all remaining special cases - call _sizeof()
+        length = "%s(%s)" % (field.type.c_sizeof_name, var_field_name)
+
+    return (value, length)
+# _c_serialize_helper_fields_variable_size
+
+def _c_serialize_helper_fields(context, self,
+                               code_lines, temp_vars,
+                               space, prefix, is_bitcase):
+    count = 0
+    need_padding = False
+    prev_field_was_variable = False
+
+    for field in self.fields:
+        if not field.visible:
+            if not ((field.wire and not field.auto) or 'unserialize' == context):
+                continue
+
+        # switch/bitcase: fixed size fields must be considered explicitly
+        if field.type.fixed_size():
+            if self.is_bitcase or self.var_followed_by_fixed_fields:
+                if prev_field_was_variable and need_padding:
+                    # insert padding
+#                    count += _c_serialize_helper_insert_padding(context, code_lines, space,
+#                                                                self.var_followed_by_fixed_fields)
+                    prev_field_was_variable = False
+
+                # prefix for fixed size fields
+                fixed_prefix = prefix
+
+                value, length = _c_serialize_helper_fields_fixed_size(context, self, field,
+                                                                      code_lines, temp_vars,
+                                                                      space, fixed_prefix)
+            else:
+                continue
+
+        # fields with variable size
+        else:
+            # switch/bitcase: always calculate padding before and after variable sized fields
+            if need_padding or is_bitcase:
+                count += _c_serialize_helper_insert_padding(context, code_lines, space,
+                                                            self.var_followed_by_fixed_fields)
+
+            value, length = _c_serialize_helper_fields_variable_size(context, self, field,
+                                                                     code_lines, temp_vars,
+                                                                     space, prefix)
+            prev_field_was_variable = True
+
+        # save (un)serialization C code
+        if '' != value:
+            code_lines.append('%s%s' % (space, value))
+
+        if field.type.fixed_size():
+            if is_bitcase or self.var_followed_by_fixed_fields:
+                # keep track of (un)serialized object's size
+                code_lines.append('%s    xcb_block_len += %s;' % (space, length))
+                if context in ('unserialize', 'unpack', 'sizeof'):
+                    code_lines.append('%s    xcb_tmp += %s;' % (space, length))
+        else:
+            # variable size objects or bitcase:
+            #   value & length might have been inserted earlier for special cases
+            if '' != length:
+                # special case: intermixed fixed and variable size fields
+                if (not field.type.fixed_size() and
+                    self.var_followed_by_fixed_fields and 'unserialize' == context):
+                    temp_vars.append('    int %s_len;' % field.c_field_name)
+                    code_lines.append('%s    %s_len = %s;' % (space, field.c_field_name, length))
+                    code_lines.append('%s    xcb_block_len += %s_len;' % (space, field.c_field_name))
+                    code_lines.append('%s    xcb_tmp += %s_len;' % (space, field.c_field_name))
+                else:
+                    code_lines.append('%s    xcb_block_len += %s;' % (space, length))
+                    # increase pointer into the byte stream accordingly
+                    if context in ('unserialize', 'sizeof', 'unpack'):
+                        code_lines.append('%s    xcb_tmp += xcb_block_len;' % space)
+
+        if 'serialize' == context:
+            if '' != length:
+                code_lines.append('%s    xcb_parts[xcb_parts_idx].iov_len = %s;' % (space, length))
+            code_lines.append('%s    xcb_parts_idx++;' % space)
+            count += 1
+
+        code_lines.append('%s    xcb_align_to = ALIGNOF(%s);' % (space, 'char' if field.c_field_type == 'void' else field.c_field_type))
+
+        need_padding = True
+        if self.var_followed_by_fixed_fields:
+            need_padding = False
+
+    return count
+# _c_serialize_helper_fields()
+
+def _c_serialize_helper(context, complex_type,
+                        code_lines, temp_vars,
+                        space='', prefix=[]):
+    # count tracks the number of fields to serialize
+    count = 0
+
+    if hasattr(complex_type, 'type'):
+        self = complex_type.type
+        complex_name = complex_type.name
+    else:
+        self = complex_type
+        if self.var_followed_by_fixed_fields and 'unserialize' == context:
+            complex_name = 'xcb_out'
+        else:
+            complex_name = '_aux'
+
+    # special case: switch is serialized by evaluating each bitcase separately
+    if self.is_switch:
+        count += _c_serialize_helper_switch(context, self, complex_name,
+                                            code_lines, temp_vars,
+                                            space, prefix)
+
+    # all other data types can be evaluated one field a time
+    else:
+        # unserialize & fixed size fields: simply cast the buffer to the respective xcb_out type
+        if context in ('unserialize', 'unpack', 'sizeof') and not self.var_followed_by_fixed_fields:
+            code_lines.append('%s    xcb_block_len += sizeof(%s);' % (space, self.c_type))
+            code_lines.append('%s    xcb_tmp += xcb_block_len;' % space)
+            code_lines.append('%s    xcb_buffer_len += xcb_block_len;' % space)
+            code_lines.append('%s    xcb_block_len = 0;' % space)
+
+        count += _c_serialize_helper_fields(context, self,
+                                            code_lines, temp_vars,
+                                            space, prefix, False)
+    # "final padding"
+    count += _c_serialize_helper_insert_padding(context, code_lines, space, False)
+
+    return count
+# _c_serialize_helper()
+
+def _c_serialize(context, self):
+    """
+    depending on the context variable, generate _serialize(), _unserialize(), _unpack(), or _sizeof()
+    for the ComplexType variable self
+    """
+    _h_setlevel(1)
+    _c_setlevel(1)
+
+    # _hc('')
+    # # _serialize() returns the buffer size
+    # _hc('int')
+
+    # sys.stderr.write('int')
+
+
+    if self.is_switch and 'unserialize' == context:
+        context = 'unpack'
+
+    cases = { 'serialize'   : self.c_serialize_name,
+              'unserialize' : self.c_unserialize_name,
+              'unpack'      : self.c_unpack_name,
+              'sizeof'      : self.c_sizeof_name }
+    func_name = cases[context]
+
+    param_fields, wire_fields, params = get_serialize_params(context, self)
+    variable_size_fields = 0
+    # maximum space required for type definition of function arguments
+    maxtypelen = 0
+
+    # determine N(variable_fields)
+    for field in param_fields:
+        # if self.is_switch, treat all fields as if they are variable sized
+        if not field.type.fixed_size() or self.is_switch:
+            variable_size_fields += 1
+    # determine maxtypelen
+    for p in params:
+        maxtypelen = max(maxtypelen, len(p[0]) + len(p[1]))
+
+    # write to .c/.h
+    indent = ' '*(len(func_name)+2)
+    param_str = []
+    for p in params:
+        typespec, pointerspec, field_name = p
+        spacing = ' '*(maxtypelen-len(typespec)-len(pointerspec))
+        param_str.append("%s%s%s  %s%s  /**< */" % (indent, typespec, spacing, pointerspec, field_name))
+    # insert function name
+    param_str[0] = "%s (%s" % (func_name, param_str[0].strip())
+    param_str = list(map(lambda x: "%s," % x, param_str))
+
+    # >>> THIS! <<< #
+    # for s in param_str[:-1]:
+    #     sys.stderr.write(s)
+
+    #     _hc(s)
+    # _h("%s);" % param_str[-1].rstrip(','))
+
+    # >>> AND THAT! <<< #
+    # sys.stderr.write("%s);" % param_str[-1].rstrip(','))
+    # >>> AND THAT! <<< #
+    _c("%s)" % param_str[-1].rstrip(','))
+    _c('{')
+
+    code_lines = []
+    temp_vars = []
+    prefix = []
+
+    if 'serialize' == context:
+        if not self.is_switch and not self.var_followed_by_fixed_fields:
+            _c('    %s *xcb_out = *_buffer;', self.c_type)
+            _c('    unsigned int xcb_out_pad = -sizeof(%s) & 3;', self.c_type)
+            _c('    unsigned int xcb_buffer_len = sizeof(%s) + xcb_out_pad;', self.c_type)
+            _c('    unsigned int xcb_align_to = 0;')
+        else:
+            _c('    char *xcb_out = *_buffer;')
+            _c('    unsigned int xcb_buffer_len = 0;')
+            _c('    unsigned int xcb_align_to = 0;')
+        prefix = [('_aux', '->', self)]
+        aux_ptr = 'xcb_out'
+
+    elif context in ('unserialize', 'unpack'):
+        _c('    char *xcb_tmp = (char *)_buffer;')
+        if not self.is_switch:
+            if not self.var_followed_by_fixed_fields:
+                _c('    const %s *_aux = (%s *)_buffer;', self.c_type, self.c_type)
+                prefix = [('_aux', '->', self)]
+            else:
+                _c('    %s xcb_out;', self.c_type)
+                prefix = [('xcb_out', '.', self)]
+        else:
+            aux_var = '_aux' # default for unpack: single pointer
+            # note: unserialize not generated for switch
+            if 'unserialize' == context:
+                aux_var = '(*_aux)' # unserialize: double pointer (!)
+            prefix = [(aux_var, '->', self)]
+        aux_ptr = '*_aux'
+        _c('    unsigned int xcb_buffer_len = 0;')
+        _c('    unsigned int xcb_block_len = 0;')
+        _c('    unsigned int xcb_pad = 0;')
+        _c('    unsigned int xcb_align_to = 0;')
+
+    elif 'sizeof' == context:
+        param_names = [p[2] for p in params]
+        if self.is_switch:
+            # switch: call _unpack()
+            _c('    %s _aux;', self.c_type)
+            _c('    return %s(%s, &_aux);', self.c_unpack_name, reduce(lambda x,y: "%s, %s" % (x, y), param_names))
+            _c('}')
+            return
+        elif self.var_followed_by_fixed_fields:
+            # special case: call _unserialize()
+            _c('    return %s(%s, NULL);', self.c_unserialize_name, reduce(lambda x,y: "%s, %s" % (x, y), param_names))
+            _c('}')
+            return
+        else:
+            _c('    char *xcb_tmp = (char *)_buffer;')
+            prefix = [('_aux', '->', self)]
+
+    count = _c_serialize_helper(context, self, code_lines, temp_vars, prefix=prefix)
+    # update variable size fields (only important for context=='serialize'
+    variable_size_fields = count
+    if 'serialize' == context:
+        temp_vars.append('    unsigned int xcb_pad = 0;')
+        temp_vars.append('    char xcb_pad0[3] = {0, 0, 0};')
+        temp_vars.append('    struct iovec xcb_parts[%d];' % count)
+        temp_vars.append('    unsigned int xcb_parts_idx = 0;')
+        temp_vars.append('    unsigned int xcb_block_len = 0;')
+        temp_vars.append('    unsigned int i;')
+        temp_vars.append('    char *xcb_tmp;')
+    elif 'sizeof' == context:
+        # neither switch nor intermixed fixed and variable size fields:
+        # evaluate parameters directly
+        if not (self.is_switch or self.var_followed_by_fixed_fields):
+
+            # look if we have to declare an '_aux' variable at all
+            if len(list(filter(lambda x: x.find('_aux')!=-1, code_lines)))>0:
+                if not self.var_followed_by_fixed_fields:
+                    _c('    const %s *_aux = (%s *)_buffer;', self.c_type, self.c_type)
+                else:
+                    _c('    %s *_aux = malloc(sizeof(%s));', self.c_type, self.c_type)
+
+            _c('    unsigned int xcb_buffer_len = 0;')
+            _c('    unsigned int xcb_block_len = 0;')
+            _c('    unsigned int xcb_pad = 0;')
+            _c('    unsigned int xcb_align_to = 0;')
+
+    _c('')
+    for t in temp_vars:
+        _c(t)
+    _c('')
+    for l in code_lines:
+        _c(l)
+
+    # variable sized fields have been collected, now
+    # allocate memory and copy everything into a continuous memory area
+    # note: this is not necessary in case of unpack
+    if context in ('serialize', 'unserialize'):
+        # unserialize: check for sizeof-only invocation
+        if 'unserialize' == context:
+            _c('')
+            _c('    if (NULL == _aux)')
+            _c('        return xcb_buffer_len;')
+
+        _c('')
+        _c('    if (NULL == %s) {', aux_ptr)
+        _c('        /* allocate memory */')
+        _c('        %s = malloc(xcb_buffer_len);', aux_ptr)
+        if 'serialize' == context:
+            _c('        *_buffer = xcb_out;')
+        _c('    }')
+        _c('')
+
+        # serialize: handle variable size fields in a loop
+        if 'serialize' == context:
+            if not self.is_switch and not self.var_followed_by_fixed_fields:
+                if len(wire_fields)>0:
+                    _c('    *xcb_out = *_aux;')
+            # copy variable size fields into the buffer
+            if variable_size_fields > 0:
+                # xcb_out padding
+                if not self.is_switch and not self.var_followed_by_fixed_fields:
+                    _c('    xcb_tmp = (char*)++xcb_out;')
+                    _c('    xcb_tmp += xcb_out_pad;')
+                else:
+                    _c('    xcb_tmp = xcb_out;')
+
+                # variable sized fields
+                _c('    for(i=0; i<xcb_parts_idx; i++) {')
+                _c('        if (0 != xcb_parts[i].iov_base && 0 != xcb_parts[i].iov_len)')
+                _c('            memcpy(xcb_tmp, xcb_parts[i].iov_base, xcb_parts[i].iov_len);')
+                _c('        if (0 != xcb_parts[i].iov_len)')
+                _c('            xcb_tmp += xcb_parts[i].iov_len;')
+                _c('    }')
+
+        # unserialize: assign variable size fields individually
+        if 'unserialize' == context:
+            _c('    xcb_tmp = ((char *)*_aux)+xcb_buffer_len;')
+            param_fields.reverse()
+            for field in param_fields:
+                if not field.type.fixed_size():
+                    _c('    xcb_tmp -= %s_len;', field.c_field_name)
+                    _c('    memmove(xcb_tmp, %s, %s_len);', field.c_field_name, field.c_field_name)
+            _c('    *%s = xcb_out;', aux_ptr)
+
+    _c('')
+    _c('    return xcb_buffer_len;')
+    _c('}')
+# _c_serialize()
+
+def _c_iterator_get_end(field, accum):
+    '''
+    Figures out what C code is needed to find the end of a variable-length structure field.
+    For nested structures, recurses into its last variable-sized field.
+    For lists, calls the end function
+    '''
+    if field.type.is_container:
+        accum = field.c_accessor_name + '(' + accum + ')'
+        return _c_iterator_get_end(field.type.last_varsized_field, accum)
+    if field.type.is_list:
+        # XXX we can always use the first way
+        if field.type.member.is_simple:
+            return field.c_end_name + '(' + accum + ')'
+        else:
+            return field.type.member.c_end_name + '(' + field.c_iterator_name + '(' + accum + '))'
+
+def _c_iterator(self, name):
+    '''
+    Declares the iterator structure and next/end functions for a given type.
+    '''
+    _h_setlevel(0)
+    _h('')
+    _h('/**')
+    _h(' * @brief %s', self.c_iterator_type)
+    _h(' **/')
+    _h('typedef struct %s {', self.c_iterator_type)
+    _h('    %s *data; /**<  */', self.c_type)
+    _h('    int%s rem; /**<  */', ' ' * (len(self.c_type) - 2))
+    _h('    int%s index; /**<  */', ' ' * (len(self.c_type) - 2))
+    _h('} %s;', self.c_iterator_type)
+
+    _h_setlevel(1)
+    _c_setlevel(1)
+    _h('')
+    _h('/**')
+    _h(' * Get the next element of the iterator')
+    _h(' * @param i Pointer to a %s', self.c_iterator_type)
+    _h(' *')
+    _h(' * Get the next element in the iterator. The member rem is')
+    _h(' * decreased by one. The member data points to the next')
+    _h(' * element. The member index is increased by sizeof(%s)', self.c_type)
+    _h(' */')
+    _c('')
+    _hc('')
+    _hc('/*****************************************************************************')
+    _hc(' **')
+    _hc(' ** void %s', self.c_next_name)
+    _hc(' ** ')
+    _hc(' ** @param %s *i', self.c_iterator_type)
+    _hc(' ** @returns void')
+    _hc(' **')
+    _hc(' *****************************************************************************/')
+    _hc(' ')
+    _hc('void')
+    _h('%s (%s *i  /**< */);', self.c_next_name, self.c_iterator_type)
+    _c('%s (%s *i  /**< */)', self.c_next_name, self.c_iterator_type)
+    _c('{')
+
+    if not self.fixed_size():
+        _c('    %s *R = i->data;', self.c_type)
+
+        if self.is_union:
+            # FIXME - how to determine the size of a variable size union??
+            _c('    /* FIXME - determine the size of the union %s */', self.c_type)
+        else:
+            if self.need_sizeof:
+                _c('    xcb_generic_iterator_t child;')
+                _c('    child.data = (%s *)(((char *)R) + %s(R));',
+                   self.c_type, self.c_sizeof_name)
+                _c('    i->index = (char *) child.data - (char *) i->data;')
+            else:
+                _c('    xcb_generic_iterator_t child = %s;', _c_iterator_get_end(self.last_varsized_field, 'R'))
+                _c('    i->index = child.index;')
+            _c('    --i->rem;')
+            _c('    i->data = (%s *) child.data;', self.c_type)
+
+    else:
+        _c('    --i->rem;')
+        _c('    ++i->data;')
+        _c('    i->index += sizeof(%s);', self.c_type)
+
+    _c('}')
+
+    _h('')
+    _h('/**')
+    _h(' * Return the iterator pointing to the last element')
+    _h(' * @param i An %s', self.c_iterator_type)
+    _h(' * @return  The iterator pointing to the last element')
+    _h(' *')
+    _h(' * Set the current element in the iterator to the last element.')
+    _h(' * The member rem is set to 0. The member data points to the')
+    _h(' * last element.')
+    _h(' */')
+    _c('')
+    _hc('')
+    _hc('/*****************************************************************************')
+    _hc(' **')
+    _hc(' ** xcb_generic_iterator_t %s', self.c_end_name)
+    _hc(' ** ')
+    _hc(' ** @param %s i', self.c_iterator_type)
+    _hc(' ** @returns xcb_generic_iterator_t')
+    _hc(' **')
+    _hc(' *****************************************************************************/')
+    _hc(' ')
+    _hc('xcb_generic_iterator_t')
+    _h('%s (%s i  /**< */);', self.c_end_name, self.c_iterator_type)
+    _c('%s (%s i  /**< */)', self.c_end_name, self.c_iterator_type)
+    _c('{')
+    _c('    xcb_generic_iterator_t ret;')
+
+    if self.fixed_size():
+        _c('    ret.data = i.data + i.rem;')
+        _c('    ret.index = i.index + ((char *) ret.data - (char *) i.data);')
+        _c('    ret.rem = 0;')
+    else:
+        _c('    while(i.rem > 0)')
+        _c('        %s(&i);', self.c_next_name)
+        _c('    ret.data = i.data;')
+        _c('    ret.rem = i.rem;')
+        _c('    ret.index = i.index;')
+
+    _c('    return ret;')
+    _c('}')
+
+def _c_accessor_get_length(expr, field_mapping=None):
+    '''
+    Figures out what C code is needed to get a length field.
+    The field_mapping parameter can be used to change the absolute name of a length field.
+    For fields that follow a variable-length field, use the accessor.
+    Otherwise, just reference the structure field directly.
+    '''
+
+    lenfield_name = expr.lenfield_name
+    if lenfield_name is not None:
+        if field_mapping is not None and lenfield_name in field_mapping:
+            lenfield_name = field_mapping[lenfield_name][0]
+
+    if expr.lenfield is not None and expr.lenfield.prev_varsized_field is not None:
+        # special case: variable and fixed size fields are intermixed
+        # if the lenfield is among the fixed size fields, there is no need
+        # to call a special accessor function like <expr.lenfield.c_accessor_name + '(' + prefix + ')'>
+        return field_mapping(expr.lenfield_name)
+    elif expr.lenfield_name is not None:
+        return lenfield_name
+    else:
+        return str(expr.nmemb)
+
+def _c_accessor_get_expr(expr, field_mapping):
+    '''
+    Figures out what C code is needed to get the length of a list field.
+    The field_mapping parameter can be used to change the absolute name of a length field.
+    Recurses for math operations.
+    Returns bitcount for value-mask fields.
+    Otherwise, uses the value of the length field.
+    '''
+    lenexp = _c_accessor_get_length(expr, field_mapping)
+
+    if expr.op == '~':
+        return '(' + '~' + _c_accessor_get_expr(expr.rhs, field_mapping) + ')'
+    elif expr.op == 'popcount':
+        return 'xcb_popcount(' + _c_accessor_get_expr(expr.rhs, field_mapping) + ')'
+    elif expr.op == 'enumref':
+        enum_name = expr.lenfield_type.name
+        constant_name = expr.lenfield_name
+        c_name = _n(enum_name + (constant_name,)).upper()
+        return c_name
+    elif expr.op == 'sumof':
+        # locate the referenced list object
+        list_obj = expr.lenfield_type
+        field = None
+        for f in expr.lenfield_parent.fields:
+            if f.field_name == expr.lenfield_name:
+                field = f
+                break
+
+        if field is None:
+            raise Exception("list field '%s' referenced by sumof not found" % expr.lenfield_name)
+        list_name = field_mapping[field.c_field_name][0]
+        c_length_func = "%s(%s)" % (field.c_length_name, list_name)
+        # note: xcb_sumof() has only been defined for integers
+        c_length_func = _c_accessor_get_expr(field.type.expr, field_mapping)
+        return 'xcb_sumof(%s, %s)' % (list_name, c_length_func)
+    elif expr.op != None:
+        return ('(' + _c_accessor_get_expr(expr.lhs, field_mapping) +
+                ' ' + expr.op + ' ' +
+                _c_accessor_get_expr(expr.rhs, field_mapping) + ')')
+    elif expr.bitfield:
+        return 'xcb_popcount(' + lenexp + ')'
+    else:
+        return lenexp
+
+def type_pad_type(type):
+    if type == 'void':
+        return 'char'
+    return type
+
+def _c_accessors_field(self, field):
+    '''
+    Declares the accessor functions for a non-list field that follows a variable-length field.
+    '''
+    c_type = self.c_type
+
+    # special case: switch
+    switch_obj = self if self.is_switch else None
+    if self.is_bitcase:
+        switch_obj = self.parents[-1]
+    if switch_obj is not None:
+        c_type = switch_obj.c_type
+
+    if field.type.is_simple:
+        _hc('')
+        _hc('')
+        _hc('/*****************************************************************************')
+        _hc(' ** ')
+        _hc(' ** %s %s', field.c_field_type, field.c_accessor_name)
+        _hc(' ** ')
+        _hc(' ** @param const %s *R', c_type)
+        _hc(' ** @returns %s', field.c_field_type)
+        _hc(' **')
+        _hc(' *****************************************************************************/')
+        _hc(' ')
+        _hc('%s', field.c_field_type)
+        _h('%s (const %s *R  /**< */);', field.c_accessor_name, c_type)
+        _c('%s (const %s *R  /**< */)', field.c_accessor_name, c_type)
+        _c('{')
+        if field.prev_varsized_field is None:
+            _c('    return (%s *) (R + 1);', field.c_field_type)
+        else:
+            _c('    xcb_generic_iterator_t prev = %s;', _c_iterator_get_end(field.prev_varsized_field, 'R'))
+            _c('    return * (%s *) ((char *) prev.data + XCB_TYPE_PAD(%s, prev.index) + %d);',
+               field.c_field_type, type_pad_type(field.first_field_after_varsized.type.c_type), field.prev_varsized_offset)
+        _c('}')
+    else:
+        _hc('')
+        _hc('')
+        _hc('/*****************************************************************************')
+        _hc(' **')
+        _hc(' ** %s * %s', field.c_field_type, field.c_accessor_name)
+        _hc(' ** ')
+        _hc(' ** @param const %s *R', c_type)
+        _hc(' ** @returns %s *', field.c_field_type)
+        _hc(' **')
+        _hc(' *****************************************************************************/')
+        _hc(' ')
+        if field.type.is_switch and switch_obj is None:
+            return_type = 'void *'
+        else:
+            return_type = '%s *' % field.c_field_type
+
+        _hc(return_type)
+        _h('%s (const %s *R  /**< */);', field.c_accessor_name, c_type)
+        _c('%s (const %s *R  /**< */)', field.c_accessor_name, c_type)
+        _c('{')
+        if field.prev_varsized_field is None:
+            _c('    return (%s) (R + 1);', return_type)
+            # note: the special case 'variable fields followed by fixed size fields'
+            #       is not of any consequence here, since the ordering gets
+            #       'corrected' in the reply function
+        else:
+            _c('    xcb_generic_iterator_t prev = %s;', _c_iterator_get_end(field.prev_varsized_field, 'R'))
+            _c('    return (%s) ((char *) prev.data + XCB_TYPE_PAD(%s, prev.index) + %d);',
+               return_type, type_pad_type(field.first_field_after_varsized.type.c_type), field.prev_varsized_offset)
+        _c('}')
+
+
+def _c_accessors_list(self, field):
+    '''
+    Declares the accessor functions for a list field.
+    Declares a direct-accessor function only if the list members are fixed size.
+    Declares length and get-iterator functions always.
+    '''
+    list = field.type
+    c_type = self.c_type
+
+    # special case: switch
+    # in case of switch, 2 params have to be supplied to certain accessor functions:
+    #   1. the anchestor object (request or reply)
+    #   2. the (anchestor) switch object
+    # the reason is that switch is either a child of a request/reply or nested in another switch,
+    # so whenever we need to access a length field, we might need to refer to some anchestor type
+    switch_obj = self if self.is_switch else None
+    if self.is_bitcase:
+        switch_obj = self.parents[-1]
+    if switch_obj is not None:
+        c_type = switch_obj.c_type
+
+    params = []
+    fields = {}
+    parents = self.parents if hasattr(self, 'parents') else [self]
+    # 'R': parents[0] is always the 'toplevel' container type
+    params.append(('const %s *R' % parents[0].c_type, parents[0]))
+    fields.update(_c_helper_field_mapping(parents[0], [('R', '->', parents[0])], flat=True))
+    # auxiliary object for 'R' parameters
+    R_obj = parents[0]
+
+    if switch_obj is not None:
+        # now look where the fields are defined that are needed to evaluate
+        # the switch expr, and store the parent objects in accessor_params and
+        # the fields in switch_fields
+
+        # 'S': name for the 'toplevel' switch
+        toplevel_switch = parents[1]
+        params.append(('const %s *S' % toplevel_switch.c_type, toplevel_switch))
+        fields.update(_c_helper_field_mapping(toplevel_switch, [('S', '->', toplevel_switch)], flat=True))
+
+        # initialize prefix for everything "below" S
+        prefix_str = '/* %s */ S' % toplevel_switch.name[-1]
+        prefix = [(prefix_str, '->', toplevel_switch)]
+
+        # look for fields in the remaining containers
+        for p in parents[2:] + [self]:
+            # the separator between parent and child is always '.' here,
+            # because of nested switch statements
+            if not p.is_bitcase or (p.is_bitcase and p.has_name):
+                prefix.append((p.name[-1], '.', p))
+            fields.update(_c_helper_field_mapping(p, prefix, flat=True))
+
+        # auxiliary object for 'S' parameter
+        S_obj = parents[1]
+
+    _h_setlevel(1)
+
+    if list.member.fixed_size():
+        idx = 1 if switch_obj is not None else 0
+
+    if switch_obj is not None:
+        spacing = ' '*(len(field.c_length_name)+2)
+        length = _c_accessor_get_expr(field.type.expr, fields)
+    else:
+        length = _c_accessor_get_expr(field.type.expr, fields)
+
+    request_name = _ext(_n_item(self.name[-1]))
+
+    if not request_name in _cpp_request_objects:
+        # print >> sys.stderr, 'WARN: Skipping undefined _cpp_request_object %s' % (request_name,)
+        return
+
+    if list.member.fixed_size() and not self.is_bitcase:
+        if field.c_field_type == "char":
+            _cpp_request_objects[request_name].accessors.append( \
+            Accessor(is_string=True,
+                     member=_ext(_n_item(field.field_name)),
+                     c_name=_n(self.name))
+            )
+
+        else:
+            _cpp_request_objects[request_name].accessors.append( \
+            Accessor(is_fixed=True,
+                     member=_ext(_n_item(field.field_name)),
+                     c_type=field.c_field_type,
+                     return_type="", # 'Type' if field.c_field_type == 'void' else field.c_field_type,
+                     iter_name="",
+                     c_name=_n(self.name))
+            )
+
+    else:
+
+        # sys.stderr.write('request_name: %s\n' % request_name)
+        # sys.stderr.write('c_iterator_name:\n%s;\nc_end_name:\n%s\n' \
+        #         % (field.c_iterator_name, field.c_end_name))
+        # sys.stderr.write('field: %s\n' % (field))
+        # sys.stderr.write('\n\n')
+
+        if not self.is_bitcase:
+            _cpp_request_objects[request_name].accessors.append( \
+            Accessor(is_variable=True,
+                     member=_ext(_n_item(field.field_name)),
+                     c_type=field.c_field_type,
+                     return_type='Type' if field.c_field_type == 'void' else field.c_field_type,
+                     iter_name=_n(field.type.name),
+                     c_name=_n(self.name))
+            )
+
+    # sys.stderr.write('c_iterator_name:\n%s;\nc_end_name:\n%s\n' % (field.c_iterator_name,
+    #     field.c_end_name))
+    # sys.stderr.write('field: %s\n' % (field))
+    # sys.stderr.write('\n\n')
+
+def _c_accessors(self, name, base):
+    '''
+    Declares the accessor functions for the fields of a structure.
+    '''
+    # no accessors for switch itself -
+    # switch always needs to be unpacked explicitly
+
+    for field in self.fields:
+        if field.type.is_list and not field.type.fixed_size():
+            _c_accessors_list(self, field)
+        elif field.prev_varsized_field is not None or not field.type.fixed_size():
+            pass
+            # _c_accessors_field(self, field)
+            # sys.stderr.write("c_accessors_field(%s, %s)\n" % (self, field))
+
+def c_simple(self, name):
+    '''
+    Exported function that handles cardinal type declarations.
+    These are types which are typedef'd to one of the CARDx's, char, float, etc.
+    '''
+    _c_type_setup(self, name, ())
+
+    if (self.name != name):
+        # Typedef
+        _h_setlevel(0)
+        my_name = _t(name)
+        # _h('')
+        # _h('typedef %s %s;', _t(self.name), my_name)
+        # if field.type.is_simple:
+        #     if len(name) == 2:
+        # _h('NS_HEAD(type)')
+        # _h("TYPE_CLASS(%s)", _ext(_n_item(name[-1])))
+        # _h('NS_TAIL(type)')
+        # sys.stderr.write('type: %s, name: %s\n' % (field.field_type, field.field_name))
+        # sys.stderr.write('simple: %s\n' % (field))
+
+        # Iterator
+        # _c_iterator(self, name)
+
+def _c_complex(self):
+    '''
+    Helper function for handling all structure types.
+    Called for all structs, requests, replies, events, errors.
+    '''
+
+    '''
+    _h_setlevel(0)
+    _h('')
+    _h('/**')
+    _h(' * @brief %s', self.c_type)
+    _h(' **/')
+    _h('typedef %s %s {', self.c_container, self.c_type)
+    '''
+
+    struct_fields = []
+    maxtypelen = 0
+
+    varfield = None
+    for field in self.fields:
+        if not field.type.fixed_size() and not self.is_switch and not self.is_union:
+            varfield = field.c_field_name
+            continue
+        if field.wire:
+            struct_fields.append(field)
+
+    for field in struct_fields:
+        length = len(field.c_field_type)
+        # account for '*' pointer_spec
+        if not field.type.fixed_size() and not self.is_union:
+            length += 1
+        maxtypelen = max(maxtypelen, length)
+
+    ### TODO: serialization(?)
+    def _c_complex_field(self, field, space=''):
+        if (field.type.fixed_size() or self.is_union or
+            # in case of switch with switch children, don't make the field a pointer
+            # necessary for unserialize to work
+            (self.is_switch and field.type.is_switch)):
+            spacing = ' ' * (maxtypelen - len(field.c_field_type))
+            # _h('%s    %s%s %s%s; /**<  */', space, field.c_field_type, spacing, field.c_field_name, field.c_subscript)
+            # _h("%s %s" % (field.field_type, field.field_name))
+            # sys.stderr.write("serialize: %s, %s\n" % (field.field_type, field.field_name))
+        else:
+            spacing = ' ' * (maxtypelen - (len(field.c_field_type) + 1))
+            # _h('%s    %s%s *%s%s; /**<  */', space, field.c_field_type, spacing, field.c_field_name, field.c_subscript)
+
+    if not self.is_switch:
+        for field in struct_fields:
+            _c_complex_field(self, field)
+    else:
+        for b in self.bitcases:
+            space = ''
+            if b.type.has_name:
+                # _h('    struct _%s {', b.c_field_name)
+                space = '    '
+            for field in b.type.fields:
+                _c_complex_field(self, field, space)
+            # if b.type.has_name:
+                # _h('    } %s;', b.c_field_name)
+
+    # _h('} %s;', self.c_type)
+
+def c_struct(self, name):
+    '''
+    Exported function that handles structure declarations.
+    '''
+    _c_type_setup(self, name, ())
+    _c_complex(self)
+    _c_accessors(self, name, name)
+    _c_iterator(self, name)
+
+def c_union(self, name):
+    '''
+    Exported function that handles union declarations.
+    '''
+    _c_type_setup(self, name, ())
+    _c_complex(self)
+    _c_iterator(self, name)
+
+def _c_request_helper(self, name, cookie_type, void, regular, aux=False, reply_fds=False):
+    '''
+    Declares a request function.
+    '''
+
+    # Four stunningly confusing possibilities here:
+    #
+    #   Void            Non-void
+    # ------------------------------
+    # "req"            "req"
+    # 0 flag           CHECKED flag   Normal Mode
+    # void_cookie      req_cookie
+    # ------------------------------
+    # "req_checked"    "req_unchecked"
+    # CHECKED flag     0 flag         Abnormal Mode
+    # void_cookie      req_cookie
+    # ------------------------------
+
+
+    # Whether we are _checked or _unchecked
+    checked = void and not regular
+    unchecked = not void and not regular
+
+    # What kind of cookie we return
+    func_cookie = 'xcb_void_cookie_t' if void else self.c_cookie_type
+
+    # What flag is passed to xcb_request
+    func_flags = '0' if (void and regular) or (not void and not regular) else 'XCB_REQUEST_CHECKED'
+
+    if reply_fds:
+        if func_flags == '0':
+            func_flags = 'XCB_REQUEST_REPLY_FDS'
+        else:
+            func_flags = func_flags + '|XCB_REQUEST_REPLY_FDS'
+
+    # Global extension id variable or NULL for xproto
+    func_ext_global = '&' + _ns.c_ext_global_name if _ns.is_ext else '0'
+
+    # What our function name is
+    func_name = self.c_request_name if not aux else self.c_aux_name
+    if checked:
+        func_name = self.c_checked_name if not aux else self.c_aux_checked_name
+    if unchecked:
+        func_name = self.c_unchecked_name if not aux else self.c_aux_unchecked_name
+
+    param_fields = []
+    wire_fields = []
+    maxtypelen = len('xcb_connection_t')
+    serial_fields = []
+    # special case: list with variable size elements
+    list_with_var_size_elems = False
+
+    for field in self.fields:
+        if field.visible:
+            # The field should appear as a call parameter
+            param_fields.append(field)
+        if field.wire and not field.auto:
+            # We need to set the field up in the structure
+            wire_fields.append(field)
+        if field.type.need_serialize or field.type.need_sizeof:
+            serial_fields.append(field)
+
+    for field in param_fields:
+        c_field_const_type = field.c_field_const_type
+        if field.type.need_serialize and not aux:
+            c_field_const_type = "const void"
+        if len(c_field_const_type) > maxtypelen:
+            maxtypelen = len(c_field_const_type)
+        if field.type.is_list and not field.type.member.fixed_size():
+            list_with_var_size_elems = True
+
+    _h_setlevel(1)
+    _c_setlevel(1)
+    # _h('')
+    # _h('/**')
+    # if hasattr(self, "doc") and self.doc:
+    #     if self.doc.brief:
+    #         _h(' * @brief ' + self.doc.brief)
+    #     else:
+    #         _h(' * No brief doc yet')
+
+    # _h(' *')
+    # _h(' * @param c The connection')
+    param_names = [f.c_field_name for f in param_fields]
+    if hasattr(self, "doc") and self.doc:
+        for field in param_fields:
+            # XXX: hard-coded until we fix xproto.xml
+            base_func_name = self.c_request_name if not aux else self.c_aux_name
+            if base_func_name == 'xcb_change_gc' and field.c_field_name == 'value_mask':
+                field.enum = 'GC'
+            elif base_func_name == 'xcb_change_window_attributes' and field.c_field_name == 'value_mask':
+                field.enum = 'CW'
+            elif base_func_name == 'xcb_create_window' and field.c_field_name == 'value_mask':
+                field.enum = 'CW'
+            if field.enum:
+                # XXX: why the 'xcb' prefix?
+                key = ('xcb', field.enum)
+
+                tname = _t(key)
+                if namecount[tname] > 1:
+                    tname = _t(key + ('enum',))
+                # _h(' * @param %s A bitmask of #%s values.' % (field.c_field_name, tname))
+
+            if self.doc and field.field_name in self.doc.fields:
+                desc = self.doc.fields[field.field_name]
+                for name in param_names:
+                    desc = desc.replace('`%s`' % name, '\\a %s' % (name))
+                desc = desc.split("\n")
+                desc = [line if line != '' else '\\n' for line in desc]
+                # _h(' * @param %s %s' % (field.c_field_name, "\n * ".join(desc)))
+            # If there is no documentation yet, we simply don't generate an
+            # @param tag. Doxygen will then warn about missing documentation.
+
+    # _h(' * @return A cookie')
+    # _h(' *')
+
+    # if hasattr(self, "doc") and self.doc:
+    #     if self.doc.description:
+    #         desc = self.doc.description
+    #         for name in param_names:
+    #             desc = desc.replace('`%s`' % name, '\\a %s' % (name))
+    #         desc = desc.split("\n")
+    #         _h(' * ' + "\n * ".join(desc))
+    #     else:
+    #         _h(' * No description yet')
+    # else:
+    #     _h(' * Delivers a request to the X server.')
+    # _h(' * ')
+    # if checked:
+    #     _h(' * This form can be used only if the request will not cause')
+    #     _h(' * a reply to be generated. Any returned error will be')
+    #     _h(' * saved for handling by xcb_request_check().')
+    # if unchecked:
+    #     _h(' * This form can be used only if the request will cause')
+    #     _h(' * a reply to be generated. Any returned error will be')
+    #     _h(' * placed in the event queue.')
+    # _h(' */')
+    # _c('')
+    # _hc('')
+    # _hc('/*****************************************************************************')
+    # _hc(' **')
+    # _hc(' ** %s %s', cookie_type, func_name)
+    # _hc(' ** ')
+
+    spacing = ' ' * (maxtypelen - len('xcb_connection_t'))
+    _c(' ** @param xcb_connection_t%s *c', spacing)
+
+    for field in param_fields:
+        c_field_const_type = field.c_field_const_type
+        if field.type.need_serialize and not aux:
+            c_field_const_type = "const void"
+        spacing = ' ' * (maxtypelen - len(c_field_const_type))
+        _c(' ** @param %s%s %s%s', c_field_const_type, spacing, field.c_pointer, field.c_field_name)
+
+    _c(' ** @returns %s', cookie_type)
+    _c(' **')
+    _c(' *****************************************************************************/')
+    _c(' ')
+    _c('%s', cookie_type)
+
+    spacing = ' ' * (maxtypelen - len('xcb_connection_t'))
+    comma = ',' if len(param_fields) else ');'
+    # _h('%s (xcb_connection_t%s *c  /**< */%s', func_name, spacing, comma)
+    comma = ',' if len(param_fields) else ')'
+    _c('%s (xcb_connection_t%s *c  /**< */%s', func_name, spacing, comma)
+
+    func_spacing = ' ' * (len(func_name) + 2)
+    count = len(param_fields)
+    for field in param_fields:
+        count = count - 1
+        c_field_const_type = field.c_field_const_type
+        c_pointer = field.c_pointer
+        if field.type.need_serialize and not aux:
+            c_field_const_type = "const void"
+            c_pointer = '*'
+        spacing = ' ' * (maxtypelen - len(c_field_const_type))
+        comma = ',' if count else ');'
+        # _h('%s%s%s %s%s  /**< */%s', func_spacing, c_field_const_type,
+        #    spacing, c_pointer, field.c_field_name, comma)
+        comma = ',' if count else ')'
+        _c('%s%s%s %s%s  /**< */%s', func_spacing, c_field_const_type,
+           spacing, c_pointer, field.c_field_name, comma)
+
+    count = 2
+    if not self.var_followed_by_fixed_fields:
+        for field in param_fields:
+            if not field.type.fixed_size():
+                count = count + 2
+                if field.type.need_serialize:
+                    # _serialize() keeps track of padding automatically
+                    count -= 1
+    dimension = count + 2
+
+    _c('{')
+    _c('    static const xcb_protocol_request_t xcb_req = {')
+    _c('        /* count */ %d,', count)
+    _c('        /* ext */ %s,', func_ext_global)
+    _c('        /* opcode */ %s,', self.c_request_name.upper())
+    _c('        /* isvoid */ %d', 1 if void else 0)
+    _c('    };')
+    _c('    ')
+
+    _c('    struct iovec xcb_parts[%d];', dimension)
+    _c('    %s xcb_ret;', func_cookie)
+    _c('    %s xcb_out;', self.c_type)
+    if self.var_followed_by_fixed_fields:
+        _c('    /* in the protocol description, variable size fields are followed by fixed size fields */')
+        _c('    void *xcb_aux = 0;')
+
+
+    for idx, f in enumerate(serial_fields):
+        if aux:
+            _c('    void *xcb_aux%d = 0;' % (idx))
+    if list_with_var_size_elems:
+        _c('    unsigned int i;')
+        _c('    unsigned int xcb_tmp_len;')
+        _c('    char *xcb_tmp;')
+    _c('    ')
+    # simple request call tracing
+#    _c('    printf("in function %s\\n");' % func_name)
+
+    # fixed size fields
+    for field in wire_fields:
+        if field.type.fixed_size():
+            if field.type.is_expr:
+                _c('    xcb_out.%s = %s;', field.c_field_name, _c_accessor_get_expr(field.type.expr, None))
+            elif field.type.is_pad:
+                if field.type.nmemb == 1:
+                    _c('    xcb_out.%s = 0;', field.c_field_name)
+                else:
+                    _c('    memset(xcb_out.%s, 0, %d);', field.c_field_name, field.type.nmemb)
+            else:
+                if field.type.nmemb == 1:
+                    _c('    xcb_out.%s = %s;', field.c_field_name, field.c_field_name)
+                else:
+                    _c('    memcpy(xcb_out.%s, %s, %d);', field.c_field_name, field.c_field_name, field.type.nmemb)
+
+    def get_serialize_args(type_obj, c_field_name, aux_var, context='serialize'):
+        serialize_args = get_serialize_params(context, type_obj,
+                                              c_field_name,
+                                              aux_var)[2]
+        return reduce(lambda x,y: "%s, %s" % (x,y), [a[2] for a in serialize_args])
+
+    # calls in order to free dyn. all. memory
+    free_calls = []
+
+    _c('    ')
+    if not self.var_followed_by_fixed_fields:
+        _c('    xcb_parts[2].iov_base = (char *) &xcb_out;')
+        _c('    xcb_parts[2].iov_len = sizeof(xcb_out);')
+        _c('    xcb_parts[3].iov_base = 0;')
+        _c('    xcb_parts[3].iov_len = -xcb_parts[2].iov_len & 3;')
+
+        count = 4
+
+        for field in param_fields:
+            if not field.type.fixed_size():
+                _c('    /* %s %s */', field.type.c_type, field.c_field_name)
+                # default: simple cast to char *
+                if not field.type.need_serialize and not field.type.need_sizeof:
+                    _c('    xcb_parts[%d].iov_base = (char *) %s;', count, field.c_field_name)
+                    if field.type.is_list:
+                        # _c("IS_LIST")
+                        if field.type.member.fixed_size():
+                            _c('    xcb_parts[%d].iov_len = %s * sizeof(%s);', count,
+                               _c_accessor_get_expr(field.type.expr, None),
+                               field.type.member.c_wiretype)
+                        else:
+                            list_length = _c_accessor_get_expr(field.type.expr, None)
+
+                            length = ''
+                            _c("    xcb_parts[%d].iov_len = 0;" % count)
+                            _c("    xcb_tmp = (char *)%s;", field.c_field_name)
+                            _c("    for(i=0; i<%s; i++) {" % list_length)
+                            _c("        xcb_tmp_len = %s(xcb_tmp);" %
+                                              (field.type.c_sizeof_name))
+                            _c("        xcb_parts[%d].iov_len += xcb_tmp_len;" % count)
+                            _c("        xcb_tmp += xcb_tmp_len;")
+                            _c("    }")
+                    else:
+                        # not supposed to happen
+                        raise Exception("unhandled variable size field %s" % field.c_field_name)
+                else:
+                    if not aux:
+                        _c('    xcb_parts[%d].iov_base = (char *) %s;', count, field.c_field_name)
+                    idx = serial_fields.index(field)
+                    aux_var = '&xcb_aux%d' % idx
+                    context = 'serialize' if aux else 'sizeof'
+                    _c('    xcb_parts[%d].iov_len = ', count)
+                    if aux:
+                        serialize_args = get_serialize_args(field.type, aux_var, field.c_field_name, context)
+                        _c('      %s (%s);', field.type.c_serialize_name, serialize_args)
+                        _c('    xcb_parts[%d].iov_base = xcb_aux%d;' % (count, idx))
+                        free_calls.append('    free(xcb_aux%d);' % idx)
+                    else:
+                        serialize_args = get_serialize_args(field.type, field.c_field_name, aux_var, context)
+                        func_name = field.type.c_sizeof_name
+                        _c('      %s (%s);', func_name, serialize_args)
+
+                count += 1
+                if not (field.type.need_serialize or field.type.need_sizeof):
+                    # the _serialize() function keeps track of padding automatically
+                    _c('    xcb_parts[%d].iov_base = 0;', count)
+                    _c('    xcb_parts[%d].iov_len = -xcb_parts[%d].iov_len & 3;', count, count-1)
+                    count += 1
+
+    # elif self.var_followed_by_fixed_fields:
+    else:
+        _c('    xcb_parts[2].iov_base = (char *) &xcb_out;')
+        # request header: opcodes + length
+        _c('    xcb_parts[2].iov_len = 2*sizeof(uint8_t) + sizeof(uint16_t);')
+        count += 1
+        # call _serialize()
+        buffer_var = '&xcb_aux'
+        serialize_args = get_serialize_args(self, buffer_var, '&xcb_out', 'serialize')
+        _c('    xcb_parts[%d].iov_len = %s (%s);', count, self.c_serialize_name, serialize_args)
+        _c('    xcb_parts[%d].iov_base = (char *) xcb_aux;', count)
+        free_calls.append('    free(xcb_aux);')
+        # no padding necessary - _serialize() keeps track of padding automatically
+
+    _c('    ')
+    for field in param_fields:
+        if field.isfd:
+            _c('    xcb_send_fd(c, %s);', field.c_field_name)
+
+    _c('    xcb_ret.sequence = xcb_send_request(c, %s, xcb_parts + 2, &xcb_req);', func_flags)
+
+    # free dyn. all. data, if any
+    for f in free_calls:
+        _c(f)
+    _c('    return xcb_ret;')
+    _c('}')
+
+def _cpp_request_helper(self, name, is_void):
+    '''
+    Declares a request function.
+    '''
+
+    request_name = _ext(_n_item(self.name[-1]))
+    c_func_name = _n(self.name)
+
+    param_fields = []
+
+    for field in self.fields:
+        if field.visible:
+            param_fields.append(field)
+
+    for field in param_fields:
+        c_field_const_type = field.c_field_const_type
+        if field.type.need_serialize:
+            c_field_const_type = "const void"
+
+    _cpp_request_names.append(request_name)
+    # self == request
+    _cpp_request_objects[request_name] = CppRequest(self, request_name, is_void, _ns, self.reply)
+
+    # is_obj_func = False
+    # if (len(param_fields) > 0 and len(param_fields[0].field_type) > 1):
+    #     # e.g.: DRAWABLE in { "DRAWABLE" : [], .. }
+    #     obj_name = param_fields[0].field_type[-1]
+    #     is_obj_func = obj_name in _type_objects[get_namespace(_ns)]
+
+    generate_request_specialization = False
+    for field in param_fields:
+        c_field_const_type = field.c_field_const_type
+
+        if field.c_pointer == " ": c_pointer = ""
+        else: c_pointer = " " + field.c_pointer
+
+        if field.type.need_serialize:
+            c_field_const_type = "const void"
+            c_pointer = ' *'
+
+        param = Parameter(field) # , verbose=request_name=="set_screen_config")
+
+        _cpp_request_objects[request_name].add(param)
+
+        if (param.is_const and param.is_pointer
+                and param.c_type == 'void'):
+            generate_request_specialization = True
+
+    _cpp_request_objects[request_name].make_wrapped()
+
+    _interface_class.add(_cpp_request_objects[request_name])
+
+    for key in _object_classes:
+        _object_classes[key].set_namespace(_ns)
+        _object_classes[key].add(_cpp_request_objects[request_name])
+
+    ### C CODE ###
+
+    # if generate_request_specialization:
+    #     if self.reply:
+    #         # _c_type_setup(self.reply, name, ('reply',))
+    #         # Reply structure definition
+    #         # _c_complex(self.reply)
+    #         # Request prototypes
+    #         has_fds = _c_reply_has_fds(self.reply)
+    #         _c_request_helper(self, name, self.c_cookie_type, False, True, False, has_fds)
+    #         _c_request_helper(self, name, self.c_cookie_type, False, False, False, has_fds)
+    #         if self.need_aux:
+    #             _c_request_helper(self, name, self.c_cookie_type, False, True, True, has_fds)
+    #             _c_request_helper(self, name, self.c_cookie_type, False, False, True, has_fds)
+    #         # Reply accessors
+    #         # _c_accessors(self.reply, name + ('reply',), name)
+    #         # _c_reply(self, name)
+    #         # if has_fds:
+    #         #     _c_reply_fds(self, name)
+    #     else:
+    #         # Request prototypes
+    #         _c_request_helper(self, name, 'xcb_void_cookie_t', True, False)
+    #         _c_request_helper(self, name, 'xcb_void_cookie_t', True, True)
+    #         if self.need_aux:
+    #             _c_request_helper(self, name, 'xcb_void_cookie_t', True, False, True)
+    #             _c_request_helper(self, name, 'xcb_void_cookie_t', True, True, True)
+
+    ### C CODE ###
+
+def _c_reply(self, name):
+    '''
+    Declares the function that returns the reply structure.
+    '''
+    spacing1 = ' ' * (len(self.c_cookie_type) - len('xcb_connection_t'))
+    spacing2 = ' ' * (len(self.c_cookie_type) - len('xcb_generic_error_t'))
+    spacing3 = ' ' * (len(self.c_reply_name) + 2)
+
+    # check if _unserialize() has to be called for any field
+    def look_for_special_cases(complex_obj):
+        unserialize_fields = []
+        # no unserialize call in case of switch
+        if not complex_obj.is_switch:
+            for field in complex_obj.fields:
+                # three cases: 1. field with special case
+                #              2. container that contains special case field
+                #              3. list with special case elements
+                if field.type.var_followed_by_fixed_fields:
+                    unserialize_fields.append(field)
+                elif field.type.is_container:
+                    unserialize_fields += look_for_special_cases(field.type)
+                elif field.type.is_list:
+                    if field.type.member.var_followed_by_fixed_fields:
+                        unserialize_fields.append(field)
+                    if field.type.member.is_container:
+                        unserialize_fields += look_for_special_cases(field.type.member)
+        return unserialize_fields
+
+    unserialize_fields = look_for_special_cases(self.reply)
+
+    '''
+    _h('')
+    _h('/**')
+    _h(' * Return the reply')
+    _h(' * @param c      The connection')
+    _h(' * @param cookie The cookie')
+    _h(' * @param e      The xcb_generic_error_t supplied')
+    _h(' *')
+    _h(' * Returns the reply of the request asked by')
+    _h(' * ')
+    _h(' * The parameter @p e supplied to this function must be NULL if')
+    _h(' * %s(). is used.', self.c_unchecked_name)
+    _h(' * Otherwise, it stores the error if any.')
+    _h(' *')
+    _h(' * The returned value must be freed by the caller using free().')
+    _h(' */')
+    _c('')
+    _hc('')
+    _hc('/*****************************************************************************')
+    _hc(' **')
+    _hc(' ** %s * %s', self.c_reply_type, self.c_reply_name)
+    _hc(' ** ')
+    _hc(' ** @param xcb_connection_t%s  *c', spacing1)
+    _hc(' ** @param %s   cookie', self.c_cookie_type)
+    _hc(' ** @param xcb_generic_error_t%s **e', spacing2)
+    _hc(' ** @returns %s *', self.c_reply_type)
+    _hc(' **')
+    _hc(' *****************************************************************************/')
+    '''
+
+    _hc(' ')
+    _hc('%s *', self.c_reply_type)
+    _hc('%s (xcb_connection_t%s  *c  /**< */,', self.c_reply_name, spacing1)
+    _hc('%s%s   cookie  /**< */,', spacing3, self.c_cookie_type)
+    _h('%sxcb_generic_error_t%s **e  /**< */);', spacing3, spacing2)
+    _c('%sxcb_generic_error_t%s **e  /**< */)', spacing3, spacing2)
+    _c('{')
+
+    if len(unserialize_fields)>0:
+        # certain variable size fields need to be unserialized explicitly
+        _c('    %s *reply = (%s *) xcb_wait_for_reply(c, cookie.sequence, e);',
+           self.c_reply_type, self.c_reply_type)
+        _c('    int i;')
+        for field in unserialize_fields:
+            if field.type.is_list:
+                _c('    %s %s_iter = %s(reply);', field.c_iterator_type, field.c_field_name, field.c_iterator_name)
+                _c('    int %s_len = %s(reply);', field.c_field_name, field.c_length_name)
+                _c('    %s *%s_data;', field.c_field_type, field.c_field_name)
+            else:
+                raise Exception('not implemented: call _unserialize() in reply for non-list type %s', field.c_field_type)
+        # call _unserialize(), using the reply as source and target buffer
+        _c('    /* special cases: transform parts of the reply to match XCB data structures */')
+        for field in unserialize_fields:
+            if field.type.is_list:
+                _c('    for(i=0; i<%s_len; i++) {', field.c_field_name)
+                _c('        %s_data = %s_iter.data;', field.c_field_name, field.c_field_name)
+                _c('        %s((const void *)%s_data, &%s_data);', field.type.c_unserialize_name,
+                   field.c_field_name, field.c_field_name)
+                _c('        %s(&%s_iter);', field.type.c_next_name, field.c_field_name)
+                _c('    }')
+        # return the transformed reply
+        _c('    return reply;')
+
+    else:
+        _c('    return (%s *) xcb_wait_for_reply(c, cookie.sequence, e);', self.c_reply_type)
+
+    _c('}')
+
+def _c_reply_has_fds(self):
+    for field in self.fields:
+        if field.isfd:
+            return True
+    return False
+
+def _c_reply_fds(self, name):
+    '''
+    Declares the function that returns fds related to the reply.
+    '''
+    spacing1 = ' ' * (len(self.c_reply_type) - len('xcb_connection_t'))
+    spacing3 = ' ' * (len(self.c_reply_fds_name) + 2)
+    _h('')
+    _h('/**')
+    _h(' * Return the reply fds')
+    _h(' * @param c      The connection')
+    _h(' * @param reply  The reply')
+    _h(' *')
+    _h(' * Returns the array of reply fds of the request asked by')
+    _h(' * ')
+    _h(' * The returned value must be freed by the caller using free().')
+    _h(' */')
+    _c('')
+    _hc('')
+    _hc('/*****************************************************************************')
+    _hc(' **')
+    _hc(' ** int * %s', self.c_reply_fds_name)
+    _hc(' ** ')
+    _hc(' ** @param xcb_connection_t%s  *c', spacing1)
+    _hc(' ** @param %s  *reply', self.c_reply_type)
+    _hc(' ** @returns int *')
+    _hc(' **')
+    _hc(' *****************************************************************************/')
+    _hc(' ')
+    _hc('int *')
+    _hc('%s (xcb_connection_t%s  *c  /**< */,', self.c_reply_fds_name, spacing1)
+    _h('%s%s  *reply  /**< */);', spacing3, self.c_reply_type)
+    _c('%s%s  *reply  /**< */)', spacing3, self.c_reply_type)
+    _c('{')
+
+    _c('    return xcb_get_reply_fds(c, reply, sizeof(%s) + 4 * reply->length);', self.c_reply_type)
+
+    _c('}')
+
+
+def _c_opcode(name, opcode):
+    '''
+    Declares the opcode define for requests, events, and errors.
+    '''
+    _h_setlevel(0)
+    _h('')
+    _h('/** Opcode for %s. */', _n(name))
+    _h('#define %s %s', _n(name).upper(), opcode)
+
+def _c_cookie(self, name):
+    '''
+    Declares the cookie type for a non-void request.
+    '''
+    _h_setlevel(0)
+    _h('')
+    _h('/**')
+    _h(' * @brief %s', self.c_cookie_type)
+    _h(' **/')
+    _h('typedef struct %s {', self.c_cookie_type)
+    _h('    unsigned int sequence; /**<  */')
+    _h('} %s;', self.c_cookie_type)
+
+def _man_request(self, name, cookie_type, void, aux):
+    param_fields = [f for f in self.fields if f.visible]
+
+    func_name = self.c_request_name if not aux else self.c_aux_name
+
+    def create_link(linkname):
+        name = 'man/%s.3' % linkname
+        if manpaths:
+            sys.stdout.write(name)
+        f = open(name, 'w')
+        f.write('.so man3/%s.3' % func_name)
+        f.close()
+
+    if manpaths:
+        sys.stdout.write('man/%s.3 ' % func_name)
+    # Our CWD is src/, so this will end up in src/man/
+    f = open('man/%s.3' % func_name, 'w')
+    f.write('.TH %s 3  %s "XCB" "XCB Requests"\n' % (func_name, today))
+    # Left-adjust instead of adjusting to both sides
+    f.write('.ad l\n')
+    f.write('.SH NAME\n')
+    brief = self.doc.brief if hasattr(self, "doc") and self.doc else ''
+    f.write('%s \\- %s\n' % (func_name, brief))
+    f.write('.SH SYNOPSIS\n')
+    # Don't split words (hyphenate)
+    f.write('.hy 0\n')
+    f.write('.B #include <xcb/%s.h>\n' % _ns.header)
+
+    # function prototypes
+    prototype = ''
+    count = len(param_fields)
+    for field in param_fields:
+        count = count - 1
+        c_field_const_type = field.c_field_const_type
+        c_pointer = field.c_pointer
+        if c_pointer == ' ':
+            c_pointer = ''
+        if field.type.need_serialize and not aux:
+            c_field_const_type = "const void"
+            c_pointer = '*'
+        comma = ', ' if count else ');'
+        prototype += '%s\\ %s\\fI%s\\fP%s' % (c_field_const_type, c_pointer, field.c_field_name, comma)
+
+    f.write('.SS Request function\n')
+    f.write('.HP\n')
+    base_func_name = self.c_request_name if not aux else self.c_aux_name
+    f.write('%s \\fB%s\\fP(xcb_connection_t\\ *\\fIconn\\fP, %s\n' % (cookie_type, base_func_name, prototype))
+    create_link('%s_%s' % (base_func_name, ('checked' if void else 'unchecked')))
+    if not void:
+        f.write('.PP\n')
+        f.write('.SS Reply datastructure\n')
+        f.write('.nf\n')
+        f.write('.sp\n')
+        f.write('typedef %s %s {\n' % (self.reply.c_container, self.reply.c_type))
+        struct_fields = []
+        maxtypelen = 0
+
+        for field in self.reply.fields:
+            if not field.type.fixed_size() and not self.is_switch and not self.is_union:
+                continue
+            if field.wire:
+                struct_fields.append(field)
+
+        for field in struct_fields:
+            length = len(field.c_field_type)
+            # account for '*' pointer_spec
+            if not field.type.fixed_size():
+                length += 1
+            maxtypelen = max(maxtypelen, length)
+
+        def _c_complex_field(self, field, space=''):
+            if (field.type.fixed_size() or
+                # in case of switch with switch children, don't make the field a pointer
+                # necessary for unserialize to work
+                (self.is_switch and field.type.is_switch)):
+                spacing = ' ' * (maxtypelen - len(field.c_field_type))
+                f.write('%s    %s%s \\fI%s\\fP%s;\n' % (space, field.c_field_type, spacing, field.c_field_name, field.c_subscript))
+            else:
+                spacing = ' ' * (maxtypelen - (len(field.c_field_type) + 1))
+                f.write('ELSE %s = %s\n' % (field.c_field_type, field.c_field_name))
+                #_h('%s    %s%s *%s%s; /**<  */', space, field.c_field_type, spacing, field.c_field_name, field.c_subscript)
+
+        if not self.is_switch:
+            for field in struct_fields:
+                _c_complex_field(self, field)
+        else:
+            for b in self.bitcases:
+                space = ''
+                if b.type.has_name:
+                    space = '    '
+                for field in b.type.fields:
+                    _c_complex_field(self, field, space)
+                if b.type.has_name:
+                    print >> sys.stderr, 'ERROR: New unhandled documentation case'
+                    pass
+
+        f.write('} \\fB%s\\fP;\n' % self.reply.c_type)
+        f.write('.fi\n')
+
+        f.write('.SS Reply function\n')
+        f.write('.HP\n')
+        f.write(('%s *\\fB%s\\fP(xcb_connection_t\\ *\\fIconn\\fP, %s\\ '
+                 '\\fIcookie\\fP, xcb_generic_error_t\\ **\\fIe\\fP);\n') %
+                (self.c_reply_type, self.c_reply_name, self.c_cookie_type))
+        create_link('%s' % self.c_reply_name)
+
+        has_accessors = False
+        for field in self.reply.fields:
+            if field.type.is_list and not field.type.fixed_size():
+                has_accessors = True
+            elif field.prev_varsized_field is not None or not field.type.fixed_size():
+                has_accessors = True
+
+        if has_accessors:
+            f.write('.SS Reply accessors\n')
+
+        def _c_accessors_field(self, field):
+            '''
+            Declares the accessor functions for a non-list field that follows a variable-length field.
+            '''
+            c_type = self.c_type
+
+            # special case: switch
+            switch_obj = self if self.is_switch else None
+            if self.is_bitcase:
+                switch_obj = self.parents[-1]
+            if switch_obj is not None:
+                c_type = switch_obj.c_type
+
+            if field.type.is_simple:
+                f.write('%s %s (const %s *reply)\n' % (field.c_field_type, field.c_accessor_name, c_type))
+                create_link('%s' % field.c_accessor_name)
+            else:
+                f.write('%s *%s (const %s *reply)\n' % (field.c_field_type, field.c_accessor_name, c_type))
+                create_link('%s' % field.c_accessor_name)
+
+        def _c_accessors_list(self, field):
+            '''
+            Declares the accessor functions for a list field.
+            Declares a direct-accessor function only if the list members are fixed size.
+            Declares length and get-iterator functions always.
+            '''
+            list = field.type
+            c_type = self.reply.c_type
+
+            # special case: switch
+            # in case of switch, 2 params have to be supplied to certain accessor functions:
+            #   1. the anchestor object (request or reply)
+            #   2. the (anchestor) switch object
+            # the reason is that switch is either a child of a request/reply or nested in another switch,
+            # so whenever we need to access a length field, we might need to refer to some anchestor type
+            switch_obj = self if self.is_switch else None
+            if self.is_bitcase:
+                switch_obj = self.parents[-1]
+            if switch_obj is not None:
+                c_type = switch_obj.c_type
+
+            params = []
+            fields = {}
+            parents = self.parents if hasattr(self, 'parents') else [self]
+            # 'R': parents[0] is always the 'toplevel' container type
+            params.append(('const %s *\\fIreply\\fP' % parents[0].c_type, parents[0]))
+            fields.update(_c_helper_field_mapping(parents[0], [('R', '->', parents[0])], flat=True))
+            # auxiliary object for 'R' parameters
+            R_obj = parents[0]
+
+            if switch_obj is not None:
+                # now look where the fields are defined that are needed to evaluate
+                # the switch expr, and store the parent objects in accessor_params and
+                # the fields in switch_fields
+
+                # 'S': name for the 'toplevel' switch
+                toplevel_switch = parents[1]
+                params.append(('const %s *S' % toplevel_switch.c_type, toplevel_switch))
+                fields.update(_c_helper_field_mapping(toplevel_switch, [('S', '->', toplevel_switch)], flat=True))
+
+                # initialize prefix for everything "below" S
+                prefix_str = '/* %s */ S' % toplevel_switch.name[-1]
+                prefix = [(prefix_str, '->', toplevel_switch)]
+
+                # look for fields in the remaining containers
+                for p in parents[2:] + [self]:
+                    # the separator between parent and child is always '.' here,
+                    # because of nested switch statements
+                    if not p.is_bitcase or (p.is_bitcase and p.has_name):
+                        prefix.append((p.name[-1], '.', p))
+                    fields.update(_c_helper_field_mapping(p, prefix, flat=True))
+
+                # auxiliary object for 'S' parameter
+                S_obj = parents[1]
+
+            if list.member.fixed_size():
+                idx = 1 if switch_obj is not None else 0
+                f.write('.HP\n')
+                f.write('%s *\\fB%s\\fP(%s);\n' %
+                        (field.c_field_type, field.c_accessor_name, params[idx][0]))
+                create_link('%s' % field.c_accessor_name)
+
+            f.write('.HP\n')
+            f.write('int \\fB%s\\fP(const %s *\\fIreply\\fP);\n' %
+                    (field.c_length_name, c_type))
+            create_link('%s' % field.c_length_name)
+
+            if field.type.member.is_simple:
+                f.write('.HP\n')
+                f.write('xcb_generic_iterator_t \\fB%s\\fP(const %s *\\fIreply\\fP);\n' %
+                        (field.c_end_name, c_type))
+                create_link('%s' % field.c_end_name)
+            else:
+                f.write('.HP\n')
+                f.write('%s \\fB%s\\fP(const %s *\\fIreply\\fP);\n' %
+                        (field.c_iterator_type, field.c_iterator_name,
+                         c_type))
+                create_link('%s' % field.c_iterator_name)
+
+        for field in self.reply.fields:
+            if field.type.is_list and not field.type.fixed_size():
+                _c_accessors_list(self, field)
+            elif field.prev_varsized_field is not None or not field.type.fixed_size():
+                _c_accessors_field(self, field)
+
+
+    f.write('.br\n')
+    # Re-enable hyphenation and adjusting to both sides
+    f.write('.hy 1\n')
+
+    # argument reference
+    f.write('.SH REQUEST ARGUMENTS\n')
+    f.write('.IP \\fI%s\\fP 1i\n' % 'conn')
+    f.write('The XCB connection to X11.\n')
+    for field in param_fields:
+        f.write('.IP \\fI%s\\fP 1i\n' % (field.c_field_name))
+        printed_enum = False
+        # XXX: hard-coded until we fix xproto.xml
+        if base_func_name == 'xcb_change_gc' and field.c_field_name == 'value_mask':
+            field.enum = 'GC'
+        elif base_func_name == 'xcb_change_window_attributes' and field.c_field_name == 'value_mask':
+            field.enum = 'CW'
+        elif base_func_name == 'xcb_create_window' and field.c_field_name == 'value_mask':
+            field.enum = 'CW'
+        if hasattr(field, "enum") and field.enum:
+            # XXX: why the 'xcb' prefix?
+            key = ('xcb', field.enum)
+            if key in enums:
+                f.write('One of the following values:\n')
+                f.write('.RS 1i\n')
+                enum = enums[key]
+                count = len(enum.values)
+                for (enam, eval) in enum.values:
+                    count = count - 1
+                    f.write('.IP \\fI%s\\fP 1i\n' % (_n(key + (enam,)).upper()))
+                    if hasattr(enum, "doc") and enum.doc and enam in enum.doc.fields:
+                        desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', enum.doc.fields[enam])
+                        f.write('%s\n' % desc)
+                    else:
+                        f.write('TODO: NOT YET DOCUMENTED.\n')
+                f.write('.RE\n')
+                f.write('.RS 1i\n')
+                printed_enum = True
+
+        if hasattr(self, "doc") and self.doc and field.field_name in self.doc.fields:
+            desc = self.doc.fields[field.field_name]
+            desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', desc)
+            if printed_enum:
+                f.write('\n')
+            f.write('%s\n' % desc)
+        else:
+            f.write('TODO: NOT YET DOCUMENTED.\n')
+        if printed_enum:
+            f.write('.RE\n')
+
+    # Reply reference
+    if not void:
+        f.write('.SH REPLY FIELDS\n')
+        # These fields are present in every reply:
+        f.write('.IP \\fI%s\\fP 1i\n' % 'response_type')
+        f.write(('The type of this reply, in this case \\fI%s\\fP. This field '
+                 'is also present in the \\fIxcb_generic_reply_t\\fP and can '
+                 'be used to tell replies apart from each other.\n') %
+                 _n(self.reply.name).upper())
+        f.write('.IP \\fI%s\\fP 1i\n' % 'sequence')
+        f.write('The sequence number of the last request processed by the X11 server.\n')
+        f.write('.IP \\fI%s\\fP 1i\n' % 'length')
+        f.write('The length of the reply, in words (a word is 4 bytes).\n')
+        for field in self.reply.fields:
+            if (field.c_field_name in frozenset(['response_type', 'sequence', 'length']) or
+                field.c_field_name.startswith('pad')):
+                continue
+
+            if field.type.is_list and not field.type.fixed_size():
+                continue
+            elif field.prev_varsized_field is not None or not field.type.fixed_size():
+                continue
+            f.write('.IP \\fI%s\\fP 1i\n' % (field.c_field_name))
+            printed_enum = False
+            if hasattr(field, "enum") and field.enum:
+                # XXX: why the 'xcb' prefix?
+                key = ('xcb', field.enum)
+                if key in enums:
+                    f.write('One of the following values:\n')
+                    f.write('.RS 1i\n')
+                    enum = enums[key]
+                    count = len(enum.values)
+                    for (enam, eval) in enum.values:
+                        count = count - 1
+                        f.write('.IP \\fI%s\\fP 1i\n' % (_n(key + (enam,)).upper()))
+                        if enum.doc and enam in enum.doc.fields:
+                            desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', enum.doc.fields[enam])
+                            f.write('%s\n' % desc)
+                        else:
+                            f.write('TODO: NOT YET DOCUMENTED.\n')
+                    f.write('.RE\n')
+                    f.write('.RS 1i\n')
+                    printed_enum = True
+
+            if hasattr(self.reply, "doc") and self.reply.doc and field.field_name in self.reply.doc.fields:
+                desc = self.reply.doc.fields[field.field_name]
+                desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', desc)
+                if printed_enum:
+                    f.write('\n')
+                f.write('%s\n' % desc)
+            else:
+                f.write('TODO: NOT YET DOCUMENTED.\n')
+            if printed_enum:
+                f.write('.RE\n')
+
+
+
+    # text description
+    f.write('.SH DESCRIPTION\n')
+    if hasattr(self, "doc") and self.doc and self.doc.description:
+        desc = self.doc.description
+        desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', desc)
+        lines = desc.split('\n')
+        f.write('\n'.join(lines) + '\n')
+
+    f.write('.SH RETURN VALUE\n')
+    if void:
+        f.write(('Returns an \\fIxcb_void_cookie_t\\fP. Errors (if any) '
+                 'have to be handled in the event loop.\n\nIf you want to '
+                 'handle errors directly with \\fIxcb_request_check\\fP '
+                 'instead, use \\fI%s_checked\\fP. See '
+                 '\\fBxcb-requests(3)\\fP for details.\n') % (base_func_name))
+    else:
+        f.write(('Returns an \\fI%s\\fP. Errors have to be handled when '
+                 'calling the reply function \\fI%s\\fP.\n\nIf you want to '
+                 'handle errors in the event loop instead, use '
+                 '\\fI%s_unchecked\\fP. See \\fBxcb-requests(3)\\fP for '
+                 'details.\n') %
+                (cookie_type, self.c_reply_name, base_func_name))
+    f.write('.SH ERRORS\n')
+    if hasattr(self, "doc") and self.doc:
+        for errtype, errtext in self.doc.errors.items():
+            f.write('.IP \\fI%s\\fP 1i\n' % (_t(('xcb', errtype, 'error'))))
+            errtext = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', errtext)
+            f.write('%s\n' % (errtext))
+    if not hasattr(self, "doc") or not self.doc or len(self.doc.errors) == 0:
+        f.write('This request does never generate any errors.\n')
+    if hasattr(self, "doc") and self.doc and self.doc.example:
+        f.write('.SH EXAMPLE\n')
+        f.write('.nf\n')
+        f.write('.sp\n')
+        lines = self.doc.example.split('\n')
+        f.write('\n'.join(lines) + '\n')
+        f.write('.fi\n')
+    f.write('.SH SEE ALSO\n')
+    if hasattr(self, "doc") and self.doc:
+        see = ['.BR %s (3)' % 'xcb-requests']
+        if self.doc.example:
+            see.append('.BR %s (3)' % 'xcb-examples')
+        for seename, seetype in self.doc.see.items():
+            if seetype == 'program':
+                see.append('.BR %s (1)' % seename)
+            elif seetype == 'event':
+                see.append('.BR %s (3)' % _t(('xcb', seename, 'event')))
+            elif seetype == 'request':
+                see.append('.BR %s (3)' % _n(('xcb', seename)))
+            elif seetype == 'function':
+                see.append('.BR %s (3)' % seename)
+            else:
+                see.append('TODO: %s (type %s)' % (seename, seetype))
+        f.write(',\n'.join(see) + '\n')
+    f.write('.SH AUTHOR\n')
+    f.write('Generated from %s.xml. Contact xcb@lists.freedesktop.org for corrections and improvements.\n' % _ns.header)
+    f.close()
+
+def _man_event(self, name):
+    if manpaths:
+        sys.stdout.write('man/%s.3 ' % self.c_type)
+    # Our CWD is src/, so this will end up in src/man/
+    f = open('man/%s.3' % self.c_type, 'w')
+    f.write('.TH %s 3  %s "XCB" "XCB Events"\n' % (self.c_type, today))
+    # Left-adjust instead of adjusting to both sides
+    f.write('.ad l\n')
+    f.write('.SH NAME\n')
+    brief = self.doc.brief if hasattr(self, "doc") and self.doc else ''
+    f.write('%s \\- %s\n' % (self.c_type, brief))
+    f.write('.SH SYNOPSIS\n')
+    # Don't split words (hyphenate)
+    f.write('.hy 0\n')
+    f.write('.B #include <xcb/%s.h>\n' % _ns.header)
+
+    f.write('.PP\n')
+    f.write('.SS Event datastructure\n')
+    f.write('.nf\n')
+    f.write('.sp\n')
+    f.write('typedef %s %s {\n' % (self.c_container, self.c_type))
+    struct_fields = []
+    maxtypelen = 0
+
+    for field in self.fields:
+        if not field.type.fixed_size() and not self.is_switch and not self.is_union:
+            continue
+        if field.wire:
+            struct_fields.append(field)
+
+    for field in struct_fields:
+        length = len(field.c_field_type)
+        # account for '*' pointer_spec
+        if not field.type.fixed_size():
+            length += 1
+        maxtypelen = max(maxtypelen, length)
+
+    def _c_complex_field(self, field, space=''):
+        if (field.type.fixed_size() or
+            # in case of switch with switch children, don't make the field a pointer
+            # necessary for unserialize to work
+            (self.is_switch and field.type.is_switch)):
+            spacing = ' ' * (maxtypelen - len(field.c_field_type))
+            f.write('%s    %s%s \\fI%s\\fP%s;\n' % (space, field.c_field_type, spacing, field.c_field_name, field.c_subscript))
+        else:
+            print >> sys.stderr, 'ERROR: New unhandled documentation case'
+
+    if not self.is_switch:
+        for field in struct_fields:
+            _c_complex_field(self, field)
+    else:
+        for b in self.bitcases:
+            space = ''
+            if b.type.has_name:
+                space = '    '
+            for field in b.type.fields:
+                _c_complex_field(self, field, space)
+            if b.type.has_name:
+                print >> sys.stderr, 'ERROR: New unhandled documentation case'
+                pass
+
+    f.write('} \\fB%s\\fP;\n' % self.c_type)
+    f.write('.fi\n')
+
+
+    f.write('.br\n')
+    # Re-enable hyphenation and adjusting to both sides
+    f.write('.hy 1\n')
+
+    # argument reference
+    f.write('.SH EVENT FIELDS\n')
+    f.write('.IP \\fI%s\\fP 1i\n' % 'response_type')
+    f.write(('The type of this event, in this case \\fI%s\\fP. This field is '
+             'also present in the \\fIxcb_generic_event_t\\fP and can be used '
+             'to tell events apart from each other.\n') % _n(name).upper())
+    f.write('.IP \\fI%s\\fP 1i\n' % 'sequence')
+    f.write('The sequence number of the last request processed by the X11 server.\n')
+
+    if not self.is_switch:
+        for field in struct_fields:
+            # Skip the fields which every event has, we already documented
+            # them (see above).
+            if field.c_field_name in ('response_type', 'sequence'):
+                continue
+            if isinstance(field.type, PadType):
+                continue
+            f.write('.IP \\fI%s\\fP 1i\n' % (field.c_field_name))
+            if hasattr(self, "doc") and self.doc and field.field_name in self.doc.fields:
+                desc = self.doc.fields[field.field_name]
+                desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', desc)
+                f.write('%s\n' % desc)
+            else:
+                f.write('NOT YET DOCUMENTED.\n')
+
+    # text description
+    f.write('.SH DESCRIPTION\n')
+    if hasattr(self, "doc") and self.doc and self.doc.description:
+        desc = self.doc.description
+        desc = re.sub(r'`([^`]+)`', r'\\fI\1\\fP', desc)
+        lines = desc.split('\n')
+        f.write('\n'.join(lines) + '\n')
+
+    if hasattr(self, "doc") and self.doc and self.doc.example:
+        f.write('.SH EXAMPLE\n')
+        f.write('.nf\n')
+        f.write('.sp\n')
+        lines = self.doc.example.split('\n')
+        f.write('\n'.join(lines) + '\n')
+        f.write('.fi\n')
+    f.write('.SH SEE ALSO\n')
+    if hasattr(self, "doc") and self.doc:
+        see = ['.BR %s (3)' % 'xcb_generic_event_t']
+        if self.doc.example:
+            see.append('.BR %s (3)' % 'xcb-examples')
+        for seename, seetype in self.doc.see.items():
+            if seetype == 'program':
+                see.append('.BR %s (1)' % seename)
+            elif seetype == 'event':
+                see.append('.BR %s (3)' % _t(('xcb', seename, 'event')))
+            elif seetype == 'request':
+                see.append('.BR %s (3)' % _n(('xcb', seename)))
+            elif seetype == 'function':
+                see.append('.BR %s (3)' % seename)
+            else:
+                see.append('TODO: %s (type %s)' % (seename, seetype))
+        f.write(',\n'.join(see) + '\n')
+    f.write('.SH AUTHOR\n')
+    f.write('Generated from %s.xml. Contact xcb@lists.freedesktop.org for corrections and improvements.\n' % _ns.header)
+    f.close()
+
+
+def c_request(self, name):
+    '''
+    Exported function that handles request declarations.
+    '''
+
+    _c_type_setup(self, name, ('request',))
+
+    # Request structure declaration
+    # _c_complex(self)
+
+    request_name = _ext(_n_item(self.name[-1]))
+    c_func_name = _n(self.name)
+
+    if self.reply:
+
+        _c_type_setup(self.reply, name, ('reply',))
+        # Reply structure definition
+        # _c_complex(self.reply)
+
+        # Request prototypes
+        _cpp_request_helper(self, name, False)
+
+        # Reply accessors
+        _c_accessors(self.reply, name + ('reply',), name)
+
+    else:
+        # Request prototypes
+        _cpp_request_helper(self, name, True)
+
+    # We generate the manpage afterwards because _c_type_setup has been called.
+    # TODO: what about aux helpers?
+    # cookie_type = self.c_cookie_type if self.reply else 'xcb_void_cookie_t'
+    # _man_request(self, name, cookie_type, not self.reply, False)
+
+def c_event(self, name):
+    '''
+    Exported function that handles event declarations.
+    '''
+
+    # The generic event structure xcb_ge_event_t has the full_sequence field
+    # at the 32byte boundary. That's why we've to inject this field into GE
+    # events while generating the structure for them. Otherwise we would read
+    # garbage (the internal full_sequence) when accessing normal event fields
+    # there.
+    if hasattr(self, 'is_ge_event') and self.is_ge_event and self.name == name:
+        event_size = 0
+        for field in self.fields:
+            if field.type.size != None and field.type.nmemb != None:
+                event_size += field.type.size * field.type.nmemb
+            if event_size == 32:
+                full_sequence = Field(tcard32, tcard32.name, 'full_sequence', False, True, True)
+                idx = self.fields.index(field)
+                self.fields.insert(idx + 1, full_sequence)
+                break
+
+    _c_type_setup(self, name, ('event',))
+
+    # Opcode define
+    # _c_opcode(name, self.opcodes[name])
+
+    _h('typedef %s %s;', _t(self.name + ('event',)), _t(name + ('event',)))
+    if self.name == name:
+        pass
+        # Structure definition
+        # _c_complex(self)
+    else:
+        pass
+        # Typedef
+        # _h('')
+        # _h('typedef %s %s;', _t(self.name + ('event',)), _t(name + ('event',)))
+
+    # _man_event(self, name)
+
+def cpp_event(self, name):
+    '''
+    Exported function that handles event declarations.
+    '''
+
+    _c_type_setup(self, name, ('event',))
+
+    opcode = _n(name).upper()
+    c_name = _t(self.name + ('event',))
+
+    cpp_event = CppEvent(self.opcodes[name], opcode, c_name, _ns, name, self.fields)
+    _cpp_events.append(cpp_event)
+    _interface_class.add_event(cpp_event)
+
+def c_error(self, name):
+    '''
+    Exported function that handles error declarations.
+    '''
+    _c_type_setup(self, name, ('error',))
+
+    # Opcode define
+    _c_opcode(name, self.opcodes[name])
+
+    if self.name == name:
+        # Structure definition
+        _c_complex(self)
+    else:
+        # Typedef
+        _h('')
+        _h('typedef %s %s;', _t(self.name + ('error',)), _t(name + ('error',)))
+
+def cpp_error(self, name):
+    '''
+    Exported function that handles error declarations.
+    '''
+    _c_type_setup(self, name, ('error',))
+
+    # Opcode define
+    # _c_opcode(name, self.opcodes[name])
+
+    # sys.stderr.write("error declaration: %s\n" % str(self))
+    # sys.stderr.write("opcode: %s\n" % self.opcodes[name])
+    # sys.stderr.write('typedef %s %s;\n\n' % ( _t(self.name + ('error',)), _t(name + ('error',))))
+
+    opcode_name = _n(name).upper()
+    c_name = _t(self.name + ('error',))
+    cpp_error = CppError(self, _ns, name, c_name, self.opcodes[name], opcode_name)
+    _cpp_errors.append(cpp_error)
+    _interface_class.add_error(cpp_error)
+
+    # if self.name == name:
+    #     # Structure definition
+    #     _c_complex(self)
+    # else:
+    #     # Typedef
+    #     _h('')
+    #     _h('typedef %s %s;', _t(self.name + ('error',)), _t(name + ('error',)))
+
+def cpp_prototypes():
+    _h("namespace request {")
+    for request in _request_classes:
+        _h("  class %s;", request)
+    _h("} // namespace request")
+    _h("")
+
+    def ctor(name, type):
+        return """\
+    %s(const xcb_%s_t & %s)
+      : m_%s(%s)
+    {}\
+""" % (name, type, name, name, name)
+
+    for key in _type_objects[get_namespace(_ns)].keys():
+        name = _ext(_n_item(key))
+        type = ("" if get_namespace(_ns) == "xproto" else get_namespace(_ns) + "_") + name
+
+        if len(_type_objects[get_namespace(_ns)][key]) > 0:
+            _h("class %s {", name)
+            _h("  public:")
+            _h(ctor(name, type))
+            _h("")
+            _h("    const xcb_%s_t & operator*(void)", type)
+            _h("    {")
+            _h("      return m_%s;", name)
+            _h("    }")
+            _h("")
+
+            for (proto, body) in _type_objects[get_namespace(_ns)][key]:
+                _h("%s", proto)
+                _h("")
+
+            _h("  private:")
+            _h("    connection m_c;")
+            _h("    xcb_%s_t m_%s;", type, name)
+            _h("}; // class %s", name)
+            _h("")
+
+def cpp_type_classes():
+    for key in _type_objects[get_namespace(_ns)].keys():
+        type = _ext(_n_item(key))
+        if len(_type_objects[get_namespace(_ns)][key]) > 0:
+            # _h("")
+            # _h("class %s {", type)
+            # _h("  public:")
+            # _h("    const xcb_%s_t & operator*(void)", type)
+            # _h("    {")
+            # _h("      return m_%s;", type)
+            # _h("    }")
+            # _h("")
+
+            for (proto, body) in _type_objects[get_namespace(_ns)][key]:
+                # _h("%s", proto)
+                _h("%s", body)
+                _h("")
+
+            # _h("  private:")
+            # _h("    connection m_c;")
+            # _h("    xcb_%s_t m_%s;", type, type)
+            # _h("}; // class %s", type)
+            # _h("")
+
+# Main routine starts here
+
+# # Must create an "output" dictionary before any xcbgen imports.
+# output = {'open'    : c_open,
+#           'close'   : c_close,
+#           'simple'  : c_simple,
+#           'enum'    : c_enum,
+#           'struct'  : c_struct,
+#           'union'   : c_union,
+#           'request' : c_request,
+#           'event'   : c_event,
+#           'error'   : c_error,
+#           }
+
+# Must create an "output" dictionary before any xcbgen imports.
+output = {'open'          : c_open,
+          'close'         : c_close,
+          'simple'        : c_simple, # lambda x, y: None,
+          'enum'          : lambda x, y: None,
+          'struct'        : lambda x, y: None,
+          'union'         : lambda x, y: None,
+          'request'       : c_request,
+          'event'         : cpp_event,
+          'error'         : cpp_error,
+	  'eventstruct'   : lambda x, y: None,
+          'eventstruct'   : lambda x, y: None,
+          }
+
+# Boilerplate below this point
+
+# Check for the argument that specifies path to the xcbgen python package.
+try:
+    opts, args = getopt.getopt(sys.argv[1:], 'p:m')
+except getopt.GetoptError as err:
+    print(err)
+    print('Usage: c_client.py [-p path] file.xml')
+    sys.exit(1)
+
+for (opt, arg) in opts:
+    if opt == '-p':
+        sys.path.insert(1, arg)
+    elif opt == '-m':
+        manpaths = True
+        sys.stdout.write('man_MANS = ')
+
+# Import the module class
+try:
+    from xcbgen.state import Module
+    from xcbgen.xtypes import *
+except ImportError:
+    print('''
+Failed to load the xcbgen Python package!
+Make sure that xcb/proto installed it on your Python path.
+If not, you will need to create a .pth file or define $PYTHONPATH
+to extend the path.
+Refer to the README file in xcb/proto for more info.
+''')
+    raise
+
+# Ensure the man subdirectory exists
+try:
+    os.mkdir('man')
+except OSError as e:
+    if e.errno != errno.EEXIST:
+        raise
+
+today = time.strftime('%Y-%m-%d', time.gmtime(os.path.getmtime(args[0])))
+
+# Parse the xml header
+module = Module(args[0], output)
+
+# Build type-registry and resolve type dependencies
+module.register()
+module.resolve()
+
+# Output the code
+module.generate()
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cppcookie.py polybar-3.2.1/lib/xpp/generators/cppcookie.py
--- polybar-3.2.1.orig/lib/xpp/generators/cppcookie.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cppcookie.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,202 @@
+from utils import _n, _ext, _n_item, get_namespace
+
+_templates = {}
+
+_templates['void_cookie_function'] = \
+'''\
+%s\
+void
+%s_checked(Connection && c%s)
+{%s\
+  xpp::generic::check<Connection, xpp::%s::error::dispatcher>(
+      std::forward<Connection>(c),
+      %s_checked(std::forward<Connection>(c)%s));
+}
+
+%s\
+void
+%s(Connection && c%s)
+{%s\
+  %s(std::forward<Connection>(c)%s);
+}
+'''
+
+def _void_cookie_function(ns, name, c_name, template, return_value, protos, calls, initializer):
+    if len(template) == 0: template = "template<typename Connection>\n"
+    return _templates['void_cookie_function'] % \
+            ( template
+            , name
+            , protos
+            , initializer
+            , ns
+            , c_name
+            , calls
+            , template
+            , name
+            , protos
+            , initializer
+            , c_name
+            , calls
+            )
+
+_templates['cookie_static_getter'] = \
+'''\
+%s\
+    static
+    %s
+    cookie(xcb_connection_t * const c%s)
+    {%s\
+      return base::cookie(c%s);
+    }
+'''
+
+def _cookie_static_getter(template, return_value, protos, calls, initializer):
+    return _templates['cookie_static_getter'] % \
+            ( template
+            , return_value
+            , protos
+            , initializer
+            , calls
+            )
+
+class CppCookie(object):
+    def __init__(self, namespace, is_void, name, reply, parameter_list):
+        self.namespace = namespace
+        self.is_void = is_void
+        self.name = name
+        self.reply = reply
+        self.parameter_list = parameter_list
+        self.request_name = _ext(_n_item(self.name[-1]))
+        self.c_name = "xcb" \
+            + (("_" + get_namespace(namespace)) if namespace.is_ext else "") \
+            + "_" + self.request_name
+
+    def comma(self):
+        return self.parameter_list.comma()
+
+    def calls(self, sort):
+        return self.parameter_list.calls(sort)
+
+    def protos(self, sort, defaults):
+        return self.parameter_list.protos(sort, defaults)
+
+    def iterator_template(self, indent="    ", tail="\n"):
+        prefix = "template<typename " + ("Connection, typename " if self.is_void else "")
+        return indent + prefix \
+                + ", typename ".join(self.parameter_list.iterator_templates \
+                                   + self.parameter_list.templates) \
+                + ">" + tail \
+                if len(self.parameter_list.iterator_templates) > 0 \
+                else ""
+
+    def iterator_calls(self, sort):
+        return self.parameter_list.iterator_calls(sort)
+
+    def iterator_protos(self, sort, defaults):
+        return self.parameter_list.iterator_protos(sort, defaults)
+
+    def iterator_initializers(self):
+        return self.parameter_list.iterator_initializers()
+
+    def void_functions(self, protos, calls, template="", initializer=[]):
+        inits = "" if len(initializer) > 0 else "\n"
+        for i in initializer:
+            inits += "\n"
+            for line in i.split('\n'):
+                inits += "      " + line + "\n"
+
+        return_value = "xcb_void_cookie_t"
+
+        return _void_cookie_function(get_namespace(self.namespace),
+                                     self.request_name,
+                                     self.c_name,
+                                     template,
+                                     return_value,
+                                     self.comma() + protos,
+                                     self.comma() + calls,
+                                     inits)
+
+
+    def static_reply_methods(self, protos, calls, template="", initializer=[]):
+        inits = "" if len(initializer) > 0 else "\n"
+        for i in initializer:
+            inits += "\n"
+            for line in i.split('\n'):
+                inits += "      " + line + "\n"
+
+        if self.is_void: return_value = "xcb_void_cookie_t"
+        else: return_value = self.c_name + "_cookie_t"
+
+        return _cookie_static_getter(template,
+                                     return_value,
+                                     self.comma() + protos,
+                                     self.comma() + calls,
+                                     inits)
+
+
+    def make_static_getter(self):
+        default = self.static_reply_methods(self.protos(False, False), self.calls(False))
+
+        if self.parameter_list.has_defaults:
+            default = self.static_reply_methods(self.protos(True, True), self.calls(False))
+
+        wrapped = ""
+        if self.parameter_list.want_wrap:
+            wrapped = \
+                self.static_reply_methods(self.iterator_protos(True, True),
+                        self.iterator_calls(False), self.iterator_template(),
+                        self.iterator_initializers())
+
+        default_args = ""
+        if self.parameter_list.is_reordered():
+            default_args = \
+                self.static_reply_methods(self.protos(True, True), self.calls(False))
+
+        result = ""
+
+        if (self.parameter_list.has_defaults
+            or self.parameter_list.is_reordered()
+            or self.parameter_list.want_wrap):
+            result += default
+
+        if self.parameter_list.is_reordered():
+            result += "\n" + default_args
+
+        if self.parameter_list.want_wrap:
+            result += "\n" + wrapped
+
+        return result
+
+    def make_void_functions(self):
+        default = self.void_functions(self.protos(False, False), self.calls(False))
+
+        if self.parameter_list.has_defaults:
+            default = self.void_functions(self.protos(True, True), self.calls(False))
+
+        wrapped = ""
+        if self.parameter_list.want_wrap:
+            wrapped = \
+                self.void_functions(self.iterator_protos(True, True),
+                        self.iterator_calls(False),
+                        self.iterator_template(indent=""),
+                        self.iterator_initializers())
+
+        default_args = ""
+        if self.parameter_list.is_reordered():
+            default_args = \
+                self.void_functions(self.protos(True, True), self.calls(False))
+
+        result = ""
+
+        if (self.parameter_list.has_defaults
+            or self.parameter_list.is_reordered()
+            or self.parameter_list.want_wrap):
+            result += default
+
+        if self.parameter_list.is_reordered():
+            result += "\n" + default_args
+
+        if self.parameter_list.want_wrap:
+            result += "\n" + wrapped
+
+        return result
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cpperror.py polybar-3.2.1/lib/xpp/generators/cpperror.py
--- polybar-3.2.1.orig/lib/xpp/generators/cpperror.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cpperror.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,221 @@
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext, \
+        _reserved_keywords
+
+_templates = {}
+
+_templates['error_dispatcher_class'] = \
+'''\
+namespace error {
+
+class dispatcher
+{
+  public:
+%s\
+%s\
+
+    void
+    operator()(const std::shared_ptr<xcb_generic_error_t> &%s) const
+    {
+%s\
+    }
+
+%s\
+}; // class dispatcher
+
+} // namespace error
+'''
+
+def _error_dispatcher_class(typedef, ctors, switch, members, has_errors):
+    return _templates['error_dispatcher_class'] % \
+        ( typedef
+        , ctors
+        , " error" if has_errors else ""
+        , switch if has_errors else ""
+        , members
+        )
+
+
+def error_dispatcher_class(namespace, cpperrors):
+    ns = get_namespace(namespace)
+
+    ctor_name = "dispatcher"
+
+    typedef = []
+    ctors = []
+    members = []
+    opcode_switch = "error->error_code"
+
+    typedef = [ "typedef xpp::%s::extension extension;\n" % ns ]
+
+    # >>> if begin <<<
+    if namespace.is_ext:
+        opcode_switch = "error->error_code - m_first_error"
+
+        members += \
+            [ "protected:"
+            , "  uint8_t m_first_error;"
+            ]
+
+        ctors = \
+            [ "%s(uint8_t first_error)" % (ctor_name)
+            , "  : m_first_error(first_error)"
+            , "{}"
+            , ""
+            , "%s(const xpp::%s::extension & extension)" % (ctor_name, ns)
+            , "  : %s(extension->first_error)" % ctor_name
+            , "{}"
+            ]
+
+    # >>> if end <<<
+
+    if len(typedef) > 0:
+        typedef = "\n".join(map(lambda s: "    " + s, typedef)) + "\n"
+    else:
+        typedef = ""
+
+    if len(ctors) > 0:
+        ctors = "\n".join(map(lambda s: ("    " if len(s) > 0 else "") + s, ctors)) + "\n"
+    else:
+        ctors = ""
+
+    if len(members) > 0:
+        members = "\n".join(map(lambda s: "  " + s, members)) + "\n"
+    else:
+        members = ""
+
+    switch = error_switch_cases(cpperrors, opcode_switch, "error")
+    return _error_dispatcher_class(typedef,
+                                   ctors,
+                                   switch,
+                                   members,
+                                   len(cpperrors) > 0)
+
+def error_switch_cases(cpperrors, arg_switch, arg_error):
+    cases = ""
+    errors = cpperrors
+    templ = [ "        case %s: // %s"
+            , "          throw %s" + "(%s);" % arg_error
+            , ""
+            , ""
+            ]
+
+    cases += "      switch (%s) {\n\n" % arg_switch
+    for e in errors:
+        cases += "\n".join(templ) % (e.opcode_name, e.opcode, e.scoped_name())
+    cases += "      };\n"
+
+    return cases
+
+
+class CppError(object):
+    def __init__(self, error, namespace, name, c_name, opcode, opcode_name):
+        self.error = error
+        self.namespace = namespace
+        self.c_name = c_name
+        self.opcode = opcode
+        self.opcode_name = opcode_name
+
+        self.names = map(str.lower, _n_item(name[-1], True))
+        self.name = "_".join(map(str.lower, self.names))
+
+        self.nssopen = ""
+        self.nssclose = ""
+        self.scope = []
+        for name in self.names[0:-1]:
+            if name in _reserved_keywords: name += "_"
+            self.nssopen += " namespace %s {" % name
+            self.nssclose += " }"
+            self.scope.append(name)
+
+    def get_name(self):
+        return _reserved_keywords.get(self.name, self.name)
+
+
+    def scoped_name(self):
+        ns = get_namespace(self.namespace)
+        return "xpp::" + ns + "::error::" + self.get_name()
+
+    def make_class(self):
+        ns = get_namespace(self.namespace)
+        typedef = []
+        members = []
+
+        opcode_accessor = \
+            [ "static uint8_t opcode(void)"
+            , "{"
+            , "  return %s;" % self.opcode_name
+            , "}"
+            ]
+
+        if self.namespace.is_ext:
+            opcode_accessor += \
+                [ ""
+                , "static uint8_t opcode(uint8_t first_error)"
+                , "{"
+                , "  return first_error + opcode();"
+                , "}"
+                , ""
+                , "static uint8_t opcode(const xpp::%s::extension & extension)" % ns
+                , "{"
+                , "  return opcode(extension->first_error);"
+                , "}"
+                ]
+
+            members = \
+                [ "protected:"
+                , "  uint8_t m_first_error;"
+                ]
+
+        if len(opcode_accessor) > 0:
+            opcode_accessor = "\n".join(map(lambda s: "    " + s, opcode_accessor)) + "\n"
+        else:
+            opcode_accessor = ""
+
+        if len(members) > 0:
+            members = "\n" + "\n".join(map(lambda s: "  " + s, members)) + "\n"
+        else:
+            members = ""
+
+        if len(typedef) > 0:
+            typedef = "\n".join(map(lambda s: "    " + s, typedef)) + "\n\n"
+        else:
+            typedef = ""
+
+        name = self.name
+        if self.name in _reserved_keywords: name = self.name + "_"
+
+        return \
+'''
+namespace error {
+class %s
+  : public xpp::generic::error<%s,
+                               %s>
+{
+  public:
+%s\
+    using xpp::generic::error<%s, %s>::error;
+
+    virtual ~%s(void) {}
+
+%s
+    static std::string description(void)
+    {
+      return std::string("%s");
+    }
+%s\
+}; // class %s
+} // namespace error
+''' % (self.get_name(), # class %s
+       self.get_name(), # : public xpp::generic::error<%s,
+       self.c_name, # %s>
+       typedef,
+       self.get_name(), self.c_name, # using xpp::generic::error<%s, %s>::error;
+       self.get_name(), # virtual ~%s(void) {}
+       opcode_accessor,
+       self.opcode_name, # static constexpr const char * opcode_literal
+       members,
+       self.get_name()) # // class %s
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cppevent.py polybar-3.2.1/lib/xpp/generators/cppevent.py
--- polybar-3.2.1.orig/lib/xpp/generators/cppevent.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cppevent.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,380 @@
+import sys # stderr
+
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext, \
+        _reserved_keywords
+
+from resource_classes import _resource_classes
+
+_field_accessor_template_specialization = \
+'''\
+template<typename Connection>
+template<>
+%s
+%s<Connection>::%s<%s>(void) const
+{
+  return %s;
+}\
+'''
+
+_templates = {}
+
+_templates['field_accessor_template'] = \
+'''\
+    template<typename ReturnType = %s, typename ... Parameter>
+    ReturnType
+    %s(Parameter && ... parameter) const
+    {
+      using make = xpp::generic::factory::make<Connection,
+                                               decltype((*this)->%s),
+                                               ReturnType,
+                                               Parameter ...>;
+      return make()(this->m_c,
+                    (*this)->%s,
+                    std::forward<Parameter>(parameter) ...);
+    }\
+'''
+
+def _field_accessor_template(c_type, method_name, member):
+    return _templates['field_accessor_template'] % \
+        ( c_type
+        , method_name
+        , member
+        , member
+        )
+
+_templates['event_dispatcher_class'] = \
+'''\
+namespace event {
+
+template<typename Connection>
+class dispatcher
+{
+  public:
+%s\
+%s\
+
+    template<typename Handler>
+    bool
+    operator()(Handler%s,
+               const std::shared_ptr<xcb_generic_event_t> &%s) const
+    {\
+%s
+      return false;
+    }
+
+%s\
+}; // class dispatcher
+
+} // namespace event
+'''
+
+def _event_dispatcher_class(typedef, ctors, switch, members, has_events):
+    return _templates['event_dispatcher_class'] % \
+        ( typedef
+        , ctors
+        , " handler" if has_events else ""
+        , " event" if has_events else ""
+        , switch if has_events else ""
+        , members
+        )
+
+def event_dispatcher_class(namespace, cppevents):
+    ns = get_namespace(namespace)
+
+    ctor_name = "dispatcher"
+
+    typedef = []
+    ctors = []
+    members = []
+
+    opcode_switch = "event->response_type & ~0x80"
+    typedef = [ "typedef xpp::%s::extension extension;\n" % ns ]
+
+    members = \
+        [ "protected:"
+        , "  Connection m_c;"
+        ]
+
+    ctors = \
+        [ "template<typename C>"
+        , "%s(C && c)" % ctor_name
+        , "  : m_c(std::forward<C>(c))"
+        , "{}"
+        ]
+
+    # >>> if begin <<<
+    if namespace.is_ext:
+        # XXX: The xkb extension contains the sub-event in the member pad0
+        if ns == "xkb":
+            opcode_switch = "event->pad0"
+        else:
+            opcode_switch = "(event->response_type & ~0x80) - m_first_event"
+
+        members += [ "  uint8_t m_first_event;" ]
+
+        ctors = \
+            [ "template<typename C>"
+            , "%s(C && c, uint8_t first_event)" % (ctor_name)
+            , "  : m_c(std::forward<C>(c))"
+            , "  , m_first_event(first_event)"
+            , "{}"
+            , ""
+            , "template<typename C>"
+            , "%s(C && c, const xpp::%s::extension & extension)" % (ctor_name, ns)
+            , "  : %s(std::forward<C>(c), extension->first_event)" % ctor_name
+            , "{}"
+            ]
+
+    # >>> if end <<<
+
+    if len(typedef) > 0:
+        typedef = "\n".join(map(lambda s: "    " + s, typedef)) + "\n"
+    else:
+        typedef = ""
+
+    if len(ctors) > 0:
+        ctors = "\n".join(map(lambda s: ("    " if len(s) > 0 else "") + s, ctors)) + "\n"
+    else:
+        ctors = ""
+
+    if len(members) > 0:
+        members = "\n".join(map(lambda s: "  " + s, members)) + "\n"
+    else:
+        members = ""
+
+    switch = event_switch_cases(cppevents, opcode_switch, "handler", "event", namespace)
+
+    return _event_dispatcher_class(typedef,
+                                   ctors,
+                                   switch,
+                                   members,
+                                   len(cppevents) > 0)
+
+def event_switch_cases(cppevents, arg_switch, arg_handler, arg_event, ns):
+    cases = ""
+    first_event_arg = ", m_first_event" if ns.is_ext else ""
+    templ = [ "        case %s:"
+            , "          %s(" % arg_handler + "%s<Connection>" + "(m_c%s, %s));" % (first_event_arg, arg_event)
+            , "          return true;"
+            , ""
+            , ""
+            ]
+
+    distinct_events = [[]]
+    for e in cppevents:
+        done = False
+        for l in distinct_events:
+            if e in l:
+                continue
+            else:
+                l.append(e)
+                done = True
+                break
+
+        if not done:
+            distinct_events.append([e])
+        else:
+            continue
+
+    for l in distinct_events:
+        cases += "\n      switch (%s) {\n\n" % arg_switch
+        for e in l:
+            cases += "\n".join(templ) % (e.opcode_name, e.scoped_name())
+        cases += "      };\n"
+
+    return cases if len(cppevents) > 0 else ""
+
+########## EVENT ##########
+
+class CppEvent(object):
+    def __init__(self, opcode, opcode_name, c_name, namespace, name, fields):
+        self.opcode = opcode
+        self.opcode_name = opcode_name
+        self.c_name = c_name
+        self.namespace = namespace
+        self.fields = fields
+
+        self.names = map(str.lower, _n_item(name[-1], True))
+        self.name = "_".join(map(str.lower, self.names))
+
+        self.nssopen = ""
+        self.nssclose = ""
+        self.scope = []
+        for name in self.names[0:-1]:
+            if name in _reserved_keywords: name += "_"
+            self.nssopen += " namespace %s {" % name
+            self.nssclose += " };"
+            self.scope.append(name)
+
+    def __cmp__(self, other):
+        if self.opcode == other.opcode:
+            return 0
+        elif self.opcode < other.opcode:
+            return -1
+        else:
+            return 1
+
+    def get_name(self):
+        return _reserved_keywords.get(self.name, self.name)
+
+
+    def scoped_name(self):
+        ns = get_namespace(self.namespace)
+        return "xpp::" + ns + "::event::" + self.get_name()
+
+    def make_class(self):
+        member_accessors = []
+        member_accessors_special = []
+        for field in self.fields:
+            if field.field_type[-1] in _resource_classes:
+                template_name = field.field_name.capitalize()
+                c_type = field.c_field_type
+                method_name = field.field_name.lower()
+                if (method_name == self.get_name()
+                    or method_name in _reserved_keywords):
+                    method_name += "_"
+                member = field.c_field_name
+
+                member_accessors.append(_field_accessor_template(c_type, method_name, member))
+
+        ns = get_namespace(self.namespace)
+
+        extension = "xpp::%s::extension" % ns
+
+        ctor = \
+            [ "template<typename C>"
+            , "%s(C && c," % self.get_name()
+            , (" " * len(self.get_name())) + " const std::shared_ptr<xcb_generic_event_t> & event)"
+            , "  : base(event)"
+            , "  , m_c(std::forward<C>(c))"
+            , "{}"
+            ]
+
+        m_first_event = ""
+
+        typedef = [ "typedef xpp::%s::extension extension;" % ns ]
+
+        description = \
+            [ "static std::string description(void)"
+            , "{"
+            , "  return std::string(\"%s\");" % self.opcode_name
+            , "}"
+            ]
+
+        opcode_accessor = \
+            [ "static uint8_t opcode(void)"
+            , "{"
+            , "  return %s;" % self.opcode_name
+            , "}"
+            ]
+
+        first_event = []
+
+        if self.namespace.is_ext:
+            opcode_accessor += \
+                [ ""
+                , "static uint8_t opcode(uint8_t first_event)"
+                , "{"
+                , "  return first_event + opcode();"
+                , "}"
+                , ""
+                , "static uint8_t opcode(const xpp::%s::extension & extension)" % ns
+                , "{"
+                , "  return opcode(extension->first_event);"
+                , "}"
+                ]
+
+            first_event = \
+                [ "uint8_t first_event(void)"
+                , "{"
+                , "  return m_first_event;"
+                , "}"
+                ]
+
+            ctor = \
+                [ "template<typename C>"
+                , "%s(C && c," % self.get_name()
+                , (" " * len(self.get_name())) + " uint8_t first_event,"
+                , (" " * len(self.get_name())) + " const std::shared_ptr<xcb_generic_event_t> & event)"
+                , "  : base(event)"
+                , "  , m_c(std::forward<C>(c))"
+                , "  , m_first_event(first_event)"
+                , "{}"
+                ]
+
+            m_first_event = "    const uint8_t m_first_event;\n"
+
+        if len(opcode_accessor) > 0:
+            opcode_accessor = "\n".join(map(lambda s: "    " + s, opcode_accessor)) + "\n"
+        else:
+            opcode_accessor = ""
+
+        if len(ctor) > 0:
+            ctor = "\n".join(map(lambda s: "    " + s, ctor)) + "\n"
+        else:
+            ctor = ""
+
+        if len(typedef) > 0:
+            typedef = "\n".join(map(lambda s: "    " + s, typedef)) + "\n\n"
+        else:
+            typedef = ""
+
+        if len(member_accessors) > 0:
+            member_accessors = "\n" + "\n\n".join(member_accessors) + "\n\n"
+            member_accessors_special = "\n" + "\n\n".join(member_accessors_special) + "\n\n"
+        else:
+            member_accessors = ""
+            member_accessors_special = ""
+
+        if len(description) > 0:
+            description = "\n" + "\n".join(map(lambda s: "    " + s, description)) + "\n"
+        else:
+            description = ""
+
+        if len(first_event) > 0:
+            first_event = "\n" + "\n".join(map(lambda s: "    " + s, first_event)) + "\n"
+        else:
+            first_event = ""
+
+        return \
+'''
+namespace event {
+template<typename Connection>
+class %s
+  : public xpp::generic::event<%s>
+{
+  public:
+%s\
+    typedef xpp::generic::event<%s> base;
+
+%s\
+
+    virtual ~%s(void) {}
+
+%s\
+%s\
+%s\
+%s\
+  protected:
+    Connection m_c;
+%s\
+}; // class %s
+%s\
+} // namespace event
+''' % (self.get_name(), # class %s
+       self.c_name, # %s>
+       typedef,
+       self.c_name, # typedef xpp::generic::event<%s>::base;
+       ctor,
+       self.get_name(), # virtual ~%s(void) {}
+       opcode_accessor,
+       description,
+       first_event,
+       member_accessors,
+       m_first_event,
+       self.get_name(), # // class %s
+       member_accessors_special)
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cppreply.py polybar-3.2.1/lib/xpp/generators/cppreply.py
--- polybar-3.2.1.orig/lib/xpp/generators/cppreply.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cppreply.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,138 @@
+from utils import _n, _ext, _n_item, get_namespace
+from resource_classes import _resource_classes
+
+_templates = {}
+
+_templates['reply_class'] = \
+'''\
+namespace reply {
+
+namespace detail {
+
+template<typename Connection,
+         typename Check,
+         typename CookieFunction>
+class %s
+  : public xpp::generic::reply<%s<Connection, Check, CookieFunction>,
+                               Connection,
+                               Check,
+                               SIGNATURE(%s_reply),
+                               CookieFunction>
+{
+  public:
+    typedef xpp::generic::reply<%s<Connection, Check, CookieFunction>,
+                                Connection,
+                                Check,
+                                SIGNATURE(%s_reply),
+                                CookieFunction>
+                                  base;
+
+    template<typename C, typename ... Parameter>
+    %s(C && c, Parameter && ... parameter)
+      : base(std::forward<C>(c), std::forward<Parameter>(parameter) ...)
+    {}
+
+%s\
+%s\
+}; // class %s
+
+} // namespace detail
+
+namespace checked {
+template<typename Connection>
+using %s = detail::%s<
+    Connection, xpp::generic::checked_tag,
+    SIGNATURE(%s)>;
+} // namespace checked
+
+namespace unchecked {
+template<typename Connection>
+using %s = detail::%s<
+    Connection, xpp::generic::unchecked_tag,
+    SIGNATURE(%s_unchecked)>;
+} // namespace unchecked
+
+} // namespace reply
+'''
+
+def _reply_class(name, c_name, ns, cookie, accessors):
+    return _templates['reply_class'] % \
+            ( name
+            , name # base class
+            , c_name # %s_reply
+            , name # typedef
+            , c_name # %s_reply
+            , name # c'tor
+            , cookie.make_static_getter()
+            , accessors
+            , name # // class %s
+            , name # checked { using %s =
+            , name # checked { detail::%s
+            , c_name # checked { SIGNATURE
+            , name # unchecked { using %s =
+            , name # unchecked { detail::%s
+            , c_name # unchecked { SIGNATURE
+            )
+
+_templates['reply_member_accessor'] = \
+'''\
+    template<typename ReturnType = %s, typename ... Parameter>
+    ReturnType
+    %s(Parameter && ... parameter)
+    {
+      using make = xpp::generic::factory::make<Connection,
+                                               decltype(this->get()->%s),
+                                               ReturnType,
+                                               Parameter ...>;
+      return make()(this->m_c,
+                    this->get()->%s,
+                    std::forward<Parameter>(parameter) ...);
+    }
+'''
+
+def _reply_member_accessor(request_name, name, c_type, template_type):
+    return _templates['reply_member_accessor'] % \
+            ( c_type
+            , name
+            , name
+            , name
+            )
+
+class CppReply(object):
+    def __init__(self, namespace, name, cookie, reply, accessors, parameter_list):
+        self.namespace = namespace
+        self.name = name
+        self.reply = reply
+        self.cookie = cookie
+        self.accessors = accessors
+        self.parameter_list = parameter_list
+        self.request_name = _ext(_n_item(self.name[-1]))
+        self.c_name = "xcb" \
+            + (("_" + get_namespace(namespace)) if namespace.is_ext else "") \
+            + "_" + self.request_name
+
+    def make_accessors(self):
+        return "\n".join(map(lambda a: "\n%s\n" % a, self.accessors))
+
+    def make(self):
+        accessors = [self.make_accessors()]
+        naccessors = len(self.accessors)
+
+        for field in self.reply.fields:
+            if (field.field_type[-1] in _resource_classes
+                and not field.type.is_list
+                and not field.type.is_container):
+
+                naccessors = naccessors + 1
+
+                name = field.field_name.lower()
+                c_type = field.c_field_type
+                template_type = field.field_name.capitalize()
+
+                accessors.append(_reply_member_accessor(self.request_name, name, c_type, template_type))
+
+        result = ""
+        result += _reply_class(
+            self.request_name, self.c_name, get_namespace(self.namespace),
+            self.cookie, "\n".join(accessors))
+        return result
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/cpprequest.py polybar-3.2.1/lib/xpp/generators/cpprequest.py
--- polybar-3.2.1.orig/lib/xpp/generators/cpprequest.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/cpprequest.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,197 @@
+# vim: set ts=4 sws=4 sw=4:
+
+# from utils import *
+from utils import _n, _ext, _n_item, get_namespace
+from parameter import *
+from resource_classes import _resource_classes
+from cppreply import CppReply
+from cppcookie import CppCookie
+
+_templates = {}
+
+_templates['void_request_function'] = \
+'''\
+template<typename Connection, typename ... Parameter>
+void
+%s_checked(Connection && c, Parameter && ... parameter)
+{
+  xpp::generic::check<Connection, xpp::%s::error::dispatcher>(
+      std::forward<Connection>(c),
+      %s_checked(
+          std::forward<Connection>(c),
+          std::forward<Parameter>(parameter) ...));
+}
+
+template<typename ... Parameter>
+void
+%s(Parameter && ... parameter)
+{
+  %s(std::forward<Parameter>(parameter) ...);
+}
+'''
+
+def _void_request_function(ns, name, c_name):
+    return _templates['void_request_function'] % \
+            ( name
+            , ns
+            , c_name
+            , name
+            , c_name
+            )
+
+_templates['reply_request_function'] = \
+'''\
+template<typename Connection, typename ... Parameter>
+reply::checked::%s<Connection>
+%s(Connection && c, Parameter && ... parameter)
+{
+  return reply::checked::%s<Connection>(
+      std::forward<Connection>(c), std::forward<Parameter>(parameter) ...);
+}
+
+template<typename Connection, typename ... Parameter>
+reply::unchecked::%s<Connection>
+%s_unchecked(Connection && c, Parameter && ... parameter)
+{
+  return reply::unchecked::%s<Connection>(
+      std::forward<Connection>(c), std::forward<Parameter>(parameter) ...);
+}
+'''
+
+def _reply_request_function(name):
+    return _templates['reply_request_function'] % \
+            ( name
+            , name
+            , name
+            , name
+            , name
+            , name)
+
+_templates['inline_reply_class'] = \
+'''\
+    template<typename ... Parameter>
+    auto
+    %s(Parameter && ... parameter) const
+    -> reply::checked::%s<Connection>
+    {
+      return xpp::%s::%s(
+          connection(),
+          %s\
+          std::forward<Parameter>(parameter) ...);
+    }
+
+    template<typename ... Parameter>
+    auto
+    %s_unchecked(Parameter && ... parameter) const
+    -> reply::unchecked::%s<Connection>
+    {
+      return xpp::%s::%s_unchecked(
+          connection(),
+          %s\
+          std::forward<Parameter>(parameter) ...);
+    }
+'''
+
+def _inline_reply_class(request_name, method_name, member, ns):
+    return _templates['inline_reply_class'] % \
+            ( method_name
+            , request_name
+            , ns
+            , request_name
+            , member
+            , method_name
+            , request_name
+            , ns
+            , request_name
+            , member
+            )
+
+_templates['inline_void_class'] = \
+'''\
+    template<typename ... Parameter>
+    void
+    %s_checked(Parameter && ... parameter) const
+    {
+      xpp::%s::%s_checked(connection(),
+                          %s\
+                          std::forward<Parameter>(parameter) ...);
+    }
+
+    template<typename ... Parameter>
+    void
+    %s(Parameter && ... parameter) const
+    {
+      xpp::%s::%s(connection(),
+                  %s\
+                  std::forward<Parameter>(parameter) ...);
+    }
+'''
+
+def _inline_void_class(request_name, method_name, member, ns):
+    return _templates['inline_void_class'] % \
+            ( method_name
+            , ns
+            , request_name
+            , member
+            , method_name
+            , ns
+            , request_name
+            , member
+            )
+
+_replace_special_classes = \
+        { "gcontext" : "gc" }
+
+def replace_class(method, class_name):
+    cn = _replace_special_classes.get(class_name, class_name)
+    return method.replace("_" + cn, "")
+
+class CppRequest(object):
+    def __init__(self, request, name, is_void, namespace, reply):
+        self.request = request
+        self.name = name
+        self.request_name = _ext(_n_item(self.request.name[-1]))
+        self.is_void = is_void
+        self.namespace = namespace
+        self.reply = reply
+        self.c_namespace = \
+            "" if namespace.header.lower() == "xproto" \
+            else get_namespace(namespace)
+        self.accessors = []
+        self.parameter_list = ParameterList()
+
+        self.c_name = "xcb" \
+            + (("_" + get_namespace(namespace)) if namespace.is_ext else "") \
+            + "_" + self.request_name
+
+    def add(self, param):
+        self.parameter_list.add(param)
+
+    def make_wrapped(self):
+        self.parameter_list.make_wrapped()
+
+    def make_class(self):
+        cppcookie = CppCookie(self.namespace, self.is_void, self.request.name, self.reply, self.parameter_list)
+
+        if self.is_void:
+            void_functions = cppcookie.make_void_functions()
+            if len(void_functions) > 0:
+                return void_functions
+            else:
+                return _void_request_function(get_namespace(self.namespace), self.request_name, self.c_name)
+
+        else:
+            cppreply = CppReply(self.namespace, self.request.name, cppcookie, self.reply, self.accessors, self.parameter_list)
+            return cppreply.make() + "\n\n" + _reply_request_function(self.request_name)
+
+    def make_object_class_inline(self, is_connection, class_name=""):
+        member = ""
+        method_name = self.name
+        if not is_connection:
+            member = "resource(),\n"
+            method_name = replace_class(method_name, class_name)
+
+        if self.is_void:
+            return _inline_void_class(self.request_name, method_name, member, get_namespace(self.namespace))
+        else:
+            return _inline_reply_class(self.request_name, method_name, member, get_namespace(self.namespace))
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/extensionclass.py polybar-3.2.1/lib/xpp/generators/extensionclass.py
--- polybar-3.2.1.orig/lib/xpp/generators/extensionclass.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/extensionclass.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,45 @@
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext
+
+class ExtensionClass(object):
+    def __init__(self, namespace):
+        self.namespace = namespace
+
+    def make_class(self):
+        # if not self.namespace.is_ext:
+        #     return ""
+        # else:
+        ns = get_namespace(self.namespace)
+        if self.namespace.is_ext:
+            base = "\n  : public xpp::generic::extension<extension, &xcb_%s_id>\n" % ns
+            ctor = "    using base = xpp::generic::extension<extension, &xcb_%s_id>;\n" % ns + \
+                   "    using base::base;\n"
+        else:
+            base = " "
+            ctor = ""
+
+        return \
+'''\
+template<typename Derived, typename Connection>
+class interface;
+
+namespace event { template<typename Connection> class dispatcher; }
+namespace error { class dispatcher; }
+
+class extension%s{
+  public:
+%s\
+    template<typename Derived, typename Connection>
+    using interface = xpp::%s::interface<Derived, Connection>;
+    template<typename Connection>
+    using event_dispatcher = xpp::%s::event::dispatcher<Connection>;
+    using error_dispatcher = xpp::%s::error::dispatcher;
+};\
+''' % (base,
+       ctor,
+       ns, # typedef xpp::interface::%s interface;
+       ns, # typedef xpp::event::dispatcher::%s dispatcher;
+       ns) # typedef xpp::error::dispatcher::%s dispatcher;
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/interfaceclass.py polybar-3.2.1/lib/xpp/generators/interfaceclass.py
--- polybar-3.2.1.orig/lib/xpp/generators/interfaceclass.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/interfaceclass.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,86 @@
+# vim: set ts=4 sws=4 sw=4:
+
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext
+
+from cppevent import event_dispatcher_class
+from cpperror import error_dispatcher_class
+
+_templates = {}
+
+_templates['interface_class'] = \
+"""\
+template<typename Derived, typename Connection>
+class interface
+{
+  protected:
+    Connection
+    connection(void) const
+    {
+      return static_cast<const Derived *>(this)->connection();
+    }
+
+  public:
+%s\
+
+    virtual ~interface(void) {}
+
+    const interface<Derived, Connection> &
+    %s(void)
+    {
+      return *this;
+    }
+
+%s\
+}; // class interface
+"""
+
+_ignore_events = \
+        { "XCB_PRESENT_GENERIC" }
+
+########## INTERFACECLASS ##########
+
+class InterfaceClass(object):
+    def __init__(self):
+        self.requests = []
+        self.events = []
+        self.errors = []
+
+    def add(self, request):
+        self.requests.append(request)
+
+    def add_event(self, event):
+        if event.opcode_name not in _ignore_events:
+            self.events.append(event)
+
+    def add_error(self, error):
+        self.errors.append(error)
+
+    def set_namespace(self, namespace):
+        self.namespace = namespace
+
+    def make_proto(self):
+        ns = get_namespace(self.namespace)
+        methods = ""
+        for request in self.requests:
+            methods += request.make_object_class_inline(True) + "\n\n"
+
+        typedef = []
+        if self.namespace.is_ext:
+            typedef = [ "typedef xpp::%s::extension extension;" % ns ]
+
+        if len(typedef) > 0:
+            typedef = "".join(map(lambda s: "    " + s, typedef)) + "\n\n"
+        else:
+            typedef = ""
+
+
+        return (_templates['interface_class'] \
+            % (typedef, ns, methods)) + \
+              '\n' + event_dispatcher_class(self.namespace, self.events) + \
+              '\n' + error_dispatcher_class(self.namespace, self.errors)
+
+########## INTERFACECLASS ##########
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/Makefile polybar-3.2.1/lib/xpp/generators/Makefile
--- polybar-3.2.1.orig/lib/xpp/generators/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/Makefile	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,60 @@
+include ../flags.makefile
+
+# find ${PROTODIR} -iname '*.xml' -exec basename {} .xml \;
+# without ge, xf86vidmode
+PROTOS= \
+	present \
+	dpms \
+	shm \
+	damage \
+	dri3 \
+	render \
+	xfixes \
+	screensaver \
+	bigreq \
+	xprint \
+	xinerama \
+	xkb \
+	xc_misc \
+	record \
+	xproto \
+	xvmc \
+	dri2 \
+	xinput \
+	sync \
+	randr \
+	xtest \
+	res \
+	shape \
+	xevie \
+	glx \
+	xv \
+	xselinux \
+	xf86dri \
+	composite
+
+PYTHON=python2
+CLIENT=cpp_client.py
+XCBGEN=/usr/lib/python2.7/site-packages
+PROTODIR=/usr/share/xcb
+XMLPROTOS=$(PROTOS:%=%.xml)
+HPPPROTOS=$(XMLPROTOS:%.xml=%.hpp)
+
+all: ${XMLPROTOS}
+
+gch: ${HPPPROTOS}
+
+${HPPPROTOS}:
+	-${CXX} ${CXXFLAGS} ${LDFLAGS} -c $(if $(filter $@,xproto.hpp),x.hpp,$(@))
+
+${XMLPROTOS}:
+	-${PYTHON} ${CLIENT} -p ${XCBGEN} ${PROTODIR}/$@ > $(if $(filter $@,xproto.xml),x.hpp,$(@:%.xml=%.hpp))
+
+find:
+	@ find ${PROTODIR} -iname '*.xml' -exec basename {} .xml \;
+
+clean:
+	rm -f ${PROTOS:%=%.hpp}
+	rm -f $(PROTOS:%=%.hpp.gch)
+
+.PHONY: clean find ${XMLPROTOS} ${HPPPROTOS}
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/objectclass.py polybar-3.2.1/lib/xpp/generators/objectclass.py
--- polybar-3.2.1.orig/lib/xpp/generators/objectclass.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/objectclass.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,69 @@
+# vim: set ts=4 sws=4 sw=4:
+
+import sys # stderr
+import copy # deepcopy
+
+from utils import \
+        get_namespace, \
+        get_ext_name, \
+        _n_item, \
+        _ext
+
+class ObjectClass(object):
+    def __init__(self, name):
+        self.name = name
+        self.requests = []
+
+    def add(self, request):
+        if (len(request.parameter_list.parameter) > 0
+                and request.parameter_list.parameter[0].c_type == self.c_name):
+            request_copy = copy.deepcopy(request)
+            request_copy.parameter_list.parameter.pop(0)
+            request_copy.make_wrapped()
+            self.requests.append(request_copy)
+
+    def set_namespace(self, namespace):
+        self.namespace = namespace
+        name = (get_namespace(namespace) + "_") if namespace.is_ext else ""
+        self.c_name = "xcb_%s_t" % (name + self.name.lower())
+
+    def make_inline(self):
+        ns = get_namespace(self.namespace)
+        name = self.name.lower()
+        c_name = self.c_name
+        methods = ""
+
+        for request in self.requests:
+            methods += request.make_object_class_inline(False, self.name.lower()) + "\n\n"
+
+        if methods == "":
+            return ""
+        else:
+            return \
+"""\
+template<typename Derived, typename Connection>
+class %s
+{
+  protected:
+    Connection
+    connection(void) const
+    {
+      return static_cast<const Derived *>(this)->connection();
+    }
+
+    const %s &
+    resource(void) const
+    {
+      return static_cast<const Derived *>(this)->resource();
+    }
+
+  public:
+    virtual ~%s(void) {}
+
+%s
+}; // class %s
+""" % (name,   # class %s
+       c_name, # %s resource(void) { ... }
+       name, # virtual ~%s(void)
+       methods,
+       name) # }; // class %s
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/parameter.py polybar-3.2.1/lib/xpp/generators/parameter.py
--- polybar-3.2.1.orig/lib/xpp/generators/parameter.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/parameter.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,269 @@
+# vim: set ts=4 sws=4 sw=4:
+
+import sys # stderr
+
+_templates = {}
+
+_templates['initializer'] = \
+'''\
+typedef typename value_type<%s, ! std::is_pointer<%s>::value>::type
+          vector_type;
+std::vector<vector_type> %s =
+  { value_iterator<%s>(%s), value_iterator<%s>(%s) };
+'''
+
+def _initializer(iter_type, c_name, iter_begin, iter_end):
+    return _templates['initializer'] % \
+            ( iter_type
+            , iter_type
+            , c_name
+            , iter_type
+            , iter_begin
+            , iter_type
+            , iter_end
+            )
+
+class ParameterList(object):
+    def __init__(self):
+        self.want_wrap = False
+        self.has_defaults = False
+        self.parameter = []
+        self.wrap_calls = []
+        self.wrap_protos = []
+        self.iter_calls = []
+        self.iter_2nd_lvl_calls = []
+        self.iter_protos = []
+        self.templates = []
+        self.iterator_templates = []
+        self.initializer = []
+
+    def add(self, param):
+        self.has_defaults = param.default != None
+        self.parameter.append(param)
+
+    def comma(self):
+        return "" if len(self.parameter) == 0 else ", "
+
+    def is_reordered(self):
+        tmp = sorted(self.parameter, cmp=lambda p1, p2: cmp(p1.default, p2.default))
+        return tmp != self.parameter
+
+    def calls(self, sort, params=None):
+        ps = self.parameter if params == None else params
+        if sort:
+            tmp = sorted(ps, cmp=lambda p1, p2: cmp(p1.default, p2.default))
+            ps = tmp
+        calls = map(lambda p: p.call(), ps)
+        return "" if len(calls) == 0 else ", ".join(calls)
+
+    def protos(self, sort, defaults, params=None):
+        if defaults: sort = True
+        ps = self.parameter if params == None else params
+        if sort:
+            tmp = sorted(ps, cmp=lambda p1, p2: cmp(p1.default, p2.default))
+            ps = tmp
+        protos = map(lambda p: p.proto(defaults), ps)
+        return "" if len(protos) == 0 else ", ".join(protos)
+
+    def iterator_initializers(self):
+        return self.initializer
+
+    def make_wrapped(self):
+        self.wrap_calls = []
+        self.wrap_protos = []
+        self.iter_calls = []
+        self.iter_2nd_lvl_calls = []
+        self.iter_protos = []
+        self.initializer = []
+        self.templates = []
+        self.iterator_templates = []
+
+        lenfields = {}
+        # if a parameter is removed, take reduced parameter size into account
+        adjust = 0
+        for index, param in enumerate(self.parameter):
+            prev = index - adjust - 1
+
+            if param.field.type.is_list:
+                name = param.field.type.expr.lenfield_name
+                if lenfields.has_key(name):
+                    lenfields[name].append(param.c_name)
+                else:
+                    lenfields[name] = [ param.c_name ]
+
+                # sys.stderr.write("list: %s %s\n\n"
+                #         % ( param.field.type.expr.lenfield_type
+                #           , param.field.type.expr.lenfield_name
+                #           ))
+
+            # SetGamma: takes 1 size, but 3 value lists
+            # if param.field.type.is_list and prev >= 0:
+            if (param.is_const and param.is_pointer
+                    and prev >= 0
+                    and self.parameter[prev].c_name == param.c_name + "_len"):
+
+                adjust = adjust + 1
+                self.want_wrap = True
+                self.wrap_calls.pop(prev)
+                self.wrap_protos.pop(prev)
+                self.iter_calls.pop(prev)
+                self.iter_2nd_lvl_calls.pop(prev)
+                self.iter_protos.pop(prev)
+
+                prev_type = self.parameter[prev].c_type
+                if param.c_type == 'char':
+
+                    def append_proto_string(list):
+                        list.append(Parameter(None, \
+                            c_type='const std::string &',
+                            c_name=param.c_name))
+
+                    def append_call_string(list):
+                        list.append(Parameter(None, \
+                            c_name="static_cast<" + prev_type + ">(" \
+                            + param.c_name + '.length())'))
+
+                        list.append(Parameter(None, \
+                            c_name=param.c_name + '.c_str()'))
+
+                    append_proto_string(self.wrap_protos)
+                    append_proto_string(self.iter_protos)
+                    append_call_string(self.wrap_calls)
+                    append_call_string(self.iter_calls)
+                    append_call_string(self.iter_2nd_lvl_calls)
+
+                else:
+                    param_type = param.c_type
+                    if param_type == "void":
+                        param_type = "Type_" + str(index)
+                        self.templates.append(param_type)
+
+                    prev_type = self.parameter[prev].c_type
+
+                    ### std::vector
+                    self.wrap_protos.append(Parameter(None, \
+                        c_type='const std::vector<' + param_type + '> &',
+                        c_name=param.c_name))
+
+                    self.wrap_calls.append(Parameter(None, \
+                      c_name="static_cast<" + prev_type + ">(" \
+                      + param.c_name + '.size())'))
+
+                    self.wrap_calls.append(Parameter(None, \
+                        c_name=param.c_name + '.data()'))
+
+                    ### Iterator
+                    iter_type = param.c_name.capitalize() + "_Iterator"
+                    iter_begin = param.c_name + "_begin"
+                    iter_end = param.c_name + "_end"
+
+                    if len(self.templates) > 0:
+                        self.templates[-1] += " = typename " + iter_type + "::value_type"
+                    self.iterator_templates.append(iter_type)
+
+                    self.iter_protos.append(Parameter(None, \
+                            c_type=iter_type,
+                            c_name=iter_begin))
+
+                    self.iter_protos.append(Parameter(None, \
+                            c_type=iter_type,
+                            c_name=iter_end))
+
+                    self.iter_calls.append(Parameter(None, \
+                            c_name="static_cast<" + prev_type + ">(" \
+                            + param.c_name + '.size())'))
+
+                    self.iter_calls.append(Parameter(None, \
+                            c_name='const_cast<const vector_type *>(' \
+                            + param.c_name + '.data())'))
+
+                    self.iter_2nd_lvl_calls.append(Parameter(None, \
+                            c_name=iter_begin))
+
+                    self.iter_2nd_lvl_calls.append(Parameter(None, \
+                            c_name=iter_end))
+
+#                     vector_type = \
+#                     '''\
+# typename value_type<%s,
+#                   ! std::is_pointer<%s>::value
+#                  >::type\
+#                     ''' % (iter_type, iter_type)
+
+                    # self.initializer.append( \
+                    #         "std::vector<%s> %s = { value_iterator<%s>(%s), \
+                    #         value_iterator<%s>(%s) };" \
+                    #         % (vector_type, param.c_name,
+                    #             iter_type, iter_begin,
+                    #             iter_type, iter_end))
+
+                    self.initializer.append(
+                            _initializer(iter_type, param.c_name, iter_begin, iter_end))
+
+            else:
+                self.wrap_calls.append(param)
+                self.wrap_protos.append(param)
+                self.iter_calls.append(param)
+                self.iter_2nd_lvl_calls.append(param)
+                self.iter_protos.append(param)
+
+        # end: for index, param in enumerate(self.parameter):
+
+        for k, v in lenfields.items():
+            if len(v) > 1:
+                sys.stderr.write("list: %s, %s\n" % (k, v))
+
+
+    def wrapped_calls(self, sort):
+        return self.calls(sort, params=self.wrap_calls)
+
+    def wrapped_protos(self, sort, defaults):
+        return self.protos(sort, defaults, params=self.wrap_protos)
+
+    def iterator_calls(self, sort):
+        return self.calls(sort, params=self.iter_calls)
+
+    def iterator_2nd_lvl_calls(self, sort):
+        return self.calls(sort, params=self.iter_2nd_lvl_calls)
+
+    def iterator_protos(self, sort, defaults):
+        return self.protos(sort, defaults, params=self.iter_protos)
+
+
+
+_default_parameter_values = \
+    { "xcb_timestamp_t" : "XCB_TIME_CURRENT_TIME" }
+
+class Parameter(object):
+    def __init__(self, field, c_type="", c_name="", verbose=False):
+        self.field = field
+        if field != None:
+          self.c_type = field.c_field_type
+          self.c_name = field.c_field_name
+          self.is_const = field.c_field_const_type == "const " + field.c_field_type
+          self.is_pointer = field.c_pointer != " "
+          # self.serialize = field.type.need_serialize
+          self.default = _default_parameter_values.get(self.c_type)
+          self.with_default = True
+          if verbose:
+              sys.stderr.write("c_type: %s; c_name: %s; default: %s\n" \
+                      % (self.c_type, self.c_name, self.default))
+
+        else:
+          self.c_type = c_type
+          self.c_name = c_name
+          self.is_const = False
+          self.is_pointer = False
+          # self.serialize = field.type.need_serialize
+          self.default = _default_parameter_values.get(self.c_type)
+          self.with_default = True
+
+    def call(self):
+        return self.c_name
+
+    def proto(self, with_default):
+        c_type = ("const " if self.is_const else "") \
+             + self.c_type \
+             + (" *" if self.is_pointer else "")
+        param = " = " + self.default if with_default and self.default != None else ""
+        return c_type + " " + self.c_name + param
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/resource_classes.py polybar-3.2.1/lib/xpp/generators/resource_classes.py
--- polybar-3.2.1.orig/lib/xpp/generators/resource_classes.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/resource_classes.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,81 @@
+_resource_classes = \
+    {
+    ### XPROTO ###
+      "WINDOW"
+    , "PIXMAP"
+    , "CURSOR"
+    , "FONT"
+    , "GCONTEXT"
+    , "COLORMAP"
+    , "ATOM"
+    , "DRAWABLE"
+    , "FONTABLE"
+    ### XPROTO ###
+
+    ### DAMAGE ###
+    , "DAMAGE"
+    ### DAMAGE ###
+
+    ### GLX, RECORD, XVMC ###
+    , "CONTEXT"
+    ### GLX, RECORD, XVMC ###
+
+    ### GLX ###
+    # , "PIXMAP" # already in XPROTO
+    # , "CONTEXT"
+    , "PBUFFER"
+    # , "WINDOW" # already in XPROTO
+    , "FBCONFIG"
+    ### GLX ###
+
+    ### PRESENT ###
+    , "EVENT"
+    ### PRESENT ###
+
+    ### RANDR ###
+    , "MODE"
+    , "CRTC"
+    , "OUTPUT"
+    , "PROVIDER"
+    ### RANDR ###
+
+    ### RECORD ###
+    # , "CONTEXT"
+    ### RECORD ###
+
+    ### RENDER ###
+    , "GLYPHSET"
+    , "PICTURE"
+    , "PICTFORMAT"
+    ### RENDER ###
+
+    ### SHM ###
+    , "SEG"
+    ### SHM ###
+
+    ### SYNC ###
+    , "ALARM"
+    , "COUNTER"
+    , "FENCE"
+    ### SYNC ###
+
+    ### XFIXES ###
+    , "REGION"
+    , "BARRIER"
+    ### XFIXES ###
+
+    ### XPRINT ###
+    , "PCONTEXT"
+    ### XPRINT ###
+
+    ### XVMC ###
+    # , "CONTEXT"
+    , "SURFACE"
+    , "SUBPICTURE"
+    ### XVMC ###
+
+    ### XV ###
+    , "PORT"
+    , "ENCODING"
+    ### XV ###
+    }
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/TODO polybar-3.2.1/lib/xpp/generators/TODO
--- polybar-3.2.1.orig/lib/xpp/generators/TODO	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/TODO	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,53 @@
+TODO:
+
+* Build with python 3
+
+* valueparams
+
+* serialized fields (e.g. xcb_sync_create_alarm_value_list_serialize)
+  (is this necessary?)
+
+* specialize iterator for non-vector data structures:
+  Instead of converting to vector, check if it is possible to send the data
+  directly through the socket (e.g. map { key, value }:
+  for (k,v : map) { socket_send(v); } ...
+
+* XInput Event handling: Am I doing this right? (Multiple switches etc.)
+
+* Adapter classes for drawable, window, pixmap, atom, font, etc.
+
+$ grep xidtype *.xml
+damage.xml:  <xidtype name="DAMAGE" />
+glx.xml:     <xidtype name="PIXMAP" />
+glx.xml:     <xidtype name="CONTEXT" />
+glx.xml:     <xidtype name="PBUFFER" />
+glx.xml:     <xidtype name="WINDOW" />
+glx.xml:     <xidtype name="FBCONFIG" />
+present.xml: <xidtype name="EVENT"/>
+randr.xml:   <xidtype name="MODE" />
+randr.xml:   <xidtype name="CRTC" />
+randr.xml:   <xidtype name="OUTPUT" />
+randr.xml:   <xidtype name="PROVIDER" />
+record.xml:  <xidtype name="CONTEXT" />
+render.xml:  <xidtype name="GLYPHSET" />
+render.xml:  <xidtype name="PICTURE" />
+render.xml:  <xidtype name="PICTFORMAT" />
+shm.xml:     <xidtype name="SEG" />
+sync.xml:    <xidtype name="ALARM" />
+sync.xml:    <xidtype name="COUNTER" />
+sync.xml:    <xidtype name="FENCE" />
+xfixes.xml:  <xidtype name="REGION" />
+xfixes.xml:  <xidtype name="BARRIER" />
+xprint.xml:  <xidtype name="PCONTEXT" />
+xproto.xml:  <xidtype name="WINDOW" />
+xproto.xml:  <xidtype name="PIXMAP" />
+xproto.xml:  <xidtype name="CURSOR" />
+xproto.xml:  <xidtype name="FONT" />
+xproto.xml:  <xidtype name="GCONTEXT" />
+xproto.xml:  <xidtype name="COLORMAP" />
+xproto.xml:  <xidtype name="ATOM" />
+xvmc.xml:    <xidtype name="CONTEXT" />
+xvmc.xml:    <xidtype name="SURFACE" />
+xvmc.xml:    <xidtype name="SUBPICTURE" />
+xv.xml:      <xidtype name="PORT" />
+xv.xml:      <xidtype name="ENCODING" />
diff -Nuar polybar-3.2.1.orig/lib/xpp/generators/utils.py polybar-3.2.1/lib/xpp/generators/utils.py
--- polybar-3.2.1.orig/lib/xpp/generators/utils.py	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/generators/utils.py	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,63 @@
+import re # compile
+
+_reserved_keywords = {'class' : '_class',
+                      'new'   : '_new',
+                      'delete': '_delete',
+                      'default' : '_default',
+                      'private' : '_private',
+                      'explicit': '_explicit'}
+
+def get_namespace(namespace):
+    if namespace.is_ext:
+        return get_ext_name(namespace.ext_name)
+    else:
+        return "x"
+
+def get_ext_name(str):
+    return _ext(str)
+
+_cname_re = re.compile('([A-Z0-9][a-z]+|[A-Z0-9]+(?![a-z])|[a-z]+)')
+_cname_special_cases = {'DECnet':'decnet'}
+
+def _n_item(str, parts=False):
+    '''
+    Does C-name conversion on a single string fragment.
+    Uses a regexp with some hard-coded special cases.
+    '''
+    if str in _cname_special_cases:
+        return _cname_special_cases[str]
+    else:
+        split = _cname_re.finditer(str)
+        name_parts = [match.group(0) for match in split]
+        if parts:
+          return name_parts
+        else:
+          return '_'.join(name_parts)
+
+_extension_special_cases = ['XPrint', 'XCMisc', 'BigRequests']
+
+def _ext(str):
+    '''
+    Does C-name conversion on an extension name.
+    Has some additional special cases on top of _n_item.
+    '''
+    if str in _extension_special_cases:
+        return _n_item(str).lower()
+    else:
+        return str.lower()
+
+def _n(list, namespace):
+    '''
+    Does C-name conversion on a tuple of strings.
+    Different behavior depending on length of tuple, extension/not extension, etc.
+    Basically C-name converts the individual pieces, then joins with underscores.
+    '''
+    if len(list) == 1:
+        parts = list
+    elif len(list) == 2:
+        parts = [list[0], _n_item(list[1])]
+    elif namespace.is_ext:
+        parts = [list[0], _ext(list[1])] + [_n_item(i) for i in list[2:]]
+    else:
+        parts = [list[0]] + [_n_item(i) for i in list[1:]]
+    return '_'.join(parts).lower()
diff -Nuar polybar-3.2.1.orig/lib/xpp/.gitignore polybar-3.2.1/lib/xpp/.gitignore
--- polybar-3.2.1.orig/lib/xpp/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/.gitignore	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,7 @@
+build
+.clang_complete
+*.o
+*.swp
+*.gch
+*.d
+*.pyc
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/atom.hpp polybar-3.2.1/lib/xpp/include/xpp/atom.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/atom.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/atom.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,34 @@
+#ifndef XPP_ATOM_HPP
+#define XPP_ATOM_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class atom
+  : public xpp::generic::resource<Connection, xcb_atom_t,
+                                  xpp::x::atom, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_atom_t, Interfaces ...>;
+
+  public:
+    using base::base;
+    using base::operator=;
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::atom<Connection, Interfaces ...>>
+{
+  typedef xcb_atom_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_ATOM_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/colormap.hpp polybar-3.2.1/lib/xpp/include/xpp/colormap.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/colormap.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/colormap.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,77 @@
+#ifndef XPP_COLORMAP_HPP
+#define XPP_COLORMAP_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class colormap
+  : public xpp::generic::resource<Connection, xcb_colormap_t,
+                                  xpp::x::colormap, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_colormap_t,
+                                        xpp::x::colormap, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    colormap(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    colormap<Connection, Interfaces ...>
+    create(C && c, uint8_t alloc, xcb_window_t window, xcb_visualid_t visual)
+    {
+      return colormap(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_colormap_t & colormap)
+          {
+            xpp::x::create_colormap(c, alloc, colormap, window, visual);
+          },
+          [&](const Connection & c, const xcb_colormap_t & colormap)
+          {
+            xpp::x::free_colormap(c, colormap);
+          });
+    }
+
+    template<typename C>
+    static
+    colormap<Connection, Interfaces ...>
+    create_checked(C && c, uint8_t alloc,
+                   xcb_window_t window, xcb_visualid_t visual)
+    {
+      return colormap(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_colormap_t & colormap)
+          {
+            xpp::x::create_colormap_checked(c, alloc, colormap, window, visual);
+          },
+          [&](const Connection & c, const xcb_colormap_t & colormap)
+          {
+            xpp::x::free_colormap_checked(c, colormap);
+          });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::colormap<Connection, Interfaces ...>>
+{
+  typedef xcb_colormap_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_COLORMAP_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/connection.hpp polybar-3.2.1/lib/xpp/include/xpp/connection.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/connection.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/connection.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,157 @@
+#ifndef XPP_CONNECTION_HPP
+#define XPP_CONNECTION_HPP
+
+#include "core.hpp"
+#include "generic/factory.hpp"
+
+#include "proto/x.hpp"
+
+namespace xpp {
+
+namespace detail {
+
+template<typename Connection, typename ... Extensions>
+class interfaces
+  : public xpp::x::extension::interface<interfaces<Connection, Extensions ...>, Connection>
+  , public Extensions::template interface<interfaces<Connection, Extensions ...>, Connection> ...
+{
+  public:
+    Connection
+    connection(void) const
+    {
+      return static_cast<const Connection &>(*this);
+    }
+}; // class interfaces
+
+} // namespace detail
+
+template<typename ... Extensions>
+class connection
+  : public xpp::core
+  , public xpp::generic::error_dispatcher
+  , public detail::interfaces<connection<Extensions ...>, Extensions ...>
+  // private interfaces: extensions and error_dispatcher
+  , private xpp::x::extension
+  , private xpp::x::extension::error_dispatcher
+  , private Extensions ...
+  , private Extensions::error_dispatcher ...
+{
+  protected:
+    typedef connection<Extensions ...> self;
+
+
+  public:
+    template<typename ... Parameters>
+    explicit
+    connection(Parameters && ... parameters)
+      : xpp::core::core(std::forward<Parameters>(parameters) ...)
+      , detail::interfaces<connection<Extensions ...>, Extensions ...>(*this)
+      , Extensions(static_cast<xcb_connection_t *>(*this)) ...
+      , Extensions::error_dispatcher(static_cast<Extensions &>(*this).get()) ...
+    {
+      m_root_window = screen_of_display(default_screen())->root;
+    }
+
+    virtual
+    ~connection(void)
+    {}
+
+    virtual
+    operator xcb_connection_t *(void) const
+    {
+      return *(static_cast<const core &>(*this));
+    }
+
+    void
+    operator()(const std::shared_ptr<xcb_generic_error_t> & error) const
+    {
+      check<xpp::x::extension, Extensions ...>(error);
+    }
+
+    template<typename Extension>
+    const Extension &
+    extension(void) const
+    {
+      return static_cast<const Extension &>(*this);
+    }
+
+    // TODO
+    // virtual operator Display * const(void) const
+    // {
+    // }
+
+    template<typename Window = xcb_window_t>
+    Window
+    root(void)
+    {
+      using make = xpp::generic::factory::make<self, xcb_window_t, Window>;
+      return make()(*this, m_root_window);
+    }
+
+    template<typename Window = xcb_window_t>
+    Window
+    root(void) const
+    {
+      using make = xpp::generic::factory::make<self, xcb_window_t, Window>;
+      return make()(*this, m_root_window);
+    }
+
+    virtual
+    shared_generic_event_ptr
+    wait_for_event(void) const
+    {
+      try {
+        return core::wait_for_event();
+      } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+        check<xpp::x::extension, Extensions ...>(error);
+      }
+      // re-throw any exception caused by wait_for_event
+      throw;
+    }
+
+    virtual
+    shared_generic_event_ptr
+    wait_for_special_event(xcb_special_event_t * se) const
+    {
+      try {
+        return core::wait_for_special_event(se);
+      } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+        check<xpp::x::extension, Extensions ...>(error);
+      }
+      // re-throw any exception caused by wait_for_special_event
+      throw;
+    }
+
+  private:
+    xcb_window_t m_root_window;
+
+    template<typename Extension, typename Next, typename ... Rest>
+    void
+    check(const std::shared_ptr<xcb_generic_error_t> & error) const
+    {
+      check<Extension>(error);
+      check<Next, Rest ...>(error);
+    }
+
+    template<typename Extension>
+    void
+    check(const std::shared_ptr<xcb_generic_error_t> & error) const
+    {
+      using error_dispatcher = typename Extension::error_dispatcher;
+      auto & dispatcher = static_cast<const error_dispatcher &>(*this);
+      dispatcher(error);
+    }
+}; // class connection
+
+template<>
+template<typename ... Parameters>
+connection<>::connection(Parameters && ... parameters)
+  : xpp::core::core(std::forward<Parameters>(parameters) ...)
+  , detail::interfaces<connection<>>(*this)
+{
+  m_root_window = screen_of_display(static_cast<core &>(*this).default_screen())->root;
+}
+
+} // namespace xpp
+
+#endif // XPP_CONNECTION_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/core.hpp polybar-3.2.1/lib/xpp/include/xpp/core.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/core.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/core.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,339 @@
+#ifndef XPP_CORE_HPP
+#define XPP_CORE_HPP
+
+#include <string>
+#include <memory>
+#include <xcb/xcb.h>
+
+namespace xpp {
+
+class connection_error
+  : public std::runtime_error
+{
+  public:
+    connection_error(uint8_t code, const std::string & description)
+      : std::runtime_error(description + "(" + std::to_string(code) + ")")
+      , m_code(code)
+      , m_description(description)
+    {}
+
+    uint8_t
+    code(void)
+    {
+      return m_code;
+    }
+
+    std::string
+    description(void)
+    {
+      return m_description;
+    }
+
+  protected:
+    uint8_t m_code;
+    std::string m_description;
+};
+
+class core
+{
+  protected:
+    using shared_generic_event_ptr = std::shared_ptr<xcb_generic_event_t>;
+
+    int m_screen = 0;
+    // reference counting for xcb_connection_t
+    std::shared_ptr<xcb_connection_t> m_c;
+
+    shared_generic_event_ptr
+    dispatch(const std::string & producer, xcb_generic_event_t * event) const
+    {
+      if (event) {
+        if (event->response_type == 0) {
+          throw std::shared_ptr<xcb_generic_error_t>(
+              reinterpret_cast<xcb_generic_error_t *>(event));
+        }
+
+        return shared_generic_event_ptr(event, std::free);
+      }
+
+      check_connection();
+      throw std::runtime_error(producer + " failed");
+    }
+
+  public:
+    explicit
+    core(xcb_connection_t * c)
+      : m_c(std::shared_ptr<xcb_connection_t>(c, [](...) {}))
+    {}
+
+    template<typename ... ConnectionParameter>
+    explicit
+    core(xcb_connection_t * (*Connect)(ConnectionParameter ...),
+               ConnectionParameter ... connection_parameter)
+      : m_c(std::shared_ptr<xcb_connection_t>(
+          Connect(connection_parameter ...),
+          [&](void *) { disconnect(); }))
+    {}
+
+    // xcb_connect (const char *displayname, int *screenp)
+    explicit
+    core(const std::string & displayname = "")
+      : core(xcb_connect, displayname.c_str(), &m_screen)
+    {}
+
+    // xcb_connect_to_fd (int fd, xcb_auth_info_t *auth_info)
+    explicit
+    core(int fd, xcb_auth_info_t * auth_info)
+      : core(xcb_connect_to_fd, fd, auth_info)
+    {}
+
+    // xcb_connect_to_display_with_auth_info (
+    //     const char *display, xcb_auth_info_t *auth, int *screen)
+    explicit
+    core(const std::string & display, xcb_auth_info_t * auth)
+      : core(xcb_connect_to_display_with_auth_info,
+                   display.c_str(), auth, &m_screen)
+    {}
+
+    virtual
+    ~core(void)
+    {}
+
+    virtual
+    xcb_connection_t *
+    operator*(void) const
+    {
+      return m_c.get();
+    }
+
+    virtual
+    operator xcb_connection_t *(void) const
+    {
+      return m_c.get();
+    }
+
+    virtual
+    int
+    default_screen(void) const
+    {
+      return m_screen;
+    }
+
+    virtual
+    int
+    flush(void) const
+    {
+      return xcb_flush(m_c.get());
+    }
+
+    virtual
+    uint32_t
+    get_maximum_request_length(void) const
+    {
+      return xcb_get_maximum_request_length(m_c.get());
+    }
+
+    virtual
+    void
+    prefetch_maximum_request_length(void) const
+    {
+      xcb_prefetch_maximum_request_length(m_c.get());
+    }
+
+    virtual
+    shared_generic_event_ptr
+    wait_for_event(void) const
+    {
+      return dispatch("wait_for_event", xcb_wait_for_event(m_c.get()));
+    }
+
+    virtual
+    shared_generic_event_ptr
+    poll_for_event(void) const
+    {
+      return shared_generic_event_ptr(xcb_poll_for_event(m_c.get()));
+    }
+
+    virtual
+    shared_generic_event_ptr
+    poll_for_queued_event(void) const
+    {
+      return shared_generic_event_ptr(xcb_poll_for_queued_event(m_c.get()));
+    }
+
+    virtual
+    shared_generic_event_ptr
+    poll_for_special_event(xcb_special_event_t * se) const
+    {
+      return shared_generic_event_ptr(xcb_poll_for_special_event(m_c.get(), se));
+    }
+
+    // virtual
+    // shared_generic_event_ptr
+    // poll_for_special_event(const std::shared_ptr<xcb_special_event_t> & se) const
+    // {
+    //   return poll_for_special_event(se.get());
+    // }
+
+    virtual
+    shared_generic_event_ptr
+    wait_for_special_event(xcb_special_event_t * se) const
+    {
+      return dispatch("wait_for_special_event",
+                      xcb_wait_for_special_event(m_c.get(), se));
+    }
+
+    // virtual
+    // shared_generic_event_ptr
+    // wait_for_special_event(const std::shared_ptr<xcb_special_event_t> & se) const
+    // {
+    //   return wait_for_special_event(se.get());
+    // }
+
+    // xcb_special_event_t has incomplete type -> no std::shared_ptr
+    virtual
+    xcb_special_event_t *
+    register_for_special_xge(xcb_extension_t * ext,
+                             uint32_t eid,
+                             uint32_t * stamp) const
+    {
+      return xcb_register_for_special_xge(m_c.get(), ext, eid, stamp);
+    }
+
+    virtual
+    void
+    unregister_for_special_event(xcb_special_event_t * se) const
+    {
+      xcb_unregister_for_special_event(m_c.get(), se);
+    }
+
+    virtual
+    std::shared_ptr<xcb_generic_error_t>
+    request_check(xcb_void_cookie_t cookie) const
+    {
+      return std::shared_ptr<xcb_generic_error_t>(
+          xcb_request_check(m_c.get(), cookie));
+    }
+
+    virtual
+    void
+    discard_reply(unsigned int sequence) const
+    {
+      xcb_discard_reply(m_c.get(), sequence);
+    }
+
+    // The result must not be freed.
+    // This storage is managed by the cache itself.
+    virtual
+    const xcb_query_extension_reply_t *
+    get_extension_data(xcb_extension_t * ext) const
+    {
+      return xcb_get_extension_data(m_c.get(), ext);
+    }
+
+    virtual
+    void
+    prefetch_extension_data(xcb_extension_t * ext) const
+    {
+      xcb_prefetch_extension_data(m_c.get(), ext);
+    }
+
+    virtual
+    const xcb_setup_t *
+    get_setup(void) const
+    {
+      return xcb_get_setup(m_c.get());
+    }
+
+    virtual
+    int
+    get_file_descriptor(void) const
+    {
+      return xcb_get_file_descriptor(m_c.get());
+    }
+
+    virtual
+    int
+    connection_has_error(void) const
+    {
+      return xcb_connection_has_error(m_c.get());
+    }
+
+    virtual
+    void
+    disconnect(void) const
+    {
+      xcb_disconnect(m_c.get());
+    }
+
+    // hostname, display, screen
+    virtual
+    std::tuple<std::string, int, int>
+    parse_display(const std::string & name) const
+    {
+      int screen = 0;
+      int display = 0;
+      char * host = NULL;
+      std::string hostname;
+
+      xcb_parse_display(name.c_str(), &host, &display, &screen);
+      if (host != NULL) {
+        hostname = std::string(host);
+      }
+
+      return std::make_tuple(hostname, display, screen);
+    }
+
+    virtual
+    uint32_t
+    generate_id(void) const
+    {
+      return xcb_generate_id(m_c.get());
+    }
+
+    xcb_screen_t *
+    screen_of_display(int screen)
+    {
+      xcb_screen_iterator_t iter;
+
+      iter = xcb_setup_roots_iterator(xcb_get_setup(m_c.get()));
+      for (; iter.rem; --screen, xcb_screen_next(&iter))
+        if (screen == 0)
+          return iter.data;
+
+      return NULL;
+    }
+
+    void
+    check_connection(void) const
+    {
+      switch (xcb_connection_has_error(m_c.get())) {
+        case XCB_CONN_ERROR:
+          throw(connection_error(
+                XCB_CONN_ERROR, "XCB_CONN_ERROR"));
+
+        case XCB_CONN_CLOSED_EXT_NOTSUPPORTED:
+          throw(connection_error(XCB_CONN_CLOSED_EXT_NOTSUPPORTED,
+                                 "XCB_CONN_CLOSED_EXT_NOTSUPPORTED"));
+
+        case XCB_CONN_CLOSED_MEM_INSUFFICIENT:
+          throw(connection_error(XCB_CONN_CLOSED_MEM_INSUFFICIENT,
+                                 "XCB_CONN_CLOSED_MEM_INSUFFICIENT"));
+
+        case XCB_CONN_CLOSED_REQ_LEN_EXCEED:
+          throw(connection_error(XCB_CONN_CLOSED_REQ_LEN_EXCEED,
+                                 "XCB_CONN_CLOSED_REQ_LEN_EXCEED"));
+
+        case XCB_CONN_CLOSED_PARSE_ERR:
+          throw(connection_error(XCB_CONN_CLOSED_PARSE_ERR,
+                                 "XCB_CONN_CLOSED_PARSE_ERR"));
+
+        case XCB_CONN_CLOSED_INVALID_SCREEN:
+          throw(connection_error(XCB_CONN_CLOSED_INVALID_SCREEN,
+                                 "XCB_CONN_CLOSED_INVALID_SCREEN"));
+      };
+    }
+}; // class core
+
+} // namespace xpp
+
+#endif // XPP_CORE_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/cursor.hpp polybar-3.2.1/lib/xpp/include/xpp/cursor.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/cursor.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/cursor.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,142 @@
+#ifndef XPP_CURSOR_HPP
+#define XPP_CURSOR_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class cursor
+  : public xpp::generic::resource<Connection, xcb_cursor_t,
+                                  xpp::x::cursor, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_cursor_t,
+                                        xpp::x::cursor, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    cursor(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    cursor<Connection, Interfaces ...>
+    create(C && c,
+           xcb_pixmap_t source, xcb_pixmap_t mask,
+           uint16_t fore_red, uint16_t fore_green, uint16_t fore_blue,
+           uint16_t back_red, uint16_t back_green, uint16_t back_blue,
+           uint16_t x, uint16_t y)
+    {
+      return cursor(
+            std::forward<C>(c),
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::create_cursor(c, cursor,
+                                       source, mask,
+                                       fore_red, fore_green, fore_blue,
+                                       back_red, back_green, back_blue,
+                                       x, y);
+               },
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::free_cursor(c, cursor);
+               });
+    }
+
+    template<typename C>
+    static
+    cursor<Connection, Interfaces ...>
+    create_checked(C && c,
+                   xcb_pixmap_t source, xcb_pixmap_t mask,
+                   uint16_t fore_red, uint16_t fore_green, uint16_t fore_blue,
+                   uint16_t back_red, uint16_t back_green, uint16_t back_blue,
+                   uint16_t x, uint16_t y)
+    {
+      return cursor(
+            std::forward<C>(c),
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::create_cursor_checked(c, cursor,
+                                               source, mask,
+                                               fore_red, fore_green, fore_blue,
+                                               back_red, back_green, back_blue,
+                                               x, y);
+               },
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::free_cursor_checked(c, cursor);
+               });
+    }
+
+    template<typename C>
+    static
+    cursor<Connection, Interfaces ...>
+    create_glyph(C && c,
+                 xcb_font_t source_font, xcb_font_t mask_font,
+                 uint16_t source_char, uint16_t mask_char,
+                 uint16_t fore_red, uint16_t fore_green, uint16_t fore_blue,
+                 uint16_t back_red, uint16_t back_green, uint16_t back_blue)
+    {
+      return cursor(
+              std::forward<C>(c),
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::create_glyph_cursor(c, cursor,
+                                             source_font, mask_font,
+                                             source_char, mask_char,
+                                             fore_red, fore_green, fore_blue,
+                                             back_red, back_green, back_blue);
+               },
+               [](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::free_cursor(c, cursor);
+               });
+    }
+
+    template<typename C>
+    static
+    cursor<Connection, Interfaces ...>
+    create_glyph_checked(C && c,
+                         xcb_font_t source_font, xcb_font_t mask_font,
+                         uint16_t source_char, uint16_t mask_char,
+                         uint16_t fore_red, uint16_t fore_green, uint16_t fore_blue,
+                         uint16_t back_red, uint16_t back_green, uint16_t back_blue)
+    {
+      return cursor(
+              std::forward<C>(c),
+               [&](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::create_glyph_cursor_checked(c, cursor,
+                                                     source_font, mask_font,
+                                                     source_char, mask_char,
+                                                     fore_red, fore_green, fore_blue,
+                                                     back_red, back_green, back_blue);
+               },
+               [](Connection & c, const xcb_cursor_t & cursor)
+               {
+                 xpp::x::free_cursor_checked(c, cursor);
+               });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::cursor<Connection, Interfaces ...>>
+{
+  typedef xcb_cursor_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_CURSOR_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/drawable.hpp polybar-3.2.1/lib/xpp/include/xpp/drawable.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/drawable.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/drawable.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,35 @@
+#ifndef XPP_DRAWABLE_HPP
+#define XPP_DRAWABLE_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class drawable
+  : public xpp::generic::resource<Connection, xcb_drawable_t,
+                                  xpp::x::drawable, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_drawable_t,
+                                        xpp::x::drawable, Interfaces ...>;
+
+  public:
+    using base::base;
+    using base::operator=;
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::drawable<Connection, Interfaces ...>>
+{
+  typedef xcb_drawable_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_DRAWABLE_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/event.hpp polybar-3.2.1/lib/xpp/include/xpp/event.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/event.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/event.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,210 @@
+#ifndef XPP_EVENT_HPP
+#define XPP_EVENT_HPP
+
+#include <climits>
+#include <map>
+#include <vector>
+#include <unordered_map>
+
+#include "proto/x.hpp"
+
+#define MAX_PRIORITY UINT32_MAX
+
+namespace xpp {
+
+namespace event {
+
+namespace detail {
+
+class dispatcher {
+  public:
+    virtual ~dispatcher(void) {}
+    template<typename Event> void dispatch(const Event & e);
+}; // class dispatcher
+
+template<typename Event>
+class sink : virtual public dispatcher
+{
+  public:
+    virtual ~sink(void) {}
+    virtual void handle(const Event &) = 0;
+};
+
+} // namespace detail
+
+template<typename Event, typename ... Events>
+class sink
+  : public detail::sink<Event>
+  , public detail::sink<Events> ...
+{};
+
+template<typename Connection, typename ... Extensions>
+class registry
+  : public xpp::x::event::dispatcher<Connection>
+  , public Extensions::template event_dispatcher<Connection> ...
+{
+  public:
+    typedef unsigned int priority;
+
+    template<typename C>
+    explicit
+    registry(C && c)
+      : xpp::x::event::dispatcher<Connection>(std::forward<C>(c))
+      , Extensions::template event_dispatcher<Connection>(
+          std::forward<C>(c), c.template extension<Extensions>()) ...
+      , m_c(std::forward<C>(c))
+    {}
+
+    bool
+    dispatch(const std::shared_ptr<xcb_generic_event_t> & event) const
+    {
+      return dispatch<xpp::x::extension, Extensions ...>(event);
+    }
+
+    template<typename Event, typename ... Rest>
+    void
+    attach(priority p, sink<Event, Rest ...> * s)
+    {
+      attach<sink<Event, Rest ...>, Event, Rest ...>(p, s);
+    }
+
+    template<typename Event, typename ... Rest>
+    void
+    detach(priority p, sink<Event, Rest ...> * s)
+    {
+      detach<sink<Event, Rest ...>, Event, Rest ...>(p, s);
+    }
+
+  private:
+    typedef std::multimap<priority, detail::dispatcher *> priority_map;
+
+    Connection m_c;
+    std::unordered_map<uint8_t, priority_map> m_dispatchers;
+
+    template<typename Event>
+    uint8_t opcode(const xpp::x::extension &) const
+    {
+      return Event::opcode();
+    }
+
+    template<typename Event, typename Extension>
+    uint8_t opcode(const Extension & extension) const
+    {
+      return Event::opcode(extension);
+    }
+
+    template<typename Event>
+    uint8_t opcode(void) const
+    {
+      return opcode<Event>(m_c.template extension<typename Event::extension>());
+    }
+
+    template<typename Event>
+    void
+    handle(const Event & event) const
+    {
+      try {
+        for (auto & item : m_dispatchers.at(opcode<Event>())) {
+          item.second->dispatch(event);
+        }
+      } catch (...) {}
+    }
+
+    struct handler {
+      handler(const registry<Connection, Extensions ...> & registry)
+        : m_registry(registry)
+      {}
+
+      const registry<Connection, Extensions ...> & m_registry;
+
+      template<typename Event>
+      void
+      operator()(const Event & event) const
+      {
+        m_registry.handle(event);
+      }
+    };
+
+    template<typename Extension>
+    bool
+    dispatch(const std::shared_ptr<xcb_generic_event_t> & event) const
+    {
+      typedef const typename Extension::template event_dispatcher<Connection> & dispatcher;
+      return static_cast<dispatcher>(*this)(handler(*this), event);
+    }
+
+    template<typename Extension, typename Next, typename ... Rest>
+    bool
+    dispatch(const std::shared_ptr<xcb_generic_event_t> & event) const
+    {
+      dispatch<Extension>(event);
+      return dispatch<Next, Rest ...>(event);
+    }
+
+    template<typename Sink, typename Event>
+    void
+    attach(priority p, Sink * s)
+    {
+      attach(p, s, opcode<Event>());
+    }
+
+    template<typename Sink, typename Event, typename Next, typename ... Rest>
+    void
+    attach(priority p, Sink * s)
+    {
+      attach(p, s, opcode<Event>());
+      attach<Sink, Next, Rest ...>(p, s);
+    }
+
+    void attach(priority p, detail::dispatcher * d, uint8_t opcode)
+    {
+      m_dispatchers[opcode].emplace(p, d);
+    }
+
+    template<typename Sink, typename Event>
+    void
+    detach(priority p, Sink * s)
+    {
+      detach(p, s, opcode<Event>());
+    }
+
+    template<typename Sink, typename Event, typename Next, typename ... Rest>
+    void
+    detach(priority p, Sink * s)
+    {
+      detach(p, s, opcode<Event>());
+      detach<Sink, Next, Rest ...>(p, s);
+    }
+
+    void
+    detach(priority p, detail::dispatcher * d, uint8_t opcode)
+    {
+      try {
+        auto & prio_map = m_dispatchers.at(opcode);
+        const auto & prio_sink_pair = prio_map.equal_range(p);
+        for (auto it = prio_sink_pair.first; it != prio_sink_pair.second; ) {
+          if (d == it->second) {
+            it = prio_map.erase(it);
+          } else {
+            ++it;
+          }
+        }
+      } catch (...) {}
+    }
+
+}; // xpp::event::source
+
+} // namespace event
+
+} // namespace xpp
+
+template<typename Event>
+void xpp::event::detail::dispatcher::dispatch(const Event & e)
+{
+  auto event_sink = dynamic_cast<xpp::event::detail::sink<Event> *>(this);
+  if (event_sink != nullptr) {
+    event_sink->handle(e);
+  }
+}
+
+#endif // XPP_EVENT_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/flags.makefile polybar-3.2.1/lib/xpp/include/xpp/flags.makefile
--- polybar-3.2.1.orig/lib/xpp/include/xpp/flags.makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/flags.makefile	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,40 @@
+LIBS=x11 \
+     xcb \
+     xcb-icccm \
+     xcb-sync \
+     xcb-xf86dri \
+     xcb-xprint \
+     xcb-xinput \
+     xcb-shape \
+     xcb-shm \
+     xcb-render \
+     xcb-proto \
+     xcb-event \
+     xcb-xfixes \
+     xcb-xkb \
+     xcb-dri3 \
+     xcb-ewmh \
+     xcb-util \
+     xcb-renderutil \
+     xcb-xtest \
+     xcb-xevie \
+     xcb-keysyms \
+     xcb-image \
+     xcb-composite \
+     xcb-randr \
+     xcb-present \
+     xcb-xv \
+     xcb-aux \
+     xcb-record \
+     xcb-dpms \
+     xcb-glx \
+     xcb-atom \
+     xcb-damage \
+     xcb-screensaver \
+     xcb-xvmc \
+     xcb-res \
+     xcb-xinerama \
+     xcb-dri2
+
+CXXFLAGS=-std=c++11 -Wall -O0 $(shell pkg-config --cflags ${LIBS})
+LDFLAGS=$(shell pkg-config --libs ${LIBS})
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/fontable.hpp polybar-3.2.1/lib/xpp/include/xpp/fontable.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/fontable.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/fontable.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,35 @@
+#ifndef XPP_FONTABLE_HPP
+#define XPP_FONTABLE_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class fontable
+  : public xpp::generic::resource<Connection, xcb_fontable_t,
+                                  xpp::x::fontable, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_fontable_t,
+                                        xpp::x::fontable, Interfaces ...>;
+
+  public:
+    using base::base;
+    using base::operator=;
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::fontable<Connection, Interfaces ...>>
+{
+  typedef xcb_fontable_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_FONTABLE_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/font.hpp polybar-3.2.1/lib/xpp/include/xpp/font.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/font.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/font.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,74 @@
+#ifndef XPP_FONT_HPP
+#define XPP_FONT_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class font
+  : public xpp::generic::resource<Connection, xcb_font_t,
+                                  xpp::x::font, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_font_t,
+                                        xpp::x::font, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    font(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    font<Connection, Interfaces ...>
+    open(C && c, const std::string & name) noexcept
+    {
+      return font(std::forward<C>(c),
+                  [&](const Connection & c, const xcb_font_t & font)
+                  {
+                    xpp::x::open_font(c, font, name);
+                  },
+                  [&](const Connection & c, const xcb_font_t & font)
+                  {
+                    xpp::x::close_font(c, font);
+                  });
+    }
+
+    template<typename C>
+    static
+    font<Connection, Interfaces ...>
+    open_checked(C && c, const std::string & name)
+    {
+      return font(std::forward<C>(c),
+                  [&](const Connection & c, const xcb_font_t & font)
+                  {
+                    xpp::x::open_font_checked(c, font, name);
+                  },
+                  [&](const Connection & c, const xcb_font_t & font)
+                  {
+                    xpp::x::close_font_checked(c, font);
+                  });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::font<Connection, Interfaces ...>>
+{
+  typedef xcb_font_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_FONT_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/gcontext.hpp polybar-3.2.1/lib/xpp/include/xpp/gcontext.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/gcontext.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/gcontext.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,114 @@
+#ifndef XPP_GCONTEXT_HPP
+#define XPP_GCONTEXT_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class gcontext
+  : public xpp::generic::resource<Connection, xcb_gcontext_t,
+                                  xpp::x::gcontext, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_gcontext_t,
+                                        xpp::x::gcontext, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    gcontext(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    gcontext<Connection, Interfaces ...>
+    create(C && c, xcb_drawable_t drawable,
+           uint32_t value_mask, const uint32_t * value_list)
+    {
+      return gcontext(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::create_gc(c, gcontext, drawable, value_mask, value_list);
+          },
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::free_gc(c, gcontext);
+          });
+    }
+
+    template<typename C>
+    static
+    gcontext<Connection, Interfaces ...>
+    create_checked(C && c, xcb_drawable_t drawable,
+                   uint32_t value_mask, const uint32_t * value_list)
+    {
+      return gcontext(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::create_gc_checked(c, gcontext, drawable,
+                                      value_mask, value_list);
+          },
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::free_gc_checked(c, gcontext);
+          });
+    }
+
+    template<typename C>
+    static
+    gcontext<Connection, Interfaces ...>
+    copy(C && c, xcb_gcontext_t src_gc, uint32_t value_mask)
+    {
+      return gcontext(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::copy_gc(c, src_gc, gcontext, value_mask);
+          },
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::free_gc(c, gcontext);
+          });
+    }
+
+
+    template<typename C>
+    static
+    gcontext<Connection, Interfaces ...>
+    copy_checked(C && c, xcb_gcontext_t src_gc, uint32_t value_mask)
+    {
+      return gcontext(
+          std::forward<C>(c),
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::copy_gc_checked(c, src_gc, gcontext, value_mask);
+          },
+          [&](const Connection & c, const xcb_gcontext_t & gcontext)
+          {
+            xpp::x::free_gc_checked(c, gcontext);
+          });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::gcontext<Connection, Interfaces ...>>
+{
+  typedef xcb_gcontext_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_GCONTEXT_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/error.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/error.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/error.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/error.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,96 @@
+#ifndef XPP_GENERIC_ERROR_HPP
+#define XPP_GENERIC_ERROR_HPP
+
+#include <iostream> // shared_ptr
+#include <memory> // shared_ptr
+#include <xcb/xcb.h> // xcb_generic_error_t
+
+namespace xpp { namespace generic {
+
+class error_dispatcher {
+  public:
+    virtual
+      void operator()(const std::shared_ptr<xcb_generic_error_t> &) const = 0;
+};
+
+namespace detail {
+
+template<typename Object>
+void
+dispatch(const Object & object,
+         const std::shared_ptr<xcb_generic_error_t> & error,
+         std::true_type)
+{
+  static_cast<const xpp::generic::error_dispatcher &>(object)(error);
+}
+
+template<typename Object>
+void
+dispatch(const Object &,
+         const std::shared_ptr<xcb_generic_error_t> & error,
+         std::false_type)
+{
+  throw error;
+}
+
+} // namespace detail
+
+template<typename Object>
+void
+dispatch(const Object & object,
+         const std::shared_ptr<xcb_generic_error_t> & error)
+{
+  detail::dispatch(object,
+                   error,
+                   std::is_base_of<xpp::generic::error_dispatcher, Object>());
+}
+
+template<typename Derived, typename Error>
+class error
+  : public std::runtime_error
+{
+  public:
+    error(const std::shared_ptr<xcb_generic_error_t> & error)
+      : runtime_error(get_error_description(error.get()))
+      , m_error(error)
+    {}
+
+    virtual
+    ~error(void)
+    {}
+
+    virtual
+    operator const Error &(void) const
+    {
+      return reinterpret_cast<const Error &>(*m_error);
+    }
+
+    virtual
+    const Error &
+    operator*(void) const
+    {
+      return reinterpret_cast<const Error &>(*m_error);
+    }
+
+    virtual
+    Error *
+    operator->(void) const
+    {
+      return reinterpret_cast<Error * const>(m_error.get());
+    }
+
+  protected:
+    virtual
+    std::string
+    get_error_description(xcb_generic_error_t * error) const
+    {
+      return std::string(Derived::description())
+        + " (" + std::to_string(error->error_code) + ")";
+    }
+
+    std::shared_ptr<xcb_generic_error_t> m_error;
+}; // class error
+
+} } // xpp::generic
+
+#endif // XPP_GENERIC_ERROR_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/event.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/event.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/event.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/event.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,45 @@
+#ifndef XPP_GENERIC_EVENT_HPP
+#define XPP_GENERIC_EVENT_HPP
+
+#include <memory> // shared_ptr
+#include <xcb/xcb.h> // xcb_generic_event_t
+
+namespace xpp { namespace generic {
+
+template<typename Event>
+class event {
+  public:
+    event(const std::shared_ptr<xcb_generic_event_t> & event)
+      : m_event(event)
+    {}
+
+    virtual
+    ~event(void) {}
+
+    virtual
+    operator const Event &(void) const
+    {
+      return reinterpret_cast<const Event &>(*m_event);
+    }
+
+    virtual
+    const Event &
+    operator*(void) const
+    {
+      return reinterpret_cast<const Event &>(*m_event);
+    }
+
+    virtual
+    Event *
+    operator->(void) const
+    {
+      return reinterpret_cast<Event * const>(m_event.get());
+    }
+
+  protected:
+    std::shared_ptr<xcb_generic_event_t> m_event;
+}; // class event
+
+} } // namespace xpp::generic
+
+#endif // XPP_GENERIC_EVENT_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/extension.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/extension.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/extension.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/extension.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,59 @@
+#ifndef XPP_GENERIC_EXTENSION_HPP
+#define XPP_GENERIC_EXTENSION_HPP
+
+// #include <iostream>
+#include <xcb/xcb.h>
+
+namespace xpp { namespace generic {
+
+template<typename Derived, xcb_extension_t * Id>
+class extension
+{
+  public:
+    extension(xcb_connection_t * const c)
+      : m_c(c)
+    {
+      prefetch();
+    }
+
+    const xcb_query_extension_reply_t &
+    operator*(void) const
+    {
+      return *m_extension;
+    }
+
+    const xcb_query_extension_reply_t *
+    operator->(void) const
+    {
+      return m_extension;
+    }
+
+    operator const xcb_query_extension_reply_t *(void) const
+    {
+      return m_extension;
+    }
+
+    Derived &
+    get(void)
+    {
+      m_extension = xcb_get_extension_data(m_c, Id);
+      return static_cast<Derived &>(*this);
+    }
+
+    Derived &
+    prefetch(void)
+    {
+      xcb_prefetch_extension_data(m_c, Id);
+      return static_cast<Derived &>(*this);
+    }
+
+  private:
+    xcb_connection_t * m_c = nullptr;
+    // The result must not be freed.
+    // This storage is managed by the cache itself.
+    const xcb_query_extension_reply_t * m_extension = nullptr;
+}; // class extension
+
+} } // namespace xpp::generic
+
+#endif // XPP_GENERIC_EXTENSION_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/factory.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/factory.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/factory.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/factory.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,92 @@
+#ifndef XPP_GENERIC_FACTORY_HPP
+#define XPP_GENERIC_FACTORY_HPP
+
+#include <utility> // std::forward
+
+namespace xpp { namespace generic {
+
+namespace factory {
+
+template<typename ReturnType>
+class make_object
+{
+  public:
+    template<typename Connection, typename ... Parameter>
+    ReturnType
+    operator()(Connection &&, Parameter && ... parameter) const
+    {
+      return ReturnType { std::forward<Parameter>(parameter) ... };
+    }
+};
+
+template<typename ReturnType>
+class make_object_with_member
+{
+  public:
+    template<typename Member, typename Connection, typename ... Parameter>
+    ReturnType
+    operator()(Connection && c, Member && member, Parameter && ... parameter) const
+    {
+      return ReturnType { std::forward<Member>(member)
+                        , std::forward<Connection>(c)
+                        , std::forward<Parameter>(parameter) ...
+                        };
+    }
+};
+
+template<typename ReturnType>
+class make_object_with_connection
+{
+  public:
+    template<typename Connection, typename ... Parameter>
+    ReturnType
+    operator()(Connection && c, Parameter && ... parameter) const
+    {
+      return ReturnType { std::forward<Connection>(c)
+                        , std::forward<Parameter>(parameter) ...
+                        };
+    }
+};
+
+template<typename ReturnType>
+class make_fundamental {
+  public:
+    template<typename Connection, typename Member, typename ... Parameter>
+    ReturnType
+    operator()(Connection &&, Member && member) const
+    {
+      return std::forward<Member>(member);
+    }
+};
+
+template<typename Connection,
+         typename MemberType,
+         typename ReturnType,
+         typename ... Parameter>
+class make
+  : public std::conditional<
+      std::is_constructible<ReturnType, MemberType>::value,
+      make_fundamental<ReturnType>,
+      typename std::conditional<
+        std::is_constructible<ReturnType,
+                              MemberType,
+                              Connection,
+                              Parameter ...>::value,
+        make_object_with_member<ReturnType>,
+        typename std::conditional<
+          std::is_constructible<ReturnType,
+                                Connection,
+                                MemberType,
+                                Parameter ...>::value,
+          make_object_with_connection<ReturnType>,
+          make_object<ReturnType>
+        >::type
+      >::type
+    >::type
+{};
+
+} // namespace factory
+
+} } // xpp::generic
+
+#endif // XPP_GENERIC_FACTORY_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/input_iterator_adapter.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/input_iterator_adapter.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/input_iterator_adapter.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/input_iterator_adapter.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,163 @@
+#ifndef XPP_GENERIC_INPUT_ITERATOR_ADAPTER_HPP
+#define XPP_GENERIC_INPUT_ITERATOR_ADAPTER_HPP
+
+#include <utility>
+#include <iterator>
+#include <type_traits>
+
+#define GENERATE_HAS_MEMBER(member)                                               \
+                                                                                  \
+template<typename T, bool B>                                                      \
+class HasMember_##member {                                                        \
+  private:                                                                        \
+    using Yes = char[2];                                                          \
+    using  No = char[1];                                                          \
+                                                                                  \
+    struct Fallback { int member; };                                              \
+    struct Derived : T, Fallback {};                                              \
+                                                                                  \
+    template<typename U>                                                          \
+    static No& test(decltype(U::member)*);                                        \
+    template<typename U>                                                          \
+    static Yes& test(U*);                                                         \
+                                                                                  \
+  public:                                                                         \
+    static constexpr bool RESULT = sizeof(test<Derived>(nullptr)) == sizeof(Yes); \
+};                                                                                \
+                                                                                  \
+template<typename T>                                                              \
+class HasMember_##member<T, false> {                                              \
+  public:                                                                         \
+    static constexpr bool RESULT = false;                                         \
+};                                                                                \
+                                                                                  \
+template<typename T>                                                              \
+struct has_member_##member                                                        \
+  : public std::integral_constant<                                                \
+        bool,                                                                     \
+        HasMember_##member<T, std::is_class<T>::value>::RESULT                    \
+      >                                                                           \
+{};
+
+GENERATE_HAS_MEMBER(first)
+GENERATE_HAS_MEMBER(second)
+
+// namespace iterator {
+
+template<typename Iterator>
+struct value_iterator_base {
+  value_iterator_base(const Iterator & iterator)
+    : m_iterator(iterator)
+  {}
+
+  bool
+  operator==(const value_iterator_base & other)
+  {
+    return m_iterator == other.m_iterator;
+  }
+
+  bool
+  operator!=(const value_iterator_base & other)
+  {
+    return m_iterator != other.m_iterator;
+  }
+
+  void
+  operator++(void)
+  {
+    ++m_iterator;
+  }
+
+  template<typename Key, typename Value>
+  const Value &
+  get_value(const std::pair<Key, Value> & pair)
+  {
+    return pair.second;
+  }
+
+  template<typename Value>
+  const Value &
+  get_value(const Value & v)
+  {
+    return v;
+  }
+
+  Iterator m_iterator;
+};
+
+template<typename Iterator>
+struct value_iterator_pair
+  : public value_iterator_base<Iterator>
+  , public std::iterator<typename std::input_iterator_tag,
+                         // value_type
+                         typename Iterator::value_type::second_type,
+                         typename std::iterator_traits<Iterator>::difference_type,
+                         // pointer
+                         typename Iterator::value_type::second_type *,
+                         // reference
+                         const typename Iterator::value_type::second_type &>
+{
+  typedef value_iterator_base<Iterator> base;
+  using base::base;
+
+  const typename Iterator::value_type::second_type &
+  operator*(void)
+  {
+    return base::get_value(*base::m_iterator);
+  }
+};
+
+template<typename Iterator>
+struct value_iterator_integral
+  : public value_iterator_base<Iterator>
+  , public std::iterator<typename std::input_iterator_tag,
+                         typename std::iterator_traits<Iterator>::value_type,
+                         typename std::iterator_traits<Iterator>::difference_type,
+                         typename std::iterator_traits<Iterator>::pointer,
+                         typename std::iterator_traits<Iterator>::reference>
+{
+  typedef value_iterator_base<Iterator> base;
+  using base::base;
+
+  const typename Iterator::value_type &
+  operator*(void)
+  {
+    return base::get_value(*base::m_iterator);
+  }
+};
+
+template<typename Iterator>
+struct value_iterator
+  : public std::conditional<
+        has_member_first<typename Iterator::value_type>::value
+        && has_member_second<typename Iterator::value_type>::value,
+        value_iterator_pair<Iterator>,
+        value_iterator_integral<Iterator>
+      >::type
+{
+  typedef typename std::conditional<
+      has_member_first<typename Iterator::value_type>::value
+      && has_member_second<typename Iterator::value_type>::value,
+      value_iterator_pair<Iterator>,
+      value_iterator_integral<Iterator>
+    >::type base;
+  using base::base;
+};
+
+template<typename T, bool B = true>
+struct value_type {
+  typedef typename std::conditional<
+    has_member_second<typename T::value_type>::value,
+    typename T::value_type::second_type,
+    typename T::value_type>::type
+      type;
+};
+
+template<typename T>
+struct value_type<T, false> {
+  typedef typename std::remove_const<
+            typename std::remove_pointer<T>::type
+          >::type type;
+};
+
+#endif // XPP_GENERIC_INPUT_ITERATOR_ADAPTER_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/iterator_traits.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/iterator_traits.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/iterator_traits.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/iterator_traits.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,24 @@
+#ifndef XPP_GENERIC_ITERATOR_TRAITS_HPP
+#define XPP_GENERIC_ITERATOR_TRAITS_HPP
+
+namespace xpp {
+
+namespace generic {
+
+template<typename T>
+struct traits
+{
+  typedef T type;
+};
+
+template<typename Object>
+struct conversion_type
+{
+  using type = typename traits<Object>::type;
+};
+
+} // namespace generic
+
+}
+
+#endif // XPP_GENERIC_ITERATOR_TRAITS_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/reply_iterator.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/reply_iterator.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/reply_iterator.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/reply_iterator.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,376 @@
+#ifndef XPP_GENERIC_REPLY_ITERATOR_HPP
+#define XPP_GENERIC_REPLY_ITERATOR_HPP
+
+#include <cstdlib> // size_t
+#include <memory>
+#include <stack>
+#include <xcb/xcb.h> // xcb_str_*
+#include "factory.hpp"
+#include "signature.hpp"
+#include "iterator_traits.hpp"
+
+#define NEXT_TEMPLATE \
+  void (&Next)(XcbIterator *)
+
+#define NEXT_SIGNATURE \
+  xpp::generic::signature<void (XcbIterator *), Next>
+
+#define SIZEOF_TEMPLATE \
+  int (&SizeOf)(const void *)
+
+#define SIZEOF_SIGNATURE \
+  xpp::generic::signature<int (const void *), SizeOf>
+
+#define GETITERATOR_TEMPLATE \
+  XcbIterator (&GetIterator)(const Reply *)
+
+#define GETITERATOR_SIGNATURE \
+  xpp::generic::signature<XcbIterator (const Reply *), GetIterator>
+
+#define ACCESSOR_TEMPLATE \
+  Data * (&Accessor)(const Reply *)
+
+#define ACCESSOR_SIGNATURE \
+  xpp::generic::signature<Data * (const Reply *), Accessor>
+
+#define LENGTH_TEMPLATE \
+  int (&Length)(const Reply *)
+
+#define LENGTH_SIGNATURE \
+  xpp::generic::signature<int (const Reply *), Length>
+
+namespace xpp {
+
+namespace generic {
+
+template<typename Data>
+class get
+{
+  public:
+    Data
+    operator()(Data * const data)
+    {
+      return *data;
+    }
+};
+
+template<>
+class get<xcb_str_t>
+{
+  public:
+    std::string
+    operator()(xcb_str_t * const data)
+    {
+      return std::string(xcb_str_name(data),
+                         xcb_str_name_length(data));
+    }
+};
+
+namespace detail
+{
+
+template<typename F>
+struct function_traits;
+
+template<typename Signature, Signature& S>
+struct function_traits<signature<Signature, S>> : function_traits<Signature> {};
+
+template<typename R, typename... Args>
+struct function_traits<R(*)(Args...)> : function_traits<R(Args...)> {};
+
+template<typename R, typename... Args>
+struct function_traits<R(Args...)>
+{
+  using result_type = R;
+  const static std::size_t arity = sizeof...(Args);
+
+  template <std::size_t I>
+  struct argument
+  {
+    static_assert(I < arity, "invalid argument index");
+    using type = typename std::tuple_element<I, std::tuple<Args...>>::type;
+  };
+};
+}
+
+// iterator for variable size data fields
+
+template<typename ... Types>
+class iterator;
+
+template<typename Connection,
+         typename Object,
+         typename NextTemplate,
+         NextTemplate& Next,
+         typename SizeOfTemplate,
+         SizeOfTemplate& SizeOf,
+         typename GetIteratorTemplate,
+         GetIteratorTemplate& GetIterator>
+class iterator<Connection,
+               Object,
+               xpp::generic::signature<NextTemplate, Next>,
+               xpp::generic::signature<SizeOfTemplate, SizeOf>,
+               xpp::generic::signature<GetIteratorTemplate, GetIterator>>
+  : public std::iterator<typename std::input_iterator_tag,
+                         Object,
+                         typename std::size_t,
+                         Object *,
+                         const Object &>
+{
+  protected:
+    using self = iterator<Connection,
+                          Object,
+                          xpp::generic::signature<NextTemplate, Next>,
+                          xpp::generic::signature<SizeOfTemplate, SizeOf>,
+                          xpp::generic::signature<GetIteratorTemplate, GetIterator>>;
+
+    using get_iterator_traits = detail::function_traits<GetIteratorTemplate>;
+    using const_reply_ptr = typename get_iterator_traits::template argument<0>::type;
+    using Reply = typename std::remove_pointer<typename std::remove_const<const_reply_ptr>::type>::type;
+    using XcbIterator = typename get_iterator_traits::result_type;
+
+    Connection m_c;
+    std::shared_ptr<Reply> m_reply;
+    std::stack<std::size_t> m_lengths;
+    XcbIterator m_iterator;
+
+  public:
+    iterator(void) {}
+
+    template<typename C>
+    iterator(C && c, const std::shared_ptr<Reply> & reply)
+      : m_c(std::forward<C>(c))
+      , m_reply(reply)
+      , m_iterator(GetIterator(reply.get()))
+    {}
+
+    bool
+    operator==(const iterator & other)
+    {
+      return m_iterator.rem == other.m_iterator.rem;
+    }
+
+    bool
+    operator!=(const iterator & other)
+    {
+      return ! (*this == other);
+    }
+
+    auto
+    operator*(void) -> decltype(get<Object>()(this->m_iterator.data))
+    {
+      return get<Object>()(m_iterator.data);
+    }
+
+    // prefix
+    self &
+    operator++(void)
+    {
+      m_lengths.push(SizeOf(m_iterator.data));
+      Next(&m_iterator);
+      return *this;
+    }
+
+    // postfix
+    self
+    operator++(int)
+    {
+      auto copy = *this;
+      ++(*this);
+      return copy;
+    }
+
+    // prefix
+    self &
+    operator--(void)
+    {
+      typedef typename std::remove_pointer<decltype(m_iterator.data)>::type data_t;
+      if (m_lengths.empty()) {
+        data_t * data = m_iterator.data;
+        data_t * prev = data - m_lengths.top();
+        m_lengths.pop();
+        m_iterator.index = (char *)m_iterator.data - (char *)prev;
+        m_iterator.data = prev;
+        ++m_iterator.rem;
+      }
+      return *this;
+    }
+
+    // postfix
+    self
+    operator--(int)
+    {
+      auto copy = *this;
+      --(*this);
+      return copy;
+    }
+
+    template<typename C>
+    static
+    self
+    begin(C && c, const std::shared_ptr<Reply> & reply)
+    {
+      return self { std::forward<C>(c), reply };
+    }
+
+    template<typename C>
+    static
+    self
+    end(C && c, const std::shared_ptr<Reply> & reply)
+    {
+      auto it = self { std::forward<C>(c), reply };
+      it.m_iterator.rem = 0;
+      return it;
+    }
+}; // class iterator
+
+// iterator for fixed size data fields
+
+template<typename Connection,
+         typename Object,
+         typename AccessorTemplate,
+         AccessorTemplate& Accessor,
+         typename LengthTemplate,
+         LengthTemplate& Length>
+class iterator<Connection,
+               Object,
+               signature<AccessorTemplate, Accessor>,
+               signature<LengthTemplate, Length>>
+  : public std::iterator<typename std::input_iterator_tag,
+                         Object,
+                         typename std::size_t,
+                         Object *,
+                         const Object &>
+{
+  protected:
+
+    using accessor_traits = detail::function_traits<AccessorTemplate>;
+    using Data = typename std::remove_pointer<typename accessor_traits::result_type>::type;
+    using const_reply_ptr = typename accessor_traits::template argument<0>::type;
+    using Reply = typename std::remove_pointer<typename std::remove_const<const_reply_ptr>::type>::type;
+
+    using data_t = typename std::conditional<std::is_void<Data>::value,
+      typename xpp::generic::conversion_type<Object>::type, Data>::type;
+    using make = xpp::generic::factory::make<Connection, data_t, Object>;
+
+    Connection m_c;
+    std::size_t m_index = 0;
+    std::shared_ptr<Reply> m_reply;
+
+  public:
+    typedef iterator<Connection,
+                     Object,
+                     signature<AccessorTemplate, Accessor>,
+                     signature<LengthTemplate, Length>>
+                       self;
+
+    iterator(void) {}
+
+    template<typename C>
+    iterator(C && c,
+             const std::shared_ptr<Reply> & reply,
+             std::size_t index)
+      : m_c(c)
+      , m_index(index)
+      , m_reply(reply)
+    {
+      if (std::is_void<Data>::value) {
+        m_index /= sizeof(data_t);
+      }
+    }
+
+    bool operator==(const iterator & other)
+    {
+      return m_index == other.m_index;
+    }
+
+    bool operator!=(const iterator & other)
+    {
+      return ! (*this == other);
+    }
+
+    Object operator*(void)
+    {
+      return make()(m_c, static_cast<data_t *>(Accessor(m_reply.get()))[m_index]);
+    }
+
+    // prefix
+    self & operator++(void)
+    {
+      ++m_index;
+      return *this;
+    }
+
+    // postfix
+    self operator++(int)
+    {
+      auto copy = *this;
+      ++(*this);
+      return copy;
+    }
+
+    // prefix
+    self & operator--(void)
+    {
+      --m_index;
+      return *this;
+    }
+
+    // postfix
+    self operator--(int)
+    {
+      auto copy = *this;
+      --(*this);
+      return copy;
+    }
+
+    template<typename C>
+    static
+    self
+    begin(C && c, const std::shared_ptr<Reply> & reply)
+    {
+      return self { std::forward<C>(c), reply, 0 };
+    }
+
+    template<typename C>
+    static
+    self
+    end(C && c, const std::shared_ptr<Reply> & reply)
+    {
+      return self { std::forward<C>(c),
+                    reply,
+                    static_cast<std::size_t>(Length(reply.get())) };
+    }
+}; // class iterator
+
+template<typename Connection, typename Reply, typename Iterator>
+class list {
+  private:
+    // before public part, to make decltype in begin() & end() work!
+    Connection m_c;
+    std::shared_ptr<Reply> m_reply;
+
+  public:
+    template<typename C>
+    list(C && c, const std::shared_ptr<Reply> & reply)
+      : m_c(std::forward<C>(c)), m_reply(reply)
+    {}
+
+    auto
+    begin(void) -> decltype(Iterator::begin(this->m_c, this->m_reply))
+    {
+      return Iterator::begin(m_c, m_reply);
+    }
+
+    auto
+    end(void) -> decltype(Iterator::end(this->m_c, this->m_reply))
+    {
+      return Iterator::end(m_c, m_reply);
+    }
+}; // class list
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_GENERIC_REPLY_ITERATOR_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/request.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/request.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/request.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/request.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,129 @@
+#ifndef XPP_GENERIC_REQUEST_HPP
+#define XPP_GENERIC_REQUEST_HPP
+
+#include <array>
+#include <memory>
+#include <cstdlib>
+#include <xcb/xcb.h>
+#include "error.hpp"
+#include "signature.hpp"
+
+#define REPLY_TEMPLATE \
+  typename Reply, \
+  typename Cookie, \
+  Reply *(&ReplyFunction)(xcb_connection_t *, Cookie, xcb_generic_error_t **)
+
+#define REPLY_SIGNATURE \
+  xpp::generic::signature<Reply *(xcb_connection_t *, \
+                                  Cookie, \
+                                  xcb_generic_error_t **), \
+                          ReplyFunction>
+
+#define REPLY_COOKIE_TEMPLATE \
+  typename ... CookieParameter, \
+  Cookie(&CookieFunction)(CookieParameter ...)
+
+#define REPLY_COOKIE_SIGNATURE \
+  xpp::generic::signature<Cookie(CookieParameter ...), CookieFunction>
+
+namespace xpp { namespace generic {
+
+template<typename Connection, typename Dispatcher>
+void
+check(Connection && c, const xcb_void_cookie_t & cookie)
+{
+  xcb_generic_error_t * error =
+    xcb_request_check(std::forward<Connection>(c), cookie);
+  if (error) {
+    dispatch(std::forward<Connection>(c),
+             std::shared_ptr<xcb_generic_error_t>(error, std::free));
+  }
+}
+
+struct checked_tag {};
+struct unchecked_tag {};
+
+template<typename ... Types>
+class reply;
+
+template<typename Derived,
+         typename Connection,
+         typename Check,
+         REPLY_TEMPLATE,
+         REPLY_COOKIE_TEMPLATE>
+class reply<Derived,
+            Connection,
+            Check,
+            REPLY_SIGNATURE,
+            REPLY_COOKIE_SIGNATURE>
+{
+  public:
+    template<typename C, typename ... Parameter>
+    reply(C && c, Parameter && ... parameter)
+      : m_c(std::forward<C>(c))
+      , m_cookie(Derived::cookie(std::forward<C>(c),
+                                 std::forward<Parameter>(parameter) ...))
+    {}
+
+    operator bool(void)
+    {
+      return m_reply.operator bool();
+    }
+
+    const Reply &
+    operator*(void)
+    {
+      return *get();
+    }
+
+    Reply *
+    operator->(void)
+    {
+      return get().get();
+    }
+
+    const std::shared_ptr<Reply> &
+    get(void)
+    {
+      if (! m_reply) {
+        m_reply = get(Check());
+      }
+      return m_reply;
+    }
+
+    template<typename ... Parameter>
+    static
+    Cookie
+    cookie(Parameter && ... parameter)
+    {
+      return CookieFunction(std::forward<Parameter>(parameter) ...);
+    }
+
+  protected:
+    Connection m_c;
+    Cookie m_cookie;
+    std::shared_ptr<Reply> m_reply;
+
+    std::shared_ptr<Reply>
+    get(checked_tag)
+    {
+      xcb_generic_error_t * error = nullptr;
+      auto reply = std::shared_ptr<Reply>(ReplyFunction(m_c, m_cookie, &error),
+                                          std::free);
+      if (error) {
+        dispatch(m_c, std::shared_ptr<xcb_generic_error_t>(error, std::free));
+      }
+      return reply;
+    }
+
+    std::shared_ptr<Reply>
+    get(unchecked_tag)
+    {
+      return std::shared_ptr<Reply>(ReplyFunction(m_c, m_cookie, nullptr),
+                                    std::free);
+    }
+};
+
+} } // namespace xpp::generic
+
+#endif // XPP_GENERIC_REQUEST_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/resource.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/resource.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/resource.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/resource.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,142 @@
+#ifndef XPP_GENERIC_RESOURCE_HPP
+#define XPP_GENERIC_RESOURCE_HPP
+
+#include <iostream> // std::{hex,dec}
+#include <memory> // std::shared_ptr
+#include "iterator_traits.hpp"
+
+#include <xcb/xcb.h> // xcb_generate_id
+
+namespace xpp {
+
+namespace generic {
+
+namespace detail {
+
+template<typename Connection, typename Resource, typename ResourceId,
+         template<typename, typename> class ... Interfaces>
+class interfaces
+  : public Interfaces<interfaces<Connection, Resource, ResourceId, Interfaces ...>,
+                      Connection> ...
+{
+  public:
+    const ResourceId &
+    resource(void) const
+    {
+      return *static_cast<const Resource &>(*this);
+    }
+
+    Connection
+    connection(void) const
+    {
+      return static_cast<const Resource &>(*this).connection();
+    }
+}; // class interfaces
+
+}
+
+template<typename Connection, typename ResourceId,
+         template<typename, typename> class ... Interfaces>
+class resource
+  : public detail::interfaces<Connection,
+                              resource<Connection, ResourceId, Interfaces ...>,
+                              ResourceId, Interfaces ...>
+{
+  protected:
+    using self = resource<Connection, ResourceId, Interfaces ...>;
+
+    Connection m_c;
+    // reference counting for Resource object
+    std::shared_ptr<ResourceId> m_resource;
+
+    resource(Connection c)
+      : m_c(c)
+    {}
+
+    template<typename C, typename Create, typename Destroy>
+    static
+    self
+    make(C && c, Create create, Destroy destroy)
+    {
+      self resource(std::forward<C>(c));
+
+      auto xid = xcb_generate_id(std::forward<C>(c));
+
+      // class create before instatiating the shared_ptr
+      // create might fail and throw an error, hence shared_ptr would hold an
+      // invalid xid, causing possibly another exception in destroy()
+      // when create() throws, then the shared_ptr will not be created
+      create(std::forward<C>(c), xid);
+
+      resource.m_resource =
+        std::shared_ptr<ResourceId>(new ResourceId(xid),
+          [&](ResourceId * r)
+          {
+            destroy(resource.m_c, *r);
+            delete r;
+          });
+
+      return resource;
+    }
+
+  public:
+    template<typename C>
+    resource(C && c, const ResourceId & resource_id)
+      : m_c(std::forward<C>(c))
+      , m_resource(std::make_shared<ResourceId>(resource_id))
+    {}
+
+    resource(const resource<Connection, ResourceId, Interfaces ...> & other)
+      : m_c(other.m_c)
+      , m_resource(other.m_resource)
+    {}
+
+    virtual
+    void
+    operator=(const resource<Connection, ResourceId, Interfaces ...> & other)
+    {
+      m_c = other.m_c;
+      m_resource = other.m_resource;
+    }
+
+    virtual
+    void
+    operator=(const ResourceId & resource)
+    {
+      m_resource = std::make_shared<ResourceId>(resource);
+    }
+
+    virtual
+    const ResourceId &
+    operator*(void) const
+    {
+      return *m_resource;
+    }
+
+    virtual
+    operator const ResourceId &(void) const
+    {
+      return *m_resource;
+    }
+
+    Connection
+    connection(void) const
+    {
+      return m_c;
+    }
+}; // class resource
+
+template<typename Connection, typename ResourceId,
+         template<typename, typename> class ... Interfaces>
+std::ostream &
+operator<<(std::ostream & os,
+           const resource<Connection, ResourceId, Interfaces ...> & resource)
+{
+  return os << std::hex << "0x" << *resource << std::dec;
+}
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_GENERIC_RESOURCE_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic/signature.hpp polybar-3.2.1/lib/xpp/include/xpp/generic/signature.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic/signature.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic/signature.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,16 @@
+#ifndef XPP_GENERIC_SIGNATURE_HPP
+#define XPP_GENERIC_SIGNATURE_HPP
+
+#define SIGNATURE(NAME) \
+  xpp::generic::signature<decltype(NAME), NAME>
+
+namespace xpp
+{
+  namespace generic
+  {
+    template<typename Signature, Signature & S>
+    class signature;
+  }
+}
+
+#endif // XPP_GENERIC_SIGNATURE_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/generic.hpp polybar-3.2.1/lib/xpp/include/xpp/generic.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/generic.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/generic.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,15 @@
+#ifndef XPP_GENERIC_HPP
+#define XPP_GENERIC_HPP
+
+#include "generic/error.hpp"
+#include "generic/event.hpp"
+#include "generic/factory.hpp"
+#include "generic/request.hpp"
+#include "generic/resource.hpp"
+#include "generic/extension.hpp"
+#include "generic/signature.hpp"
+#include "generic/reply_iterator.hpp"
+#include "generic/iterator_traits.hpp"
+#include "generic/input_iterator_adapter.hpp"
+
+#endif // XPP_GENERIC_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/Makefile polybar-3.2.1/lib/xpp/include/xpp/Makefile
--- polybar-3.2.1.orig/lib/xpp/include/xpp/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/Makefile	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,25 @@
+CXXFLAGS=-std=c++11 -Wall -O3
+
+HPPSRCS=$(shell find . -maxdepth 1 -name '*.hpp')
+HPPOBJS=$(HPPSRCS:%.hpp=%.hpp.gch)
+
+all: ${DIRS} ${HPPOBJS}
+
+%.hpp.gch: %.hpp
+	${CXX} ${CXXFLAGS} -MMD -c $<
+
+-include $(HPPSRCS:%.hpp=%.d)
+include flags.makefile
+
+version: ${LIBS}
+	@echo -e "\nGCC version:"
+	@gcc -v 2>&1
+
+${LIBS}:
+	@printf "%-20s" "$@:"
+	@pkg-config --modversion $@
+
+clean:
+	rm -f ${HPPOBJS}
+
+.PHONY: clean version
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/pixmap.hpp polybar-3.2.1/lib/xpp/include/xpp/pixmap.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/pixmap.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/pixmap.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,78 @@
+#ifndef XPP_PIXMAP_HPP
+#define XPP_PIXMAP_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class pixmap
+  : public xpp::generic::resource<Connection, xcb_pixmap_t,
+                                  xpp::x::pixmap, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_pixmap_t,
+                                        xpp::x::pixmap, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    pixmap(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    pixmap<Connection, Interfaces ...>
+    create(C && c, uint8_t depth, xcb_drawable_t drawable,
+                   uint16_t width, uint16_t height)
+    {
+      return pixmap(
+        std::forward<C>(c),
+        [&](const Connection & c, const xcb_pixmap_t & pixmap)
+        {
+          xpp::x::create_pixmap(c, depth, pixmap, drawable, width, height);
+        },
+        [&](const Connection & c, const xcb_pixmap_t & pixmap)
+        {
+          xpp::x::free_pixmap(c, pixmap);
+        });
+    }
+
+    template<typename C>
+    static
+    pixmap<Connection, Interfaces ...>
+    create_checked(C && c, uint8_t depth, xcb_drawable_t drawable,
+                   uint16_t width, uint16_t height)
+    {
+      return pixmap(
+        std::forward<C>(c),
+        [&](const Connection & c, const xcb_pixmap_t & pixmap)
+        {
+          xpp::x::create_pixmap_checked(c, depth, pixmap, drawable, width, height);
+        },
+        [&](const Connection & c, const xcb_pixmap_t & pixmap)
+        {
+          xpp::x::free_pixmap_checked(c, pixmap);
+        });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::pixmap<Connection, Interfaces ...>>
+{
+  typedef xcb_pixmap_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_PIXMAP_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/proto/.gitignore polybar-3.2.1/lib/xpp/include/xpp/proto/.gitignore
--- polybar-3.2.1.orig/lib/xpp/include/xpp/proto/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/proto/.gitignore	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1 @@
+*.hpp
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/valueparam.hpp polybar-3.2.1/lib/xpp/include/xpp/valueparam.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/valueparam.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/valueparam.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,50 @@
+#ifndef X_VALUEPARAM_HPP
+#define X_VALUEPARAM_HPP
+
+#include <map>
+#include <vector>
+
+namespace xpp {
+
+class valueparam {
+  public:
+    valueparam &
+    set(const uint32_t & bit, const uint32_t & value)
+    {
+      m_has_changed = true;
+      m_values_map[bit] = value;
+      return *this;
+    }
+
+    uint32_t
+    mask(void)
+    {
+      return m_mask;
+    }
+
+    uint32_t * const
+    values(void)
+    {
+      if (m_has_changed) {
+        m_values.clear();
+      }
+
+      for (auto & item : m_values_map) {
+        m_values.push_back(item.second);
+      }
+
+      m_has_changed = false;
+
+      return m_values.data();
+    }
+
+  private:
+    bool m_has_changed = true;
+    uint32_t m_mask = 0;
+    std::vector<uint32_t> m_values;
+    std::map<uint32_t, uint32_t> m_values_map;
+};
+
+} // namespace xpp
+
+#endif // X_VALUEPARAM_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/window.hpp polybar-3.2.1/lib/xpp/include/xpp/window.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/window.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/window.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,90 @@
+#ifndef XPP_WINDOW_HPP
+#define XPP_WINDOW_HPP
+
+#include "proto/x.hpp"
+#include "generic/resource.hpp"
+
+namespace xpp {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+class window
+  : public xpp::generic::resource<Connection, xcb_window_t,
+                                  xpp::x::window, Interfaces ...>
+{
+  protected:
+    using base = xpp::generic::resource<Connection, xcb_window_t,
+                                        xpp::x::window, Interfaces ...>;
+
+    template<typename C, typename Create, typename Destroy>
+    window(C && c, Create && create, Destroy && destroy)
+      : base(base::make(std::forward<C>(c),
+                        std::forward<Create>(create),
+                        std::forward<Destroy>(destroy)))
+    {}
+
+  public:
+    using base::base;
+    using base::operator=;
+
+    template<typename C>
+    static
+    window<Connection, Interfaces ...>
+    create(C && c, uint8_t depth, xcb_window_t parent,
+                   int16_t x, int16_t y, uint16_t width, uint16_t height,
+                   uint16_t border_width,
+                   uint16_t _class, xcb_visualid_t visual,
+                   uint32_t value_mask, const uint32_t * value_list)
+    {
+      return window(
+        std::forward<C>(c),
+        [&](const Connection & c, const xcb_window_t & window)
+        {
+          xpp::x::create_window(c, depth, window, parent,
+                                        x, y, width, height, border_width,
+                                        _class, visual,
+                                        value_mask, value_list);
+        },
+        [&](const Connection & c, const xcb_window_t & window)
+        {
+          xpp::x::destroy_window(c, window);
+        });
+    }
+
+    template<typename C>
+    static
+    window<Connection, Interfaces ...>
+    create_checked(C && c, uint8_t depth, xcb_window_t parent,
+                   int16_t x, int16_t y, uint16_t width, uint16_t height,
+                   uint16_t border_width,
+                   uint16_t _class, xcb_visualid_t visual,
+                   uint32_t value_mask, const uint32_t * value_list)
+    {
+      return window(
+        std::forward<C>(c),
+        [&](const Connection & c, const xcb_window_t & window)
+        {
+          xpp::x::create_window_checked(c, depth, window, parent,
+                                        x, y, width, height, border_width,
+                                        _class, visual,
+                                        value_mask, value_list);
+        },
+        [&](const Connection & c, const xcb_window_t & window)
+        {
+          xpp::x::destroy_window_checked(c, window);
+        });
+    }
+};
+
+namespace generic {
+
+template<typename Connection, template<typename, typename> class ... Interfaces>
+struct traits<xpp::window<Connection, Interfaces ...>>
+{
+  typedef xcb_window_t type;
+};
+
+} // namespace generic
+
+} // namespace xpp
+
+#endif // XPP_WINDOW_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/include/xpp/xpp.hpp polybar-3.2.1/lib/xpp/include/xpp/xpp.hpp
--- polybar-3.2.1.orig/lib/xpp/include/xpp/xpp.hpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/include/xpp/xpp.hpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,19 @@
+#ifndef XPP_HPP
+#define XPP_HPP
+
+#include "generic.hpp"
+
+#include "atom.hpp"
+#include "colormap.hpp"
+#include "cursor.hpp"
+#include "drawable.hpp"
+#include "font.hpp"
+#include "fontable.hpp"
+#include "gcontext.hpp"
+#include "pixmap.hpp"
+#include "window.hpp"
+
+#include "event.hpp"
+#include "connection.hpp"
+
+#endif // XPP_HPP
diff -Nuar polybar-3.2.1.orig/lib/xpp/README.md polybar-3.2.1/lib/xpp/README.md
--- polybar-3.2.1.orig/lib/xpp/README.md	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/README.md	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,313 @@
+# xpp - A C++11 RAII wrapper for XCB
+
+## Synopsis
+
+XPP is a header only C++11
+[RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)
+wrapper around [X protocol C-language Binding
+(XCB)](http://xcb.freedesktop.org). Pointers to dynamically allocated memory,
+such as events and errors are wrapped in std::shared_ptr.
+
+Furthermore, interfaces for connection and resource types are provided to
+facilitate the creation of custom classes. For convenience, a connection class
+and several basic resource type classes are readily available.
+
+XPP makes widespread use of the
+[Curiously Recurring Template Pattern (CRTP)](https://en.wikibooks.org/wiki/More_C++_Idioms/Curiously_Recurring_Template_Pattern)
+to avoid overhead through dynamic dispatch. Hence, most interfaces are
+implicitly defined.
+
+## Prerequisites
+
+  * Python 2
+  * GCC >= 4.8 (or Clang >= 3.3, untested)
+  * libxcb
+
+## Quick Start
+
+```
+  git clone https://github.com/jrk-/xpp
+  cd xpp
+  make
+  make examples
+  cd src/examples
+  for demo in demo_*; do ./${demo}; done
+```
+
+## Documentation
+
+### General
+
+The bindings can be generated by calling `make` in the top level directory. If
+this fails, check the [`XCBGEN`](include/proto/Makefile#L38) and
+[`PROTODIR`](include/proto/Makefile#L39) variables in
+[include/proto/Makefile](include/proto/Makefile). These need to point to the `xcbgen`
+python package and the xml protocol description respectively.
+
+Once the bindings are generated they can be used by including
+[include/xpp.hpp](include/xpp.hpp). If an extensions is required, it needs to be
+included additionally. For example, the RandR extension is available through
+`proto/randr.hpp`, the Damage extension through `proto/damage.hpp`, etc.
+
+Recent (and working) examples can be found in [src/examples](src/examples).
+To compile them, call `make examples` in the `xpp` directory or just `make` in
+[src/examples](src/examples).
+
+### Requests
+
+Requests obey this naming scheme: `xpp:: ExtensionName :: RequestName`.
+
+##### Examples:
+
+Core X protocol:
+`MapWindow`: `xcb_map_window{,_checked}` -> `xpp::x::map_window{,_checked}`
+`InternAtom`: `xcb_intern_atom{,_checked}` -> `xpp::x::intern_atom{,_unchecked}`
+
+RandR protocol:
+`SelectInput`: `xcb_randr_select_input{,_checked}` -> `xpp::randr::select_input{,_checked}`
+`QueryVersion`: `xcb_randr_query_version{,_unchecked}` -> `xpp::randr::query_version{,_unchecked}`
+
+##### Default Parameter
+
+All `xcb_timestamp_t` parameters are alternatively available with a default
+value of `XCB_TIME_CURRENT_TIME`.
+
+##### Parameter Lists
+
+Requests which take a list of values as parameters can be used with any STL
+container by passing in Iterators. Example:
+
+```
+std::string string_example = "example string";
+// std::list<char> list_example = { 'a', 'b', 'c' };
+// std::map<int, char> map_example = { {0, 'a'}, {1, 'b'}, {2, 'c'} };
+xpp::x::change_property_checked(c, XCB_PROP_MODE_REPLACE, window,
+                                atom, XCB_ATOM_STRING, 8,
+                                string_example.begin(), string_example.end());
+                                // list_example.begin(), list_example.end());
+                                // for associative containers the value (std::pair<..>::second_type) will be used
+                                // map_example.begin(), map_example.end());
+```
+
+### Replies
+
+XCB returns replies only when they are explicitely queried. With XPP this is not
+necessary anymore, because the operators for accessing the reply are overloaded.
+
+For example, getting the reply for the `InternAtom` request is as simple as this:
+
+```
+auto reply = xpp::x::intern_atom(connection, true, "MY_ATOM_NAME");
+// do some other stuff ..
+// latency hiding is still effective, because the call to
+// xcb_intern_atom_reply happens but now in operator->()
+xcb_atom_t atom = reply->atom;
+```
+
+#### Member Accessors
+
+##### Simple Types
+
+Primitive types like `xcb_window_t`, `xcb_atom_t`, etc. can be accessed either
+directly through the overloaded `operator->()` or via a method which has the
+same name as the member. These methods are templated with a default template
+type of the native type. Any type which is default constructible from the native
+type or a connection and the native type can be specified as template argument.
+
+Examples:
+
+```
+xcb_window_t w1 = reply->member;
+xcb_window_t w2 = reply.member(); // default template parameter is xcb_window_t
+xpp::window w3 = reply.member<xpp::window>();
+```
+
+##### List Types
+
+Lists (e.g. the result for `QueryTree`) are accessible through iterators. The
+value type is templated, with the default being the native data type.
+
+Example:
+
+```
+auto tree = xpp::x::query_tree(c, window);
+
+// default template type: xcb_window_t
+for (auto && child : tree.children()) {
+  // child has type xcb_window_t
+}
+
+// xpp::window is constructible with a connection and xcb_window_t
+// other types which are default-constructible with either the value type
+// (e.g.  xcb_window_t) or a connection & the value type are possible, too
+for (auto && child : tree.children<xpp::window>()) {
+  // child has type xpp::window
+}
+```
+
+Caveat: Some requests (in particular `GetProperty`) return an untyped array of
+bytes (`void *`). To access the desired data type, a template type must be
+specified. For constructible types a type trait must be implemented, like so:
+
+```
+struct my_type {
+  my_type(const xcb_window_t &);
+  // ..
+};
+
+namespace xpp { namespace generic {
+struct traits<my_type> {
+  typedef xcb_atom_t type;
+};
+}; }; // namespace xpp::generic
+```
+
+### Errors
+
+XCB offers four different variants of request functions.
+
+##### Requests without a reply:
+
+* Error delivered through event queue: `xcb_void_cookie_t xcb_request(...)`
+
+* Error can be checked immediately with `xcb_request_check(xcb_connection_t *, xcb_void_cookie_t)`: `xcb_void_cookie_t xcb_request_checked(...)`
+
+##### Requests with reply:
+
+* Error can be checked when getting the reply:
+`xcb_request_reply_t * xcb_request_reply(xcb_connection_t *, xcb_request_cookie_t, xcb_generic_error_t **)`:
+`xcb_request_cookie_t xcb_request(...)`
+
+* Error delivered through event queue: `xcb_request_cookie_t xcb_request_unchecked(...)`
+
+For more information on this, refer to [xcb-requests (3)](http://www.x.org/releases/current/doc/man/man3/xcb-requests.3.xhtml).
+
+With xpp errors are either thrown as `std::shared_ptr<xcb_generic_error_t>` or
+typed as `xpp:: extension ::error:: error_type`, e.g. `xpp::x::error::value`.
+
+The latter are based upon `xpp::generic::error` (which inherits from
+`std::runtime_error`) and come with a textual error description which is
+accessible through the `what()` method.
+
+For typed errors it is necessary to use a connection class which implements the
+appropriate error dispatching. The supplied `xpp::connection` class already does
+this. If no error dispatcher are available (e.g. when used with
+`xcb_connection_t *`), then a simply `std::shared_ptr<xcb_generic_error_t>`
+will be thrown.
+
+### Events
+
+Events returned by the event producing methods (`wait_for_event`,
+`poll_for_event`, etc.) from `xpp::core` and `xpp::connection` are encapsulated
+as `std::shared_ptr<xcb_generic_event_t>`.
+
+For additional convenience typed events are available. An event type is based on
+`xpp::generic::event`. The general structure for a typed event is
+
+`xpp::` Extension `::event::` EventName
+
+Examples:
+
+```
+xpp::x::event::key_press
+xpp::randr::event::notify
+xpp::damage::event::notify
+```
+
+Events can be converted from `std::shared_ptr<xcb_generic_event_t>` to a typed
+event by either using an event dispatcher functor (e.g.
+`xpp::x::event::dispatcher`) or by using the event registry described below.
+
+##### Registry
+
+The event registry `xpp::event::registry<Connection, Extensions ...>` can be
+used to connect events and event handlers.
+
+First, a registry object for the desired `Connection` type and `Extensions` is
+necessary.
+
+Then, arbitrary objects, which implement the `xpp::event::sink<..>` interface
+need to be attached for event handling by calling the `attach()` method.
+It takes two parameters. The first one specifies the priority, in case there are
+more than one event handler for this event. Handlers with lower priorities are
+called first. The second one is a pointer to an object which implements the
+`xpp::event::sink<..>` interface.
+
+For a detailed example, take a look at this [demo](src/examples/demo_01.cpp).
+
+### Interfaces
+
+Interfaces for creating custom types are available.
+
+##### <a name="interface-connection"></a>Connection
+
+For every extension a "connection" interface, called
+`xpp:: ExtensionName ::interface<typename Derived, typename Connection>`
+is available.
+
+These encapsulate every request for a particular extension. The `Derived`
+template parameter specifies the class which wants to derive from the interface.
+The `Derived` class must provide a method `Connection connection();`.
+
+Examples:
+
+```
+xpp::x::interface<typename Derived, typename Connection>
+xpp::randr::interface<typename Derived, typename Connection>
+xpp::damage::interface<typename Derived, typename Connection>
+etc.
+```
+
+For a customizable default implementation, take a look at the `xpp::connection`
+class described [here](#default-type-connection).
+
+##### Resources
+
+In addition, interfaces for basic resource types like `xcb_window_t`,
+`xcb_atom_t`, `xcb_gcontext_t`, etc. are available.
+
+Again, the naming scheme follows the format
+`xpp:: ExtensionName :: XidType <typename Derived, typename Connection>`
+
+Despite the `connection()` method described [here](#interface-connection),
+`Derived` needs to implement a `resource()` method which returns a xid which
+will be passed as parameter to the encapsulated requests.
+
+Examples:
+
+```
+xpp::x::window<typename Derived, typename Connection>
+xpp::randr::output<typename Derived, typename Connection>
+xpp::render::glyphset<typename Derived, typename Connection>
+etc.
+```
+
+### Default Types
+
+##### <a name="default-type-connection"></a>Connection
+
+`xpp::connection<Extensions ...>` provides a default
+implementation of the [core connection methods](include/core.hpp), the core
+X protocol and error handling facilities. In addition, it is implicitly
+convertible to `xcb_connection_t *`, hence it can be used seamlessly with XCB
+functions. The connection can be augmented with additional extension methods, by
+specifying the desired extensions as template parameters.
+
+Example:
+
+`typedef xpp::connection<xpp::randr::extension, xpp::damage::extension> my_connection;`
+
+##### Resources
+
+For the basic resource types like `Drawable`, `Window`, `Pixmap`, `Atom`,
+`Colormap`, `Cursor`, `Font`, `Fontable` and `GContext` wrapper types exist.
+They are named `xpp::drawable`, `xpp::window`, etc.
+
+Each is based upon xpp::generic::resource and provides the core X protocol
+interface for the encapsulated resource type. If the resource can be acquired
+from the X server (e.g. with `CreateWindow`) then a named constructor is
+available (e.g. `create_window` for `xpp::window`).
+
+Resources acquired through the named constructors are reference counted. When
+their lifetime expires, the resource handle will automatically be freed on the
+server. No call to destroy or free functions is necessary.
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/examples/demo_01.cpp polybar-3.2.1/lib/xpp/src/examples/demo_01.cpp
--- polybar-3.2.1.orig/lib/xpp/src/examples/demo_01.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/examples/demo_01.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,138 @@
+// This demo will allow the user to click on a window, grab the keyboard on it
+// and then print every key press and release event. Will exit when Escape is
+// pressed
+
+#include <iostream>
+
+#include <X11/Xlib.h> // XKeysymToString
+#include <X11/keysym.h> // XK_Escape
+#include <X11/cursorfont.h> // XC_cross
+
+#include "../xpp.hpp"
+
+// global variable to indicate whether the event loop should exit
+bool g_quit = false;
+
+// typedefs for convenience
+namespace x {
+  typedef xpp::connection<> connection;
+  typedef xpp::event::registry<connection &> registry;
+
+  typedef xpp::font<connection &> font;
+  typedef xpp::cursor<connection &> cursor;
+  typedef xpp::window<connection &> window;
+
+  typedef xpp::x::event::key_press<connection &> key_press;
+  typedef xpp::x::event::key_release<connection &> key_release;
+  typedef xpp::x::event::button_press<connection &> button_press;
+};
+
+// The event handler class
+// Implements the xpp::event::sink<..> interface with all events we are
+// interested in as template parameters
+template<typename Connection>
+class key_printer
+  : public xpp::event::sink<x::key_press, x::key_release, x::button_press>
+{
+  public:
+    template<typename C>
+    key_printer(C && c)
+      : m_c(std::forward<C>(c))
+    {}
+
+    // xpp::event::sink<x::key_press>::handle(...) interface
+    void handle(const x::key_press & e)
+    {
+      auto kbd_mapping = m_c.get_keyboard_mapping(e->detail, 1);
+      // take the first value from the kbd_mapping list
+      // This might throw, but for simplicity, no error handling here
+      auto keysym = *kbd_mapping.keysyms().begin();
+
+      if (keysym == XK_Escape) {
+        std::cerr << "quitting" << std::endl;
+        // parameter has a default value: XCB_TIME_CURRENT_TIME
+        m_c.ungrab_keyboard();
+        g_quit = true;
+      } else {
+        std::cerr << "key press: " << XKeysymToString(keysym) << std::endl;
+      }
+    }
+
+    // xpp::event::sink<x::key_release>::handle(...) interface
+    void handle(const x::key_release & e)
+    {
+      auto kbd_mapping = m_c.get_keyboard_mapping(e->detail, 1);
+      auto keysym = *kbd_mapping.keysyms().begin();
+      std::cerr << "key release: " << XKeysymToString(keysym) << std::endl;
+    }
+
+    // xpp::event::sink<x::button_press>::handle(...) interface
+    void handle(const x::button_press & e)
+    {
+      m_c.ungrab_pointer(XCB_TIME_CURRENT_TIME);
+
+      // event & reply accessors have a default template parameter, the c-type
+      // Usable with any type which is constructible from the c-type or
+      // connection + c-type
+      // xcb_window_t grab_window = e.event();
+      x::window grab_window = e.event<x::window>();
+
+      if (e->event == e->root) {
+        // xpp::window, etc. are assignable with the c-type
+        grab_window = e.child();
+        // xpp::window, etc. are implicitly convertible to c-type
+        auto translate = grab_window.translate_coordinates(grab_window, 1, 1);
+        grab_window = translate->child;
+      }
+
+      *m_c.grab_keyboard(true, grab_window,
+                         XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
+
+      std::cerr << "Grabbed " << grab_window
+                << ". Press Escape to quit." << std::endl;
+    }
+
+  private:
+    Connection m_c;
+};
+
+int main(int, char **)
+{
+  try {
+    // xpp::connection is implicitly convertible to xcb_connection_t *
+    // Hence, it can be used with all xcb_* c functions.
+    // However, this is not demonstrated here.
+    x::connection connection;
+    x::registry registry(connection);
+
+    key_printer<x::connection &> key_printer(connection);
+    registry.attach(0, &key_printer);
+
+    x::font font = x::font::open_checked(connection, "cursor");
+
+    // x::font, etc. is implicitly convertible to xcb_font_t
+    x::cursor cursor = x::cursor::create_glyph_checked(connection, font, font,
+        XC_cross, XC_cross + 1, 0, 0, 0, 0xffff, 0xffff, 0xffff);
+
+    *connection.grab_pointer(false, connection.root(),
+                             XCB_EVENT_MASK_BUTTON_PRESS,
+                             XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
+                             XCB_NONE, cursor);
+                             // default value for time = XCB_TIME_CURRENT_TIME);
+
+    std::cerr << "Please click on a window" << std::endl;
+
+    while (! g_quit) {
+      connection.flush();
+      registry.dispatch(connection.wait_for_event());
+    }
+
+  } catch (const std::exception & error) {
+    std::cerr << "Exception (std::exception) in "
+              << __FILE__ << " @ line " << __LINE__ << ", what(): "
+              << error.what() << std::endl;
+    std::exit(EXIT_FAILURE);
+  }
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/examples/demo_02.cpp polybar-3.2.1/lib/xpp/src/examples/demo_02.cpp
--- polybar-3.2.1.orig/lib/xpp/src/examples/demo_02.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/examples/demo_02.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,229 @@
+#include <iostream>
+
+#include "../xpp.hpp"
+#include "../proto/randr.hpp"
+#include "../proto/damage.hpp"
+#include "../proto/render.hpp"
+
+// typedefs for convenience
+namespace x {
+  typedef xpp::connection<xpp::randr::extension,
+                          xpp::damage::extension,
+                          xpp::render::extension>
+                            connection;
+
+  typedef xpp::event::registry<connection &,
+                               xpp::randr::extension,
+                               xpp::damage::extension,
+                               xpp::render::extension>
+                                 registry;
+
+  typedef xpp::font<connection &> font;
+  typedef xpp::cursor<connection &> cursor;
+  typedef xpp::window<connection &> window;
+  typedef xpp::window<xcb_connection_t *> xcb_window;
+};
+
+int main(int, char **)
+{
+  x::connection connection;
+  x::registry registry(connection);
+
+  // Print out all available font paths
+  auto && paths = connection.get_font_path().path();
+  std::cerr << "paths "
+            << "(length: " << std::distance(paths.begin(), paths.end()) << "):"
+            << std::endl;
+  for (auto && path : paths) {
+    std::cerr << "path [" << path.length() << "]: " << path << std::endl;
+  }
+  std::cerr << std::endl;
+
+  // Print out all available fonts
+  auto && fonts = connection.list_fonts(8, 1, "*").names();
+  std::cerr << "fonts "
+            << "(length: " << std::distance(fonts.begin(), fonts.end()) << "):"
+            << std::endl;
+  for (auto && name : fonts) {
+    std::cerr << "font [" << name.length() << "]: " << name << std::endl;
+  }
+  std::cerr << std::endl;
+
+  // Print all windows and their subwindows
+  auto tree = connection.root<x::window>().query_tree();
+  std::cerr << "children: " << std::endl;
+  for (auto && child : tree.children<x::xcb_window>()) {
+    std::cerr << child << " ";
+    auto siblings = child.query_tree().children();
+    auto siblings_length = std::distance(siblings.begin(), siblings.end());
+    if (siblings_length > 0) {
+      std::cerr << std::hex << "[" << siblings_length
+                << " sibling" << (siblings_length > 1 ? "s" : "") << ": ";
+      for (auto && sibling : siblings) {
+        std::cerr << "0x" << sibling << (--siblings_length > 0 ? ", " : "");
+      }
+      std::cerr << std::dec << "]" << std::endl;
+    } else {
+      std::cerr << "[no siblings]" << std::endl;
+    }
+  }
+  std::cerr << std::endl;
+
+  // Creates an atom called "XPP_STRING_PROPERTY_DEMO" with a string property
+  // "xpp is working" on the root window
+  // check with `xprop -root XPP_STRING_PROPERTY_DEMO`
+  try {
+    auto my_string_atom =
+      xpp::x::intern_atom(connection, false, "XPP_STRING_PROPERTY_DEMO");
+
+    std::string my_string("xpp is working!");
+
+    std::cerr << "atom for \"XPP_STRING_PROPERTY_DEMO\": "
+              << my_string_atom.atom() << std::endl;
+
+    auto atom_name = connection.get_atom_name(my_string_atom.atom());
+    std::cerr << "atom name: " << atom_name.name() << std::endl;;
+
+    connection.change_property_checked(
+        XCB_PROP_MODE_REPLACE, connection.root(),
+        my_string_atom.atom(), XCB_ATOM_STRING, 8,
+        // using Iterator begin + end here
+        my_string.begin(), my_string.end());
+
+    // this will deliberately fail because window = 0
+    // However, the previous call to change_property succeeded,
+    // so everything is just fine
+    connection.change_property_checked( XCB_PROP_MODE_REPLACE, 0,
+        my_string_atom.atom(), XCB_ATOM_STRING, 8,
+        // using length() & c_str()
+        my_string.length(), my_string.c_str());
+
+  } catch (const std::exception & e) {
+    std::cerr << "change property failed: " << e.what() << std::endl;
+  }
+  std::cerr << std::endl;
+
+  // Get the _NET_CLIENT_LIST_STACKING property
+  // If an error occurs, it will be thrown only when trying to access the reply
+  std::string _net_client_list_stacking = "_NET_CLIENT_LIST_STACKING";
+  auto net_client_list_stacking_atom =
+    connection.intern_atom(false, _net_client_list_stacking);
+  auto net_client_list_stacking = connection.get_property(
+      false, connection.root(), net_client_list_stacking_atom.atom(),
+      XCB_ATOM_WINDOW, 0, UINT32_MAX);
+
+  try {
+    std::cerr << _net_client_list_stacking << " (xcb_window_t):" << std::hex;
+    for (auto && w : net_client_list_stacking.value<xcb_window_t>()) {
+      std::cerr << " 0x" << w;
+    }
+    std::cerr << std::dec << std::endl;
+
+    std::cerr << _net_client_list_stacking << " (x::window):";
+    for (auto && w : net_client_list_stacking.value<x::window>()) {
+      std::cerr << " " << w;
+    }
+    std::cerr << std::endl;
+
+    std::cerr << _net_client_list_stacking << " (x::xcb_window):";
+    for (auto && w : net_client_list_stacking.value<x::xcb_window>()) {
+      std::cerr << " " << w;
+    }
+    std::cerr << std::endl;
+
+  } catch (const std::exception & e) {
+    std::cerr << "Could not get " << _net_client_list_stacking << " property: "
+              << e.what() << std::endl;
+  }
+  std::cerr << std::endl;
+
+  // Randr needs query_version to work properly in subsequent calls
+  // If methods are ambiguous (like query_version, then the extension interface
+  // can be accessed through "extension_name()" (e.g. randr() or damage())
+  connection.randr().query_version(XCB_RANDR_MAJOR_VERSION,
+                                   XCB_RANDR_MINOR_VERSION);
+
+  connection.select_input_checked(connection.root(), XCB_RANDR_NOTIFY);
+
+  const auto & randr_ext = connection.extension<xpp::randr::extension>();
+
+  std::cerr << "RandR Extension" << std::endl;
+  std::cerr << "\tfirst_event: " << (int)randr_ext->first_event << std::endl;
+  std::cerr << "\tfirst_error: " << (int)randr_ext->first_error << std::endl;
+
+  const auto & damage_ext = connection.extension<xpp::damage::extension>();
+
+  std::cerr << "Damage Extension" << std::endl;
+  std::cerr << "\tfirst_event: " << (int)damage_ext->first_event << std::endl;
+  std::cerr << "\tfirst_error: " << (int)damage_ext->first_error << std::endl;
+
+  std::cerr << std::endl;
+
+  try {
+    // Produces XCB_RANDR_BAD_OUTPUT error
+    auto output_info = connection.get_output_info(-1);
+    output_info.get();
+  } catch (const std::exception & e) {
+    std::cerr << "get_output_info error: " << e.what() << std::endl;
+  }
+
+  try {
+    // Produces XCB_RANDR_BAD_CRTC error
+    auto crtc_info = connection.get_crtc_info(-1);
+    crtc_info.get();
+  } catch (const std::exception & e) {
+    std::cerr << "get_crtc_info error: " << e.what() << std::endl;
+  }
+
+  // Produces XCB_RANDR_BAD_OUTPUT error in event queue
+  auto output_info = connection.get_output_info_unchecked(-1);
+  output_info.get();
+
+  // Produces XCB_RANDR_BAD_CRTC error in event queue
+  auto crtc_info = connection.get_crtc_info_unchecked(-1);
+  crtc_info.get();
+
+  try {
+    // XCB_VALUE error
+    connection.change_output_property_checked(-1, -1, -1, 0, 0, 0, nullptr);
+  } catch (const std::exception & e) {
+    std::cerr << "change_output_property error: " << e.what() << std::endl;
+  }
+
+  // XCB_VALUE error in event queue
+  connection.change_output_property(-1, -1, -1, 0, 0, 0, nullptr);
+
+  try {
+    // XCB_RENDER_PICT_FORMAT error
+    auto pict_index_values = connection.query_pict_index_values(-1);
+    pict_index_values.get();
+  } catch (const std::exception & e) {
+    std::cerr << "query_pict_index_values error: " << e.what() << std::endl;
+  }
+
+  try {
+    // XCB_RENDER_PICTURE error
+    connection.change_picture_checked(-1, 0, nullptr);
+  } catch (const std::exception & e) {
+    std::cerr << "change_picture error: " << e.what() << std::endl;
+  }
+
+  // XCB_RENDER_PICT_FORMAT error in event queue
+  auto pict_index_values = connection.query_pict_index_values_unchecked(-1);
+  pict_index_values.get();
+
+  // XCB_RENDER_PICTURE error in event queue
+  connection.change_picture(-1, 0, nullptr);
+
+  // Poll the event queue a couple of times to get the errors
+  for (int i = 0; i < 5; ++i) {
+    connection.flush();
+    try {
+      registry.dispatch(connection.wait_for_event());
+    } catch (const std::exception & e) {
+      std::cerr << "std::exception in event queue: " << e.what() << std::endl;
+    }
+  }
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/examples/Makefile polybar-3.2.1/lib/xpp/src/examples/Makefile
--- polybar-3.2.1.orig/lib/xpp/src/examples/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/examples/Makefile	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,14 @@
+include ../../include/flags.makefile
+
+CXXFLAGS+=-g
+CXXFLAGS+=-Wextra
+
+CPPSRCS=$(shell find . -name '*.cpp')
+EXAMPLES=${CPPSRCS:./%.cpp=%}
+
+all: ${EXAMPLES}
+
+clean:
+	rm -f ${EXAMPLES}
+
+.PHONY: clean
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/callable.cpp polybar-3.2.1/lib/xpp/src/tests/callable.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/callable.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/callable.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,83 @@
+// compile with `g++ -std=c++11 test.cpp`
+#include <iostream>
+
+#define CALLABLE(FUNCTION) callable<decltype(FUNCTION), FUNCTION>
+
+template<typename Signature, Signature & S>
+struct callable;
+
+template<typename Return,
+         typename ... Args, Return (&Function)(Args ...)>
+struct callable<Return(Args ...), Function> {
+  Return operator()(Args ... args)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    return Function(args ...);
+  }
+};
+
+template<typename ... Arguments>
+class one_size_fits_them_all;
+
+// A generic template
+template<typename T, typename U, typename V,
+         typename F1, typename F2, typename F3>
+class one_size_fits_them_all<T, U, V, F1, F2, F3>
+{
+  public:
+    one_size_fits_them_all(void)
+    {
+      std::cerr << "generic one_size_fits_them_all" << std::endl
+                << __PRETTY_FUNCTION__ << std::endl << std::endl;
+      F1()();
+      F2()();
+      F3()();
+      std::cerr << std::endl;
+    }
+};
+
+// A specialized template
+template<typename T, typename Callable>
+class one_size_fits_them_all<T, int, int, void, void, Callable>
+{
+  public:
+    one_size_fits_them_all(void)
+    {
+      std::cerr << "specialized one_size_fits_them_all" << std::endl
+                << __PRETTY_FUNCTION__ << std::endl << std::endl;
+      Callable()();
+      std::cerr << std::endl;
+    }
+};
+
+void f1(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+void f2(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+void f3(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+int main(int argc, char ** argv)
+{
+  // generic template
+  auto generic = one_size_fits_them_all<
+    int, int, int, CALLABLE(f1), CALLABLE(f2), CALLABLE(f3)>();
+
+  // specialized template
+  auto specialized_int = one_size_fits_them_all<
+    int, int, int, void, void, CALLABLE(f1)>();
+
+  // specialized template
+  auto specialized_double = one_size_fits_them_all<
+    double, int, int, void, void, CALLABLE(f3)>();
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/error_test.cpp polybar-3.2.1/lib/xpp/src/tests/error_test.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/error_test.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/error_test.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,497 @@
+#include <iostream>
+#include <string>
+
+#include <xcb/xcb.h>
+
+#include "../event.hpp"
+#include "../core/value_iterator.hpp"
+#include "../core/connection.hpp"
+#include "../core/extension.hpp"
+#include "../core/error.hpp"
+
+#include "../request.hpp"
+#include "../request_ng.hpp"
+
+#define CHECKED_REQUEST(NAME) \
+  decltype(NAME ## _reply), NAME ## _reply, \
+  decltype(NAME), NAME
+
+#define UNCHECKED_REQUEST(NAME) \
+  decltype(NAME ## _reply), NAME ## _reply, \
+  decltype(NAME ## _unchecked), NAME ## _unchecked
+
+namespace xpp { namespace generic {
+
+// class get_screen_info_checked
+//   : public checked_reply_request<xpp::connection<xpp::extension::randr>,
+//                                  xpp::extension::randr,
+//                                  CHECKED_REQUEST(xcb_randr_get_screen_info)>
+// {
+//   public:
+//     typedef checked_reply_request<xpp::connection<xpp::extension::randr>,
+//                                   xpp::extension::randr,
+//                                   CHECKED_REQUEST(xcb_randr_get_screen_info)>
+//                                     base;
+//     using base::base;
+// };
+
+// class get_screen_info_unchecked
+//   : public unchecked_reply_request<UNCHECKED_REQUEST(xcb_randr_get_screen_info)>
+// {
+//   public:
+//     typedef unchecked_reply_request<UNCHECKED_REQUEST(xcb_randr_get_screen_info)>
+//                                     base;
+//     using base::base;
+// };
+
+// template<typename NoThrow = void>
+// class get_screen_info
+//   : public std::conditional<std::is_same<NoThrow, std::nothrow_t>::value,
+//                             get_screen_info_unchecked,
+//                             get_screen_info_checked>::type
+// {
+//   public:
+//     typedef typename std::conditional<
+//       std::is_same<NoThrow, std::nothrow_t>::value,
+//       get_screen_info_unchecked,
+//       get_screen_info_checked>::type
+//         base;
+//     using base::base;
+// };
+
+/*
+class query_tree_checked
+  : public checked_reply_request<xpp::connection<>, void,
+                                 CHECKED_REQUEST(xcb_query_tree)>
+{
+  public:
+    typedef checked_reply_request<xpp::connection<>, void,
+                                  CHECKED_REQUEST(xcb_query_tree)>
+                                    base;
+    using base::base;
+};
+
+class query_tree_unchecked
+  : public unchecked_reply_request<UNCHECKED_REQUEST(xcb_query_tree)>
+{
+  public:
+    typedef unchecked_reply_request<UNCHECKED_REQUEST(xcb_query_tree)>
+                                    base;
+    using base::base;
+};
+
+template<typename NoThrow = void>
+class query_tree
+  : public std::conditional<std::is_same<NoThrow, std::nothrow_t>::value,
+                            query_tree_unchecked,
+                            query_tree_checked
+    >::type
+{
+  public:
+    typedef typename std::conditional<
+      std::is_same<NoThrow, std::nothrow_t>::value,
+      query_tree_unchecked,
+      query_tree_checked
+        >::type
+        base;
+    using base::base;
+};
+*/
+
+// class query_tree_checked
+//   : public xpp::generic::checked::request<xpp::extension::x,
+//                                              CHECKED_REQUEST(xcb_query_tree)>
+// {
+//   typedef xpp::generic::checked::request<xpp::extension::x,
+//                                             CHECKED_REQUEST(xcb_query_tree)>
+//                                               base;
+//   using base::base;
+// };
+
+// class map_window_checked
+//   : public ::test::generic::checked::request<xpp::extension::x,
+//                                              CHECKED_REQUEST(xcb_map_window)>
+// {
+//   typedef ::test::generic::checked::request<xpp::extension::x,
+//                                             CHECKED_REQUEST(xcb_map_window)>
+//                                               base;
+//   using base::base;
+// };
+
+// class get_screen_info
+//   // : public wrapper<xpp::connection<xpp::extension::randr>, xpp::extension::randr,
+//   : public wrapper<xpp::connection<xpp::extension::randr>,
+//                    xpp::extension::randr, xpp::extension::x,
+//                    decltype(xcb_randr_get_screen_info_reply), xcb_randr_get_screen_info_reply,
+//                    decltype(xcb_randr_get_screen_info), xcb_randr_get_screen_info>
+// {
+//   public:
+//     // typedef wrapper<xpp::extension::randr,
+//     typedef wrapper<xpp::connection<xpp::extension::randr>,
+//                     xpp::extension::randr, xpp::extension::x,
+//                     decltype(xcb_randr_get_screen_info_reply), xcb_randr_get_screen_info_reply,
+//                     decltype(xcb_randr_get_screen_info), xcb_randr_get_screen_info>
+//                       base;
+//     using base::base;
+// };
+
+// class query_tree
+//   // : public wrapper<xpp::extension::x,
+//   : public wrapper<xpp::connection<>,
+//                    xpp::extension::x, xpp::extension::x,
+//                    decltype(xcb_query_tree_reply), xcb_query_tree_reply,
+//                    decltype(xcb_query_tree), xcb_query_tree>
+// {
+//   public:
+//     typedef wrapper<xpp::connection<>,
+//                     xpp::extension::x, xpp::extension::x,
+//                     decltype(xcb_query_tree_reply), xcb_query_tree_reply,
+//                     decltype(xcb_query_tree), xcb_query_tree>
+//                       base;
+//     using base::base;
+// };
+
+// class dpms_capable
+//   // : public wrapper<// xpp::connection<xpp::extension::dpms>, xpp::extension::dpms,
+//   : public wrapper<xpp::extension::dpms,
+//                    decltype(xcb_dpms_capable_reply), xcb_dpms_capable_reply,
+//                    decltype(xcb_dpms_capable), xcb_dpms_capable>
+// {
+//   public:
+//     // typedef wrapper<// xpp::connection<xpp::extension::dpms>, xpp::extension::dpms,
+//     typedef wrapper<xpp::extension::dpms,
+//                     decltype(xcb_dpms_capable_reply), xcb_dpms_capable_reply,
+//                     decltype(xcb_dpms_capable), xcb_dpms_capable>
+//                       base;
+//     using base::base;
+// };
+
+// class render_query_pict_index_values
+//   // : public wrapper<// xpp::connection<xpp::extension::render>, xpp::extension::render,
+//   : public wrapper<xpp::extension::render,
+//                    decltype(xcb_render_query_pict_index_values_reply), xcb_render_query_pict_index_values_reply,
+//                    decltype(xcb_render_query_pict_index_values), xcb_render_query_pict_index_values>
+// {
+//   public:
+//     // typedef wrapper<// xpp::connection<xpp::extension::render>, xpp::extension::render,
+//     typedef wrapper<xpp::extension::render,
+//                     decltype(xcb_render_query_pict_index_values_reply), xcb_render_query_pict_index_values_reply,
+//                     decltype(xcb_render_query_pict_index_values), xcb_render_query_pict_index_values>
+//                       base;
+//     using base::base;
+// };
+
+// class render_query_filters
+//   // : public wrapper<xpp::extension::render,
+//   : public wrapper<xpp::connection<xpp::extension::render>,
+//                    xpp::extension::render, xpp::extension::x,
+//                    decltype(xcb_render_query_filters_reply), xcb_render_query_filters_reply,
+//                    decltype(xcb_render_query_filters), xcb_render_query_filters>
+// {
+//   public:
+//     // typedef wrapper<xpp::extension::render,
+//     typedef wrapper<xpp::connection<xpp::extension::render>,
+//                     xpp::extension::render, xpp::extension::x,
+//                     decltype(xcb_render_query_filters_reply), xcb_render_query_filters_reply,
+//                     decltype(xcb_render_query_filters), xcb_render_query_filters>
+//                       base;
+//     using base::base;
+// };
+
+// template<>
+// class query_tree<xcb_connection_t>
+//   : public wrapper<xcb_connection_t, void,
+//                    decltype(xcb_query_tree_reply), xcb_query_tree_reply,
+//                    decltype(xcb_query_tree), xcb_query_tree>
+// {
+//   public:
+//     typedef wrapper<xcb_connection_t, void,
+//                     decltype(xcb_query_tree_reply), xcb_query_tree_reply,
+//                     decltype(xcb_query_tree), xcb_query_tree>
+//                       base;
+//     using base::base;
+// };
+
+}; }; // namespace xpp::generic
+
+void error_dispatcher(xcb_generic_error_t * error)
+{
+  switch (error->error_code) {
+    case XCB_WINDOW:
+      xcb_window_error_t * e = (xcb_window_error_t *)error;
+      std::cerr << "XCB_WINDOW with bad_value: " << e->bad_value << std::endl;
+      // throw xpp::error::generic<XCB_WINDOW, xcb_window_error_t>(error);
+      throw xpp::generic::error<XCB_WINDOW, xcb_window_error_t>(error);
+      // throw xpp::x::window_error(error);
+      break;
+  }
+}
+
+void check_error_direct(xcb_generic_error_t * error)
+{
+  if (error) {
+    std::cerr << "error code: " << (int)error->error_code << std::endl;
+    try {
+    error_dispatcher(error);
+    } catch (const std::exception & exception) {
+      std::cerr << "caught exception: " << exception.what() << std::endl;
+    }
+  } else {
+    std::cerr << "no error occurred" << std::endl;
+  }
+}
+
+void check_error_event(xcb_connection_t * c)
+{
+  xcb_generic_event_t * event = xcb_poll_for_event(c);
+  xcb_flush(c);
+  if (event) {
+    uint8_t response = event->response_type & ~0x80;
+    std::cerr << "event response: " << (int)response << std::endl;
+    check_error_direct((xcb_generic_error_t *)event);
+  } else {
+    std::cerr << "no event available" << std::endl;
+  }
+}
+
+void
+map_window(xcb_connection_t * c, xcb_window_t window)
+{
+  xcb_map_window(c, window);
+}
+
+template<typename Extension>
+void
+map_window(const Extension & e, xcb_connection_t * c, xcb_window_t window)
+{
+  typedef typename Extension::error_dispatcher dispatcher;
+  dispatcher(/* e->first_error */)(
+      xcb_request_check(c, xcb_map_window_checked(c, window)));
+}
+
+template<typename ... Parameters>
+void
+map_window(const xpp::connection<Parameters ...> & c, xcb_window_t window)
+{
+  map_window(static_cast<const xpp::extension::x &>(c), c, window);
+}
+
+int main(int argc, char ** argv)
+{
+  xpp::connection<xpp::extension::randr,
+                  xpp::extension::render,
+                  xpp::extension::dpms> c("");
+  // xpp::connection<> c("");
+
+  // auto tree_1 = xpp::generic::query_tree<decltype(c), xpp::extension::x>(c, 0);
+  // auto tree_1 = xpp::generic::query_tree<decltype(c)>(c, 0);
+  // auto tree_1 = xpp::generic::query_tree<>(static_cast<xcb_connection_t *>(c), 0);
+
+  auto & randr  = static_cast<xpp::randr::protocol &>(c);
+  auto & render = static_cast<xpp::render::protocol &>(c);
+  auto & dpms   = static_cast<xpp::dpms::protocol &>(c);
+
+  auto & randr_ext  = static_cast<xpp::extension::randr &>(c);
+  auto & render_ext = static_cast<xpp::extension::render &>(c);
+  auto & dpms_ext   = static_cast<xpp::extension::dpms &>(c);
+
+  *randr.query_version(XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
+  *render.query_version(XCB_RENDER_MAJOR_VERSION, XCB_RENDER_MINOR_VERSION);
+  *dpms.get_version(XCB_DPMS_MAJOR_VERSION, XCB_DPMS_MINOR_VERSION);
+
+  std::cerr << "randr first_error: " << (int)randr_ext->first_error << std::endl;
+  std::cerr << "render first_error: " << (int)render_ext->first_error << std::endl;
+  std::cerr << "dpms first_error: " << (int)dpms_ext->first_error << std::endl;
+
+  // auto tree = xpp::generic::query_tree(c, 0);
+  // std::cerr << "tree go" << std::endl;
+  // try {
+  //   tree.get();
+  //   auto error = tree.error();
+  //   std::cerr << error.get() << std::endl;
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "tree fin" << std::endl << std::endl;
+
+  // auto screen_info = xpp::generic::get_screen_info(c, 0);
+  // std::cerr << "screen_info go" << std::endl;
+  // try {
+  //   screen_info.get();
+  //   auto error = screen_info.error();
+  //   std::cerr << error.get() << std::endl;
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "screen_info fin" << std::endl << std::endl;
+
+  // auto dpms_capable = xpp::generic::dpms_capable(c);
+  // std::cerr << "dpms_capable go" << std::endl;
+  // try {
+  //   dpms_capable.get();
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "dpms_capable fin" << std::endl;
+
+  // auto pict_index_values = xpp::generic::render_query_pict_index_values(c, -1);
+  // std::cerr << "pict_index_values go" << std::endl;
+  // try {
+  //   pict_index_values.get();
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "pict_index_values fin" << std::endl;
+
+  // auto filters = xpp::generic::render_query_filters(c, 0);
+  // std::cerr << "filters go" << std::endl;
+  // try {
+  //   filters.get();
+  //   auto error = filters.error();
+  //   std::cerr << error.get() << std::endl;
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "filters fin" << std::endl << std::endl;
+
+
+
+  // // auto tree_2 = xpp::generic::query_tree<xcb_connection_t>(c, 0);
+  // auto tree_2 = xpp::generic::query_tree<>(c, 0);
+  // std::cerr << "tree_2 go" << std::endl;
+  // try {
+  //   tree_2.get();
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+  // std::cerr << "tree_2 fin" << std::endl;
+
+  // auto reply = xpp::request::x::query_tree(c, 0);
+  // reply.get();
+  // reply.check((xpp::extension::x &)c);
+
+  // auto reply = xpp::request::x::query_tree(c, 0);
+  // reply.get();
+  // try {
+  //   reply.check((xpp::extension::x &)c);
+  // } catch (const std::exception & exception) {
+  //   std::cerr << "Exception: " << exception.what() << std::endl;
+  // }
+
+
+  // return 0;
+
+  /*
+  map_window(*c, 0);
+
+  try {
+    map_window(c, 0);
+  } catch (...) {}
+
+  try {
+    map_window((xpp::extension::x &)c, c, 0);
+    map_window((xpp::extension::x &)c, c, 0);
+    // map_window((xpp::extension::randr &)c, c, 0);
+  } catch (...) {}
+  */
+
+  // xcb_generic_error_t * generic_error = NULL;
+  // xcb_query_tree_reply_t * query_tree_reply = NULL;
+
+  // checked request with reply, error directly available
+  {
+  std::cerr << "checked request with reply, error directly available" << std::endl;
+  // xcb_query_tree_cookie_t query_tree_cookie = xcb_query_tree(c, 5);
+  // query_tree_reply = xcb_query_tree_reply(c, query_tree_cookie, &generic_error);
+  try {
+    auto screen_info = xpp::request::randr::get_screen_info(c, 0);
+    // auto tree = xpp::generic::query_tree<>(c, 5);
+    screen_info.get();
+  } catch (const xpp::x::error::window & e) {
+    std::cerr << "xpp::x::error::window: " << e.what() << std::endl;
+  } catch (const std::exception & e) {
+    std::cerr << "std::exception: " << e.what() << std::endl;
+  }
+  // auto reply = tree.get();
+  c.flush();
+  // std::cerr << "query_tree_reply: " << reply.get() << std::endl;
+  // check_error_direct(tree.error());
+  // std::cerr << "query_tree_reply: " << query_tree_reply << std::endl;
+  // query_tree_reply = NULL;
+  // check_error_direct(generic_error);
+  // check_error_direct(generic_error);
+  // generic_error = NULL;
+  }
+  std::cerr << std::endl;
+
+  // checked request with reply, error directly available
+  {
+  std::cerr << "checked request with reply, error directly available" << std::endl;
+  // xcb_query_tree_cookie_t query_tree_cookie = xcb_query_tree(c, 5);
+  // query_tree_reply = xcb_query_tree_reply(c, query_tree_cookie, &generic_error);
+  try {
+    auto tree = xpp::request::x::query_tree(c, 5);
+    // auto tree = xpp::generic::query_tree<>(c, 5);
+    tree.get();
+  } catch (const xpp::x::error::window & e) {
+    std::cerr << "xpp::x::error::window: " << e.what() << std::endl;
+  } catch (const std::exception & e) {
+    std::cerr << "std::exception: " << e.what() << std::endl;
+  }
+  // auto reply = tree.get();
+  c.flush();
+  // std::cerr << "query_tree_reply: " << reply.get() << std::endl;
+  // check_error_direct(tree.error());
+  // std::cerr << "query_tree_reply: " << query_tree_reply << std::endl;
+  // query_tree_reply = NULL;
+  // check_error_direct(generic_error);
+  // check_error_direct(generic_error);
+  // generic_error = NULL;
+  }
+  std::cerr << std::endl;
+
+  // // unchecked request with reply, error in event queue
+  // {
+  // std::cerr << "unchecked request with reply, error in event queue" << std::endl;
+  // // xcb_query_tree_cookie_t query_tree_cookie = xcb_query_tree_unchecked(c, 17);
+  // // query_tree_reply = xcb_query_tree_reply(c, query_tree_cookie, &generic_error);
+  // auto tree = xpp::generic::query_tree<std::nothrow_t>(c, 5);
+  // auto reply = tree.get();
+  // c.flush();
+  // std::cerr << "query_tree_reply: " << reply.get() << std::endl;
+  // // std::cerr << "query_tree_reply: " << query_tree_reply << std::endl;
+  // // std::cerr << "query_tree_reply error: " << generic_error << std::endl;
+  // // query_tree_reply = NULL;
+  // check_error_event(c);
+  // }
+  // std::cerr << std::endl;
+
+  // // checked request without reply, error directly available
+  // {
+  // std::cerr << "checked request without reply, error directly available" << std::endl;
+  // // xcb_void_cookie_t void_cookie = xcb_map_window_checked(c, 42);
+  // try {
+  //   ::test::map_window(c, 0);
+  //   // xpp::request::x::map_window(c, 0);
+  // } catch (const xpp::x::error::window & e) {
+  //   std::cerr << "xpp::x::error::window: " << e.what() << std::endl;
+  // } catch (const std::exception & e) {
+  //   std::cerr << "std::exception: " << e.what() << std::endl;
+  // }
+  // c.flush();
+  // // generic_error = xcb_request_check(c, void_cookie);
+  // // check_error_direct(generic_error);
+  // // generic_error = NULL;
+  // }
+  // std::cerr << std::endl;
+
+  // unchecked request without reply, error in event queue
+  {
+  std::cerr << "unchecked request without reply, error in event queue" << std::endl;
+  xcb_map_window(c, 0);
+  c.flush();
+  check_error_event(c);
+  }
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/event.cpp polybar-3.2.1/lib/xpp/src/tests/event.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/event.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/event.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,125 @@
+#include <iostream>
+
+#include "../event.hpp"
+#include "../connection.hpp"
+
+using namespace xpp;
+using namespace event;
+
+xcb_window_t
+get_window(xcb_button_press_event_t * const e)
+{
+  return e->event;
+}
+
+xcb_window_t
+get_window(xcb_motion_notify_event_t * const e)
+{
+  return e->event;
+}
+
+namespace test {
+
+class handler : public dispatcher
+              , public sink<button::press>
+              , public sink<button::release>
+              , public sink<motion::notify>
+{
+  public:
+    void handle(const button::press &)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+
+    void handle(const button::release & e)
+    {
+      if (XCB_BUTTON_PRESS == (e->response_type & ~0x80)) {
+        std::cerr << __PRETTY_FUNCTION__ << " XCB_BUTTON_PRESS" << std::endl;
+      } else {
+        std::cerr << __PRETTY_FUNCTION__ << " XCB_BUTTON_RELEASE" << std::endl;
+      }
+    }
+
+    void handle(const motion::notify &)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+};
+
+class container : public direct::container {
+  public:
+    dispatcher * const
+      at(const unsigned int & window) const
+    {
+      return m_dispatcher.at(window);
+    }
+
+    std::unordered_map<unsigned int, dispatcher *> m_dispatcher;
+};
+
+struct foo {
+  void bar(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+class foo_container : public any::container<foo> {
+  public:
+    foo * const at(const unsigned int & window)
+    {
+      return &m_foos.at(window);
+    }
+
+    std::unordered_map<unsigned int, foo> m_foos;
+};
+
+class foo_handler : public any::adapter<foo, button::press, 0, get_window> {
+  public:
+    using adapter::adapter;
+
+    void handle(foo * const f, const button::press & e)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << " response_type: " << (int)(e->response_type & ~0x80) << std::endl;
+      f->bar();
+    }
+};
+
+}; // namespace test
+
+int main(int argc, char ** argv)
+{
+  connection c("");
+  source source(c);
+
+  auto tree = c.query_tree(c.root());
+
+  test::handler handler;
+  test::container container;
+
+  test::foo_container foo_container;
+  test::foo_handler foo_handler(source, foo_container);
+
+  for (auto & window : tree.children()) {
+    *(c.grab_pointer(false, window,
+                     XCB_EVENT_MASK_BUTTON_PRESS
+                     | XCB_EVENT_MASK_BUTTON_RELEASE
+                     | XCB_EVENT_MASK_POINTER_MOTION,
+                     XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
+                     XCB_NONE, XCB_NONE, XCB_TIME_CURRENT_TIME));
+
+    container.m_dispatcher[window] = &handler;
+    foo_container.m_foos[window] = test::foo();
+  }
+
+  dispatcher * dispatcher[] =
+    { new direct::adapter<button::press, 0, get_window>(source, container)
+    , new direct::adapter<button::release, 0, get_window>(source, container)
+    , new direct::adapter<motion::notify, 0, get_window>(source, container)
+    };
+
+  source.run();
+
+  for (auto * d : dispatcher) {
+    delete d;
+  }
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/.gitignore polybar-3.2.1/lib/xpp/src/tests/.gitignore
--- polybar-3.2.1.orig/lib/xpp/src/tests/.gitignore	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/.gitignore	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,2 @@
+event
+iterator
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/iterator.cpp polybar-3.2.1/lib/xpp/src/tests/iterator.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/iterator.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/iterator.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,155 @@
+#include <iostream>
+
+#include "../connection.hpp"
+
+class test {
+  public:
+
+    template<typename Data>
+    class iterator {
+      public:
+        iterator(Data * const data, std::size_t index)
+          : m_data(data), m_index(index)
+        {}
+
+        bool operator==(const iterator & other)
+        {
+          return m_index == other.m_index;
+        }
+
+        bool operator!=(const iterator & other)
+        {
+          return ! (*this == other);
+        }
+
+        const Data & operator*(void)
+        {
+          return m_data[m_index];
+        }
+
+        // prefix
+        iterator & operator++(void)
+        {
+          ++m_index;
+          return *this;
+        }
+
+        // postfix
+        iterator operator++(int)
+        {
+          auto copy = *this;
+          ++(*this);
+          return copy;
+        }
+
+        // prefix
+        iterator & operator--(void)
+        {
+          --m_index;
+          return *this;
+        }
+
+        // postfix
+        iterator operator--(int)
+        {
+          auto copy = *this;
+          --(*this);
+          return copy;
+        }
+
+      private:
+        Data * const m_data;
+        std::size_t m_index = 0;
+    };
+
+
+    template<typename T>
+    iterator<T> begin(void)
+    {
+      throw "This must not happen!";
+    }
+
+    template<typename T>
+    iterator<T> end(void)
+    {
+      throw "This must not happen!";
+    }
+
+  // private:
+    std::vector<int> m_ints;
+    std::vector<double> m_doubles;
+
+};
+
+template<>
+test::iterator<int> test::begin<int>(void)
+{
+  return iterator<int>(m_ints.data(), 0);
+}
+
+template<>
+test::iterator<double> test::begin<double>(void)
+{
+  return iterator<double>(m_doubles.data(), 0);
+}
+
+template<>
+test::iterator<int> test::end<int>(void)
+{
+  return iterator<int>(m_ints.data(), m_ints.size());
+}
+
+template<>
+test::iterator<double> test::end<double>(void)
+{
+  return iterator<double>(m_doubles.data(), m_ints.size());
+}
+
+int main(int argc, char ** argv)
+{
+  xpp::connection c("");
+
+  auto tree = c.query_tree(c.root());
+
+  std::cerr << "#windows (children_len): " << tree->children_len << std::endl;
+  std::cerr << "#windows (length):       " << tree->length << std::endl;
+
+  std::cerr << std::hex;
+  for (auto & window : tree.children()) {
+    std::cerr << "0x" << window << "; ";
+  }
+  std::cerr << std::dec << std::endl;;
+
+  std::cerr << std::hex;
+  for (auto it = tree.children().begin(); it != tree.children().end(); ++it) {
+    std::cerr << "0x" << *it << "; ";
+  }
+  std::cerr << std::dec << std::endl;;
+
+  std::cerr << std::hex;
+  auto it = tree.children().begin();
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << "++it: " << *(++it) << std::endl;
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << "it++: " << *(it++) << std::endl;
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << "++it: " << *(++it) << std::endl;
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << "--it: " << *(--it) << std::endl;
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << "it--: " << *(it--) << std::endl;
+  std::cerr << "it  : " << *it     << std::endl;
+  std::cerr << std::dec << std::endl;;
+
+  auto atom = c.intern_atom(false, "_NET_CLIENT_LIST_STACKING");
+  auto properties = c.get_property<xcb_window_t>(
+      false, c.root(), atom->atom, XCB_ATOM_WINDOW, 0, UINT32_MAX);
+
+  std::cerr << std::hex;
+  for (auto & window : properties) {
+    std::cerr << "0x" << window << "; ";
+  }
+  std::cerr << std::dec << std::endl;;
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/Makefile polybar-3.2.1/lib/xpp/src/tests/Makefile
--- polybar-3.2.1.orig/lib/xpp/src/tests/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/Makefile	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,25 @@
+include ../../include/flags.makefile
+
+# CXX=clang
+CXXFLAGS+=-g
+# CXXFLAGS+=-Wextra
+# CXXFLAGS+=-ftime-report
+
+CPPSRCS=event.cpp \
+        requests.cpp \
+        iterator.cpp
+
+all: ${CPPSRCS}
+
+${CPPSRCS}:
+	${CXX} ${LDFLAGS} ${CXXFLAGS} -o $(@:%.cpp=%) $@
+
+xlib-test: xlib-test.cpp
+	${CXX} $(shell pkg-config --libs --cflags x11 xrandr) -o $@ $<
+
+version:
+
+clean:
+	rm -f ${CPPSRCS:%.cpp=%}
+
+.PHONY: ${CPPSRCS} clean
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/README.md polybar-3.2.1/lib/xpp/src/tests/README.md
--- polybar-3.2.1.orig/lib/xpp/src/tests/README.md	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/README.md	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,2 @@
+Just a couple of experiments to try out concepts, language features, ideas.
+Might or might not compile, run or crash, etc.
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/requests.cpp polybar-3.2.1/lib/xpp/src/tests/requests.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/requests.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/requests.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,910 @@
+#include <iostream>
+
+// #include "../request.hpp"
+// #include "../core/connection.hpp"
+// #include "../core/window.hpp"
+// #include <xcb/xcb.h>
+// #include "../gen/sure_dude.hpp"
+// #include "../gen/xproto-stub.hpp"
+
+
+#include <X11/Xlib.h>
+#include <X11/keysym.h>
+#include <X11/cursorfont.h> // XC_cross
+
+#include "../xpp.hpp"
+#include "../proto/randr.hpp"
+#include "../proto/damage.hpp"
+#include "../proto/render.hpp"
+
+
+/*
+namespace xpp { namespace x { namespace error {
+
+void
+dispatcher::operator()(const std::shared_ptr<xcb_generic_error_t> &) const
+{
+  throw std::runtime_error(
+        std::string(__PRETTY_FUNCTION__)
+      + "\n\thandling errors like a boss with first_error = "
+      + std::to_string((uint32_t)m_first_error));
+}
+
+}; }; }; // namespace xpp::x::error
+*/
+
+// namespace my {
+// 
+// struct dispatcher {
+//   dispatcher(xcb_connection_t *) {}
+//   void
+//   operator()(const std::shared_ptr<xcb_generic_error_t> &) const
+//   {
+//     std::cerr << __PRETTY_FUNCTION__ << "\n\thandling errors like a boss" << std::endl;
+//   }
+// };
+// 
+// }; // namespace my
+
+/*
+namespace xpp {
+
+struct dummy_extension {
+  uint8_t first_error = 42;
+};
+
+struct connection
+  : public dummy_extension
+  , public xpp::x::extension
+  , public xpp::x::error::dispatcher
+  // , public xpp::x::protocol<connection>
+  // , virtual public xpp::generic::connection<xpp::connection>
+  , public xpp::x::protocol<connection &>
+  , virtual public xpp::generic::connection<xpp::connection &>
+{
+  connection(xcb_connection_t * c)
+    : xpp::x::error::dispatcher(
+      static_cast<dummy_extension &>(*this).first_error)
+    , m_c(c)
+    , m_data(new int)
+  {
+    m_data = std::make_shared<int>();
+    std::cerr << "connection c'tor: m_data.use_count(): "
+              << m_data.use_count() << std::endl;
+  }
+
+  ~connection(void)
+  {
+    std::cerr << "~connection d'tor: m_data.use_count(): "
+              << m_data.use_count() << std::endl;
+  }
+
+  connection(connection & other)
+    : xpp::x::error::dispatcher(
+      static_cast<const dummy_extension &>(other).first_error)
+    , m_c(other.m_c)
+    // , m_data(other.m_data)
+  {
+    std::cerr << "connection copy c'tor" << std::endl;
+  }
+
+  connection(connection && other) = default;
+  // connection(const connection && other)
+  //   : xpp::x::error::dispatcher(
+  //      static_cast<const dummy_extension &&>(other).first_error)
+  //   , m_c(other.m_c)
+  // {
+  //   std::cerr << "connection move c'tor" << std::endl;
+  // }
+
+  operator xcb_connection_t * const(void) const
+  {
+    return m_c;
+  }
+
+  xpp::connection &
+  // xpp::connection
+  get(void)
+  {
+    return *this;
+  }
+
+  xcb_connection_t * m_c;
+  // std::vector<int> m_data;
+  std::shared_ptr<int> m_data;
+};
+
+class window
+  : public xpp::x::window<xpp::connection &>
+  // , virtual public xpp::iterable<void>
+  , virtual public xpp::iterable<xcb_window_t>
+  // , virtual public xpp::xcb::type<const xcb_window_t &>
+  // , virtual protected xpp::generic::connection<connection &>
+{
+  public:
+    window(xpp::connection & c, const xcb_window_t & window)
+      : m_c(c)
+      , m_window(window)
+    {}
+
+    // xpp::iterable<const xcb_window_t &>
+    virtual
+    void
+    operator=(xcb_window_t window)
+    {
+      m_window = window;
+    }
+
+    virtual operator const xcb_window_t &(void) const
+    {
+      return m_window;
+    }
+
+  protected:
+    xpp::connection & m_c;
+    xcb_window_t m_window;
+
+    xpp::connection &
+    get(void)
+    {
+      return m_c;
+    }
+};
+
+struct dummy_atom {
+  dummy_atom(const xcb_atom_t & atom, xcb_connection_t * const) : m_atom(atom) {}
+  xcb_atom_t m_atom;
+};
+
+}; // xpp
+*/
+
+// namespace xpp { namespace generic {
+// 
+// template<REPLY_TEMPLATE>
+// struct reply_getter<xpp::connection, REPLY_SIGNATURE, checked_tag>
+// {
+//   std::shared_ptr<Reply>
+//   operator()(const xpp::connection & c, const Cookie & cookie)
+//   {
+//     std::cerr << "reply_getter special NO error" << std::endl;
+//     return std::shared_ptr<Reply>(ReplyFunction(c, cookie, nullptr), std::free);
+//   }
+// };
+// 
+// }; };
+
+bool g_quit = false;
+
+namespace x {
+  typedef xpp::connection<xpp::randr::extension,
+                          xpp::damage::extension,
+                          xpp::render::extension>
+                            connection;
+
+  typedef xpp::event::registry<connection &,
+                               xpp::randr::extension,
+                               xpp::damage::extension,
+                               xpp::render::extension>
+                                 registry;
+
+  typedef xpp::font<connection &> font;
+  typedef xpp::cursor<connection &> cursor;
+  typedef xpp::window<connection &> window;
+  typedef xpp::window<xcb_connection_t *> xcb_window;
+
+  typedef xpp::x::event::key_press<connection &> key_press;
+  typedef xpp::x::event::key_release<connection &> key_release;
+  typedef xpp::x::event::button_press<connection &> button_press;
+  typedef xpp::randr::event::notify<connection &> randr_notify;
+  typedef xpp::randr::event::screen_change_notify<connection &> randr_screen_change_notify;
+  typedef xpp::damage::event::notify<connection &> damage_notify;
+};
+
+class one_event
+  : public xpp::event::sink<x::key_press>
+{
+  public:
+    void handle(const x::key_press &) {}
+};
+
+class two_event
+  : public xpp::event::sink<x::key_press, x::key_release>
+{
+  public:
+    void handle(const x::key_press &) {}
+    void handle(const x::key_release &) {}
+};
+
+class more_events
+  : public xpp::event::sink<x::randr_notify, x::randr_screen_change_notify, x::damage_notify>
+{
+  void handle(const x::randr_notify &)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+  void handle(const x::randr_screen_change_notify &)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+  void handle(const x::damage_notify &) {}
+};
+
+template<typename Connection>
+class key_printer
+  : public xpp::event::sink<x::key_press,
+                            x::key_release,
+                            x::button_press>
+                            // xpp::randr::event::notify,
+                            // xpp::damage::event::notify,
+                            // xpp::xfixes::event::selection_notify,
+                            // xpp::screensaver::event::notify
+                            // >
+{
+  public:
+    template<typename C>
+    key_printer(C && c)
+      : m_c(std::forward<C>(c))
+    {}
+
+    void handle(const x::key_press & e)
+    {
+      auto kbd_mapping = m_c.get_keyboard_mapping(e->detail, 1);
+      auto keysym = *kbd_mapping.keysyms().begin();
+
+      if (keysym == XK_Escape) {
+        std::cerr << "quitting" << std::endl;
+        m_c.ungrab_keyboard(XCB_TIME_CURRENT_TIME);
+        g_quit = true;
+      } else {
+        std::cerr << "key pressed: " << XKeysymToString(keysym) << std::endl;
+      }
+    }
+
+    void handle(const x::key_release & e)
+    {
+      auto kbd_mapping = m_c.get_keyboard_mapping(e->detail, 1);
+      auto keysym = *kbd_mapping.keysyms().begin();
+      std::cerr << "key released: " << XKeysymToString(keysym) << std::endl;
+    }
+
+    void handle(const x::button_press & e)
+    {
+      m_c.ungrab_pointer(XCB_TIME_CURRENT_TIME);
+
+      std::cerr << "root: 0x"
+                << std::hex << e->root << std::dec
+                << "; event: 0x"
+                << std::hex << e->event << std::dec
+                << "; child: 0x"
+                << std::hex << e->child << std::dec
+                << std::endl;
+
+      // xcb_window_t w = e.event();
+      x::window grab_window = e.event<x::window>();
+      std::cerr << "grab_window: " << grab_window << std::endl;
+
+      if (e->event == e->root) {
+        grab_window = e.child();
+        std::cerr << "new grab_window: " << grab_window << std::endl;
+        auto translate = grab_window.translate_coordinates(grab_window, 1, 1);
+        grab_window = translate->child;
+      }
+
+      std::cerr << "grabbing "
+                << std::hex << grab_window << std::dec
+                << std::endl;
+
+      *m_c.grab_keyboard(true, grab_window,
+                         XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
+      // g_quit = true;
+    }
+
+    // void handle(const xpp::randr::event::notify & e)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+    // void handle(const xpp::damage::event::notify & e)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+    // void handle(const xpp::xfixes::event::selection_notify & e)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+    // void handle(const xpp::screensaver::event::notify & e)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+    // does not work
+    // template<int OpCode, typename Event>
+    // void handle(const xpp::generic::event<OpCode, Event> &)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+  private:
+    Connection m_c;
+};
+
+xcb_screen_t *
+screen_of_display(xcb_connection_t * c, int screen)
+{
+  xcb_screen_iterator_t iter;
+
+  iter = xcb_setup_roots_iterator(xcb_get_setup(c));
+  for (; iter.rem; --screen, xcb_screen_next(&iter))
+    if (screen == 0)
+      return iter.data;
+
+  return NULL;
+}
+
+int main(int argc, char ** argv)
+{
+  // int default_screen;
+  // xcb_connection_t * c = xcb_connect(nullptr, &default_screen);
+  // xcb_screen_t * screen = screen_of_display(c, default_screen);
+
+  // x::error_handler eh;
+  x::connection connection;
+  // xcb_connection_t * xcb_c = nullptr;
+
+  try {
+    x::window window(connection, argc > 1 ? std::strtol(argv[1], NULL, 10) : 0);
+    auto tree = window.query_tree();
+    std::cerr << "children of window (" << window << "): ";
+    for (auto && child : tree.children<x::window>()) {
+      std::cerr << child << ", ";
+    }
+    std::cerr << std::endl;
+  } catch (const std::exception & exception) {
+    std::cerr << std::endl;
+    std::cerr << "window exception: " << exception.what() << std::endl;
+  }
+
+  auto net_client_list_stacking_atom = connection.intern_atom(
+      false, "_NET_CLIENT_LIST_STACKING");
+  auto net_client_list_stacking = connection.get_property(
+      false, connection.root(), net_client_list_stacking_atom.atom(),
+      XCB_ATOM_WINDOW, 0, UINT32_MAX);
+
+  std::cerr << "_NET_CLIENT_LIST_STACKING (xcb_window_t):" << std::hex;
+  for (auto && w : net_client_list_stacking.value<xcb_window_t>()) {
+    std::cerr << " 0x" << w;
+  }
+  std::cerr << std::dec << std::endl;
+
+  std::cerr << "_NET_CLIENT_LIST_STACKING (x::window):";
+  for (auto && w : net_client_list_stacking.value<x::window>()) {
+    std::cerr << " " << w;
+  }
+  std::cerr << std::endl;
+
+  std::cerr << "_NET_CLIENT_LIST_STACKING (x::xcb_window):";
+  for (auto && w : net_client_list_stacking.value<x::xcb_window>()) {
+    std::cerr << " " << w;
+  }
+  std::cerr << std::endl;
+
+// #ifndef __clang__
+  // static_cast<xpp::randr::protocol<const x::connection &> &>(connection)
+  //   .query_version(XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
+
+  // connection.interface<xpp::randr::extension>()
+  connection.randr().query_version(
+      XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
+
+  const xpp::randr::extension & randr = connection.extension<xpp::randr::extension>();
+  // xpp::randr::extension & randr = static_cast<xpp::randr::extension &>(connection);
+  std::cerr << "RandR Extension" << std::endl;
+  std::cerr << "\tfirst_event: " << (int)randr->first_event << std::endl;
+  std::cerr << "\tfirst_error: " << (int)randr->first_error << std::endl;
+
+  connection.select_input_checked(connection.root(), XCB_RANDR_NOTIFY);
+
+  const xpp::damage::extension & damage = connection.extension<xpp::damage::extension>();
+  std::cerr << "Damage Extension" << std::endl;
+  std::cerr << "\tfirst_event: " << (int)damage->first_event << std::endl;
+  std::cerr << "\tfirst_error: " << (int)damage->first_error << std::endl;
+// #endif
+
+  x::registry registry(connection);
+
+  // key_printer<x::connection &> key_printer(connection);
+  std::vector<key_printer<x::connection &>> key_printers(100, connection);
+  // std::vector<key_printer<x::connection &> *> key_printers(100, new key_printer<x::connection &>(connection));
+
+  const int n = 2;
+  // registry.attach(0, &key_printer);
+  for (int i =  0; i < n; ++i) {
+    registry.attach(0, &key_printers[i]);
+    // registry.attach(0, key_printers[i]);
+  }
+
+  for (int i =  0; i < n - 1; ++i) {
+    registry.detach(0, &key_printers[i]);
+    // registry.detach(0, key_printers[i]);
+  }
+
+  one_event oe;
+  two_event te;
+  more_events me;
+
+  registry.attach(0, &oe);
+  registry.attach(0, &te);
+  registry.detach(0, &oe);
+  registry.detach(0, &te);
+
+  registry.attach(0, &me);
+  // registry.detach(0, &me);
+
+
+  // auto font = connection.generate_id();
+  // connection.open_font(font, "cursor");
+
+  // auto cursor = connection.generate_id();
+  // connection.create_glyph_cursor(cursor, font, font,
+      // XC_cross, XC_cross + 1, 0, 0, 0, 0xffff, 0xffff, 0xffff);
+  // connection.close_font(font);
+  // connection.close_cursor(cursor);
+    // x::cursor cursor_xid = x::cursor(connection, 0);
+
+
+  try {
+    x::font font = x::font::open_checked(connection, "cursor");
+
+    x::cursor cursor = x::cursor::create_glyph_checked(connection, font, font,
+        XC_cross, XC_cross + 1, 0, 0, 0, 0xffff, 0xffff, 0xffff);
+
+    *connection.grab_pointer(false, connection.root(),
+                             XCB_EVENT_MASK_BUTTON_PRESS,
+                             XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
+                             XCB_NONE, cursor, XCB_TIME_CURRENT_TIME);
+
+    std::cerr << "Please click on a window" << std::endl;
+
+  } catch (const std::exception & error) {
+    std::cerr << "Exception (std::exception) in "
+              << __FILE__ << " @ line " << __LINE__ << ", what(): "
+              << error.what() << std::endl;
+    std::exit(EXIT_FAILURE);
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "Exception (std::shared_ptr<xcb_generic_error_t>) in "
+              << __FILE__ << " @ line " << __LINE__ << ", error_code: "
+              << (int)error->error_code << std::endl;
+    std::exit(EXIT_FAILURE);
+  } catch (...) {
+    std::cerr << "Exception (...) in "
+              << __FILE__ << " @ line " << __LINE__
+              << std::endl;
+    std::exit(EXIT_FAILURE);
+  }
+
+
+  // xcb_randr_get_output_info_cookie_t goic = xcb_randr_get_output_info_unchecked(connection, -1, XCB_TIME_CURRENT_TIME);
+  // xcb_randr_get_output_info_reply_t * goir = xcb_randr_get_output_info_reply(connection, goic, nullptr);
+
+  // XCB_RANDR_BAD_OUTPUT
+  auto output_info = connection.get_output_info_unchecked(-1);
+  output_info.get();
+
+  // XCB_RANDR_BAD_CRTC
+  // auto crtc_info = connection.get_crtc_info_unchecked(-1);
+  // crtc_info.get();
+
+  // auto output_property = connection.query_output_property_unchecked(-1, -1);
+  // output_property.get();
+
+  connection.change_output_property(-1, -1, -1, 0, 0, 0, nullptr);
+
+  // connection.map_window(-1);
+
+  // auto & damage_proto = static_cast<xpp::damage::protocol<const x::connection &> &>(connection);
+  // damage_proto.create(-1, -1, 0);
+  // damage_proto.destroy(-1);
+  // damage_proto.subtract(-1, 0, 0);
+
+  connection.query_pict_index_values_unchecked(-1);
+  connection.change_picture(-1, 0, nullptr);
+
+// clang_complete does not like this
+// causes vim to segfault
+// #if not defined __clang__
+
+  while (! g_quit) {
+    connection.flush();
+    try {
+      registry.dispatch(connection.wait_for_event());
+    } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+      std::cerr << "Caught std::shared_ptr<xcb_generic_error_t> in event loop "
+                << "(code: " << (int)error->error_code << ")" << std::endl;
+    } catch (const std::exception & error) {
+      std::cerr << "Caught std::exception in event loop: " << error.what() << std::endl;
+    } catch (...) {
+      std::cerr << "Something really bad has happened" << std::endl;
+    }
+  }
+
+// #endif
+
+  // xpp::x::event::key_press<x::connection &>
+  //   xek_1(connection, std::shared_ptr<xcb_generic_event_t>((xcb_generic_event_t *)new xcb_key_press_event_t));
+  // xpp::x::event::key_press<xcb_connection_t *>
+  //   xek_2(connection, std::shared_ptr<xcb_generic_event_t>(((xcb_generic_event_t *)new xcb_key_press_event_t)));
+  // xpp::x::event::key_press<xcb_connection_t *>
+  //   xek_3(xcb_c, std::shared_ptr<xcb_generic_event_t>(((xcb_generic_event_t *)new xcb_key_press_event_t)));
+
+  // xpp::window<x::connection>      w_1(connection);
+  // xpp::window<xcb_connection_t *> w_2(xcb_c);
+  // static_cast<xcb_window_t &>(w_1) = 12;
+
+  // if (xcb_connection_has_error(c)) {
+  //   std::cerr << "Connection has error" << std::endl;
+  //   return EXIT_FAILURE;
+  // }
+
+  // xpp::x::error::dispatcher ed(connection);
+
+  // xcb_void_cookie_t mwc = xcb_map_window_checked(c, -1);
+  // xcb_flush(c);
+  // xcb_generic_error_t * error = xcb_request_check(c, mwc);
+  // xcb_flush(c);
+  // if (error) {
+  //   std::free(error);
+  //   std::cerr << "mwc error" << std::endl;
+  // }
+
+  /*
+  std::shared_ptr<xcb_query_tree_reply_t> qtr;
+
+  typedef xpp::fixed::detail::simple<
+      x::connection &, xcb_window_t,
+      SIGNATURE(xcb_query_tree_children),
+      SIGNATURE(xcb_query_tree_children_length)>
+        simple_query_tree_iterator;
+  simple_query_tree_iterator(connection, qtr, 0);
+
+  typedef xpp::fixed::detail::object<
+      x::connection &, x::window,
+      SIGNATURE(xcb_query_tree_children),
+      SIGNATURE(xcb_query_tree_children_length)>
+        object_query_tree_iterator;
+  object_query_tree_iterator(connection, qtr, 0);
+  */
+
+  // typedef xpp::iterator<
+  //     x::connection, x::window,
+  //     SIGNATURE(xcb_query_tree_children),
+  //     SIGNATURE(xcb_query_tree_children_length)>
+  //       query_tree_iter;
+
+  // auto qt_iter = query_tree_iter(connection, qtr, 0);
+
+  // typedef xpp::generic::list<x::connection,
+  //                            xcb_query_tree_reply_t,
+  //                            query_tree_iter>
+  //                              query_tree_list;
+
+  // auto qt_list = query_tree_list(connection, qtr);
+  // auto qt_list_begin = qt_list.begin();
+
+  // std::shared_ptr<xcb_query_tree_reply_t> qtr;
+  // auto simple_iter = xpp::fixed::iterator::simple<
+  //     x::connection, xcb_window_t, xcb_window_t, xcb_query_tree_reply_t,
+  //     xcb_query_tree_children,
+  //     xcb_query_tree_children_length>(connection, qtr, 0);
+
+  // auto object_iter = xpp::fixed::iterator::object<
+  //     x::connection, xcb_window_t, x::window, xcb_query_tree_reply_t,
+  //     xcb_query_tree_children,
+  //     xcb_query_tree_children_length>(connection, qtr, 0);
+
+  // std::shared_ptr<xcb_get_font_path_reply_t> fpr;
+  // typedef xpp::iterator<x::connection,
+  //                       xcb_str_t,
+  //                       xcb_str_t,
+  //                       SIGNATURE(xcb_str_next),
+  //                       SIGNATURE(xcb_str_sizeof),
+  //                       SIGNATURE(xcb_get_font_path_path_iterator)>
+  //                         font_path_iter;
+
+  std::cerr << "fonts:" << std::endl;
+  auto fonts = connection.list_fonts(8, 1, "*");
+  for (auto && name : fonts.names()) {
+    std::cerr << "font [" << name.length() << "]: " << name << std::endl;
+  }
+
+  std::cerr << "paths:" << std::endl;
+  // auto font_paths = connection.get_font_path();
+  for (auto && path : connection.get_font_path().path()) {
+    std::cerr << "path [" << path.length() << "]: " << path << std::endl;
+  }
+
+  auto tree = connection.root<x::window>().query_tree();
+  std::cerr << "children: ";
+  for (auto && child : tree.children<x::xcb_window>()) {
+    std::cerr << child << ", ";
+    auto siblings = child.query_tree();
+    std::cerr << "(siblings: ";
+    for (auto && sibling : siblings.children()) {
+      std::cerr << sibling << ", ";
+    }
+    std::cerr << "), " << std::endl;
+  }
+  std::cerr << std::endl;
+
+  // auto tree_2 = connection.query_tree(screen->root);
+  // std::cerr << "children: ";
+  // for (auto & w : tree_2.children<x::window>()) {
+  //   std::cerr << w << ", ";
+  // }
+  // std::cerr << std::endl;
+
+  // xcb_window_t window = 27263111;
+  xcb_window_t window = 0;
+
+  // test::map_window(c, window);
+  // test::map_window(c, window, 0);
+  xpp::x::map_window(connection, window);
+  connection.map_window(window);
+
+  try {
+    // test::map_window_checked(c, window);
+    // xpp::x::map_window_checked(c, window);
+    connection.map_window_checked(window);
+  } catch (const std::exception & e) {
+    std::cerr << "CATCH: map_window exception:" << std::endl
+              << "\twhat(): " << e.what() << std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "CATCH: map_window error: " << (int)error->error_code << std::endl;
+  }
+
+  // auto attrs_0 = test::get_window_attributes(c, window);
+  // auto attrs_1 = test::get_window_attributes(connection, window);
+  // auto attrs_2 = test::get_window_attributes_unchecked(connection, window);
+
+  xpp::x::reply::checked::get_window_attributes<xcb_connection_t *>
+    gwar(connection, window);
+
+  auto attrs_0 = connection.get_window_attributes(window);
+  // auto attrs_0 = xpp::x::get_window_attributes(c, window);
+  auto attrs_1 = xpp::x::get_window_attributes(connection, window);
+  auto attrs_2 = xpp::x::get_window_attributes_unchecked(connection, window);
+
+  try {
+    attrs_0.get();
+  } catch (const std::exception & e) {
+    std::cerr << "CATCH: attrs_0 exception:" << std::endl
+              << "\twhat(): " << e.what() << std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "CATCH: attrs_0 std::shared_ptr<xcb_generic_error_t>::error_code: " << (int)error->error_code << std::endl;
+  }
+
+  if (! attrs_0) {
+    std::cerr << "attrs_0 invalid" << std::endl;
+  } else {
+    std::cerr << "attrs_0 valid" << std::endl;
+  }
+
+  try {
+    attrs_1.get();
+  } catch (const std::exception & e) {
+    std::cerr << "CATCH: attrs_1 exception:" << std::endl
+              << "\twhat(): " << e.what() << std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "CATCH: attrs_1 std::shared_ptr<xcb_generic_error_t>::error_code: " << (int)error->error_code << std::endl;
+  }
+
+  if (! attrs_1) {
+    std::cerr << "attrs_1 invalid" << std::endl;
+  } else {
+    std::cerr << "attrs_1 valid" << std::endl;
+  }
+
+  try {
+    attrs_2.get();
+  } catch (const std::exception & e) {
+    std::cerr << "CATCH: attrs_2 exception:" << std::endl
+              << "\twhat(): " << e.what() << std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "CATCH: attrs_2 std::shared_ptr<xcb_generic_error_t>::error_code: " << (int)error->error_code << std::endl;
+  }
+
+  if (! attrs_2) {
+    std::cerr << "attrs_2 invalid" << std::endl;
+  } else {
+    std::cerr << "attrs_2 valid" << std::endl;
+  }
+
+  try {
+    auto my_string_atom = xpp::x::intern_atom(connection, false, "MY_STRING");
+    std::string my_string("SUPER COOL");
+
+    std::cerr << "atom \"MY_STRING\": " << my_string_atom.atom() << std::endl;;
+
+    auto atom_name = connection.get_atom_name(my_string_atom.atom());
+    std::cerr << "atom name: " << atom_name.name() << std::endl;;
+
+    // xpp::x::change_property_checked(c,
+    connection.change_property_checked(
+        XCB_PROP_MODE_REPLACE, connection.root(),
+        my_string_atom.atom(), XCB_ATOM_STRING, 8,
+        my_string.begin(), my_string.end());
+
+    // xpp::x::change_property_checked(c,
+    connection.change_property_checked(
+        XCB_PROP_MODE_REPLACE, 0,
+        my_string_atom.atom(), XCB_ATOM_STRING, 8,
+        my_string.length(), my_string.c_str());
+  } catch (const std::exception & e) {
+    std::cerr << "change property failed: " << e.what() << std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr << "generic error: " << (int)error->error_code << std::endl;
+  }
+
+  connection.flush();
+
+  // xcb_disconnect(c);
+
+
+  /*
+  std::cerr << std::endl << "intern_atom 1" << std::endl;
+  auto atom_reply_1 =
+    xpp::x::intern_atom_unchecked(c, false, 25, "_NET_CLIENT_LIST_STACKING");
+  atom_reply_1.get();
+  if (atom_reply_1) {
+    std::cerr<<"atom_reply_1 success"<<std::endl;
+  }
+
+  std::cerr << std::endl << "intern_atom 2" << std::endl;
+  auto atom_reply_2 = xpp::x::intern_atom(c, false, "_NET_CLIENT_LIST_STACKING");
+  atom_reply_2.get();
+  if (atom_reply_2) {
+    std::cerr<<"atom_reply_2 success"<<std::endl;
+  }
+
+  std::cerr << std::endl << "intern_atom 3" << std::endl;
+  auto atom_reply_3 = xpp::x::intern_atom(c, false, "_NET_CLIENT_LIST_STAC");
+  try {
+    atom_reply_3.get();
+    std::cerr<<"atom_reply_3 success"<<std::endl;
+  } catch (const std::shared_ptr<xcb_generic_error_t> & error) {
+    std::cerr<<"CATCH: atom_reply_3 success, error_code: "
+    << (int)error->error_code <<std::endl;
+  }
+
+  std::cerr << std::endl << "intern_atom 1 reply: ";
+  xcb_atom_t atom = atom_reply_1->atom;
+  std::cerr << (int)atom << std::endl;
+
+  std::cerr << std::endl << "intern_atom 2 reply: ";
+  auto dummy_atom = atom_reply_2.atom<xpp::dummy_atom>();
+  std::cerr << (int)dummy_atom.m_atom << std::endl;
+
+  auto my_string_atom = xpp::x::intern_atom(c, true, "MY_STRING");
+  std::string my_string("LADIDA");
+  xpp::x::change_property(
+      c, XCB_PROP_MODE_REPLACE, 0, my_string_atom.atom(), XCB_ATOM_STRING, 8,
+      my_string.begin(), my_string.end());
+  */
+
+  /*
+  std::cerr << std::endl << "intern_atom 1" << std::endl;
+  auto atom_reply_1 = intern_atom(c, false, 25, "_NET_CLIENT_LIST_STACKING");
+
+  std::cerr << std::endl << "intern_atom 2" << std::endl;
+  auto atom_reply_2 = intern_atom(c, false, std::string("_NET_CLIENT_LIST_STACKING"));
+
+  std::cerr << std::endl << "intern_atom 3" << std::endl;
+  auto atom_reply_3 = intern_atom<xpp::connection,
+                                  my::dispatcher,
+                                  xpp::x::error::dispatcher>
+                                    (c, false, "FOO BAZ");
+  atom_reply_3.get();
+
+  std::cerr << std::endl << "intern_atom 1 reply: ";
+  xcb_atom_t atom = atom_reply_1->atom;
+  std::cerr << (int)atom << std::endl;
+
+  std::cerr << std::endl << "intern_atom 2 reply: ";
+  auto dummy_atom = atom_reply_2.atom<xpp::dummy_atom>();
+  std::cerr << (int)dummy_atom.m_atom << std::endl;
+
+  std::cerr << std::endl << "map_window 1" << std::endl;
+  map_window(connection, 0);
+  std::cerr << std::endl << "map_window 2" << std::endl;
+  map_window<xpp::connection>(c, 0);
+  std::cerr << std::endl << "map_window 3" << std::endl;
+  map_window<xpp::connection, my::dispatcher, xpp::x::error::dispatcher>(connection, 0);
+
+  auto my_string_atom =
+    intern_atom<xpp::connection, my::dispatcher>(connection, true, "MY_STRING");
+  std::string my_string("LADIDA");
+  change_property<xpp::connection, my::dispatcher>(
+      c, XCB_PROP_MODE_REPLACE, 0, my_string_atom.atom(), XCB_ATOM_STRING, 8,
+      my_string.begin(), my_string.end());
+  */
+
+  /*
+  std::cerr << std::endl << "auto wa_1" << std::endl;
+  auto wa_1 = get_window_attributes(c, 0);
+  std::cerr << std::endl << "auto wa_2" << std::endl;
+  auto wa_2 = get_window_attributes<xpp::connection,
+                                    my::dispatcher,
+                                    xpp::x::error::dispatcher>
+                                      (connection, 0);
+  std::cerr << std::endl << "auto wa_3" << std::endl;
+  auto wa_3 = get_window_attributes<xpp::connection,
+                                    my::dispatcher,
+                                    xpp::x::error::dispatcher>
+                                      (connection, 0);
+
+  std::cerr << std::endl << "wa_1" << std::endl;
+  auto r1 = wa_1.get();
+  std::cerr << std::endl << "wa_2" << std::endl;
+  auto r2 = wa_2.get();
+  std::cerr << std::endl << "wa_3" << std::endl;
+  auto r3 = wa_3.get();
+  */
+
+  // try {
+  //   std::cerr << "YOLOLOLOL" << std::endl;
+  //   xcb_colormap_t cm = wa_3.colormap();
+  //   cm = wa_1->colormap;
+  //   cm = r1->colormap;
+  // } catch (...) {}
+
+  // map_window<xpp::connection>(c, 0);
+  // map_window<xpp::connection, my::dispatcher, xpp::x::error::dispatcher>(c, 0);
+
+  // auto wa_cookie = get_window_attributes_cookie(c, 0);
+  // auto wa_reply_1 = get_window_attributes_reply<xpp::connection>(connection, wa_cookie);
+  // auto wa_reply_2 = get_window_attributes_reply<
+  //   xpp::connection, my::dispatcher, xpp::x::error::dispatcher>(
+  //     connection, get_window_attributes_cookie()(c, 0));
+
+  // wa_reply_1.get();
+  // wa_reply_2.get();
+
+  // auto wa = get_window_attributes(c, 0);
+  // auto wa_error = get_window_attributes(ed, c, 0);
+  // wa_error.get();
+
+  // map_window_cookie<xpp::connection>()(connection, 0);
+  // map_window_cookie<xpp::connection>()(ed, connection, 0);
+  // map_window_cookie<xpp::connection>()(connection, connection, 0);
+  // map_window_cookie<xpp::connection>()(xpp::x::error::dispatcher(), connection, 0);
+
+  // get_window_attributes_cookie wac_1(c, 0);
+  // get_window_attributes_cookie wac_2(c, 0);
+
+  // get_window_attributes_reply<> war_1(connection, wac_1);
+  // get_window_attributes_reply<> war_2(connection, wac_2);
+
+  // get_window_attributes_reply<my::dispatcher, xpp::x::error::dispatcher>
+  //   war_3(connection, get_window_attributes_cookie()(c, 0), my::dispatcher(), xpp::x::error::dispatcher());
+
+  // war_1.get();
+  // war_2.get();
+  // war_3.get();
+
+
+  // map_window_cookie<xpp::connection> mwc_unchecked;
+  // mwc_checked(, connection, 0);
+  // mwc_checked(xpp::x::error::dispatcher(), connection, 0);
+  // mwc_unchecked(connection, 0);
+  // map_window_cookie<checked,   xpp::connection> mwc_checked;
+  // map_window_cookie<unchecked, xpp::connection> mwc_unchecked;
+
+  // map_window(c, 0);
+  // map_window<xpp::generic::checked>(c, 0);
+  // auto reply = get_window_attributes(connection, 0);
+  // reply.get();
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/resource.cpp polybar-3.2.1/lib/xpp/src/tests/resource.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/resource.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/resource.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,49 @@
+#include <iostream>
+
+#include "../xpp.hpp"
+#include "../proto/randr.hpp"
+#include "../proto/damage.hpp"
+#include "../proto/render.hpp"
+
+#include <X11/Xlib.h>
+#include <X11/keysym.h>
+#include <X11/cursorfont.h> // XC_cross
+
+namespace x {
+  typedef xpp::connection<
+                          // xpp::randr::extension,
+                          // xpp::damage::extension,
+                          // xpp::render::extension
+                         >
+                            connection;
+
+  typedef xpp::event::registry<connection &
+                               // xpp::randr::extension,
+                               // xpp::damage::extension,
+                               // xpp::render::extension>
+                              >
+                                 registry;
+
+  typedef xpp::font<connection &> font;
+  typedef xpp::cursor<connection &> cursor;
+  typedef xpp::window<connection &> window;
+  typedef xpp::window<xcb_connection_t *> xcb_window;
+
+  typedef xpp::x::event::key_press<connection &> key_press;
+  typedef xpp::x::event::key_release<connection &> key_release;
+  typedef xpp::x::event::button_press<connection &> button_press;
+  typedef xpp::randr::event::notify<connection &> randr_notify;
+  typedef xpp::randr::event::screen_change_notify<connection &> randr_screen_change_notify;
+  typedef xpp::damage::event::notify<connection &> damage_notify;
+};
+
+int main(int argc, char ** argv)
+{
+  x::connection connection;
+  xcb_font_t font = 0;
+  auto cursor_1 = x::cursor(connection, 0);
+  auto cursor_2 = x::cursor::create_glyph(connection, font, font,
+      XC_cross, XC_cross + 1, 0, 0, 0, 0xffff, 0xffff, 0xffff);
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/sizeof.cpp polybar-3.2.1/lib/xpp/src/tests/sizeof.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/sizeof.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/sizeof.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,767 @@
+// compile with `g++ -std=c++11 test.cpp`
+#include <iostream>
+#include <map>
+#include <unordered_map>
+#include <vector>
+#include <algorithm>
+
+namespace test1 {
+
+template<typename T>
+struct interface {
+  static std::size_t size_of(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    return sizeof(T);
+  }
+};
+
+template<>
+struct interface<void> {
+  static std::size_t size_of(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    return sizeof(char);
+  }
+};
+
+template<typename T>
+struct A : public interface<T> {
+  A(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " size_of(): "
+              << this->size_of() << std::endl;
+  }
+
+  static std::size_t size_of(void)
+  {
+    std::cerr << "YOLOLOL" << std::endl;
+    return 0;
+  }
+};
+
+// template<typename T>
+struct B : public interface<int> {
+  B(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " size_of(): "
+              << this->size_of() << std::endl;
+  }
+};
+
+// template<typename T>
+struct C : public interface<double> {
+  C(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " size_of(): "
+              << this->size_of() << std::endl;
+  }
+};
+
+int main(int argc, char ** argv)
+{
+  test1::A<int> t1_1;
+  std::cerr << std::endl;
+  test1::A<double> t1_2;
+  std::cerr << std::endl;
+  test1::A<char> t1_3;
+  std::cerr << std::endl;
+  test1::A<uint16_t> t1_4;
+  std::cerr << std::endl;
+  test1::A<void> t1_5;
+  std::cerr << std::endl;
+
+  test1::B t2_1;
+  std::cerr << std::endl;
+
+  test1::C t3_1;
+  std::cerr << std::endl;
+
+  return 0;
+}
+
+};
+
+namespace test2 {
+
+struct interface {
+  static void test(void);
+};
+
+struct A : public interface {
+  static void test(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " (A::test)" << std::endl;
+  }
+  A(void)
+  {
+    test();
+  }
+};
+
+struct B : public interface {
+  static void test(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " (B::test)" << std::endl;
+  }
+  B(void)
+  {
+    test();
+  }
+};
+
+void test(const interface & i)
+{
+  A::test();
+  B::test();
+  // decltype(i)::test();
+}
+
+int main(int argc, char ** argv)
+{
+  test2::A a;
+  test2::B b;
+  test2::test(a);
+  // test2::test();
+
+  return 0;
+}
+
+};
+
+namespace test3 {
+
+template<typename T>
+struct Base {
+  T t;
+};
+
+template<int N>
+struct select_type;
+
+template<>
+struct select_type<1> {
+  Base<int> base;
+};
+
+template<>
+struct select_type<2> {
+  Base<double> base;
+};
+
+int main(int argc, char ** argv)
+{
+  constexpr int i = 0;
+  test3::select_type<1> st_1;
+  test3::select_type<2> st_2;
+
+  return 0;
+}
+
+};
+
+namespace test4 {
+
+template<typename T>
+struct i {
+  virtual bool f(T) = 0;
+};
+
+namespace a {
+  struct a : public i<int> {
+    bool f(int i)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      return i == m_i;
+    }
+    int m_i = 0;
+  };
+};
+
+namespace b {
+  struct b : public i<int> {
+    bool f(int i)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      return i == m_i;
+    }
+    int m_i = 1;
+  };
+};
+
+namespace c {
+  struct c : public i<int> {
+    bool f(int i)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      return i == m_i;
+    }
+    int m_i = 2;
+  };
+};
+
+template<typename ... IS>
+struct z : public IS ... {
+
+  // template<typename ... VS>
+  void
+  run(int i)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " with i = " << i << std::endl;
+    f(i, static_cast<IS *>(this) ...);
+  }
+
+  template<typename I, typename ... ISS>
+  void
+  f(int v, I * i, ISS ... is)
+  {
+    if (! i->f(v)) {
+      f(v, is ...);
+    } else {
+      std::cerr << "We've got a winner!" << std::endl;
+    }
+  }
+
+  template<typename I>
+  void
+  f(int v, I * i)
+  {
+    i->f(v);
+  }
+
+};
+
+int main(int argc, char ** argv)
+{
+  test4::z<test4::a::a, test4::b::b, test4::c::c> z;
+  for (auto i : { 0, 1, 2, 3 }) {
+    z.run(i);
+  }
+  return 0;
+}
+
+};
+
+namespace test5 {
+
+struct pod_generic {
+  int id;
+  int m_int;
+};
+
+struct pod_int {
+  int id = 0;
+  int m_int;
+};
+
+struct pod_double {
+  int id = 1;
+  double m_double;
+};
+
+struct pod_string {
+  int id = 2;
+  std::string m_string;
+};
+
+template<int OpCode>
+struct my_pod_wrapper {
+  static const int opcode = OpCode;
+};
+
+struct my_pod_int_wrapper : public my_pod_wrapper<0> {
+  my_pod_int_wrapper(pod_generic * pg)
+    : m_pi((pod_int *)pg) {}
+  pod_int * m_pi;
+};
+
+struct my_pod_double_wrapper : public my_pod_wrapper<1> {
+  my_pod_double_wrapper(pod_generic * pg)
+    : m_pd((pod_double *)pg) {}
+  pod_double * m_pd;
+};
+
+struct my_pod_string_wrapper : public my_pod_wrapper<2> {
+  my_pod_string_wrapper(pod_generic * pg)
+    : m_ps((pod_string *)pg) {}
+  pod_string * m_ps;
+};
+
+class dispatcher {
+  public:
+    virtual ~dispatcher(void) {}
+    template<typename E> void dispatch(const E & e);
+};
+
+template<typename ... Events>
+class sink;
+
+template<typename E>
+class sink<E> : virtual public dispatcher {
+  public:
+    virtual void handle(const E & e) = 0;
+};
+
+template<typename Event, typename ... Events>
+class sink<Event, Events ...>
+  : virtual public sink<Event>
+  , virtual public sink<Events> ...
+{};
+
+template<typename E>
+void dispatcher::dispatch(const E & e)
+{
+  dynamic_cast<sink<E> *>(this)->handle(e);
+}
+
+template<int ExtensionId>
+class pod_dispatcher {
+  public:
+    template<typename Dispatcher>
+    bool
+    operator()(pod_generic * pg, const Dispatcher & D) const
+    {
+      // std::cerr << __PRETTY_FUNCTION__ << std::endl;
+      std::cerr << "POD_DISPATCHER<" << ExtensionId << ">" << std::endl;
+      switch (pg->id) {
+        case 0:
+          // std::cerr << "dispatch with my_pod_int_wrapper" << std::endl;
+          D(my_pod_int_wrapper(pg));
+          return true;
+
+        case 1:
+          // std::cerr << "dispatch with my_pod_double_wrapper" << std::endl;
+          D(my_pod_double_wrapper(pg));
+          return true;
+
+        case 2:
+          // std::cerr << "dispatch with my_pod_string_wrapper" << std::endl;
+          D(my_pod_string_wrapper(pg));
+          return true;
+      };
+
+      return false;
+    }
+};
+
+template<>
+class pod_dispatcher<1> {
+  public:
+    template<typename Dispatcher>
+    bool
+    operator()(pod_generic * pg, const Dispatcher & D) const
+    {
+      std::cerr << "POD_DISPATCHER<1>" << std::endl;
+      switch (pg->id) {
+        case 0:
+          // std::cerr << "dispatch with my_pod_int_wrapper" << std::endl;
+          D(my_pod_int_wrapper(pg));
+          return true;
+
+        case 1:
+          // std::cerr << "dispatch with my_pod_double_wrapper" << std::endl;
+          D(my_pod_double_wrapper(pg));
+          return true;
+
+        case 2:
+          // std::cerr << "dispatch with my_pod_string_wrapper" << std::endl;
+          D(my_pod_string_wrapper(pg));
+          return true;
+      };
+
+      return false;
+    }
+};
+
+class a : public sink<my_pod_int_wrapper,
+                      my_pod_double_wrapper,
+                      my_pod_string_wrapper>
+{
+  public:
+    virtual void handle(const my_pod_int_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+    virtual void handle(const my_pod_double_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+    virtual void handle(const my_pod_string_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+class b : public sink<my_pod_string_wrapper,
+                      my_pod_double_wrapper>
+{
+  public:
+    virtual void handle(const my_pod_string_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+    virtual void handle(const my_pod_double_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+class c : public sink<my_pod_double_wrapper>
+{
+  public:
+    virtual void handle(const my_pod_double_wrapper &) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+template<typename ... POD_Dispatcher>
+struct handler_registry {
+
+  template<typename D>
+  bool
+  dispatch(pod_generic * pg) const
+  {
+    std::cerr << "RecursiveDispatchEnd_EvenBetter" << std::endl;
+    return D()(pg, *this);
+  }
+
+  template<typename D1, typename D2, typename ... Dispatcher>
+  bool
+  dispatch(pod_generic * pg) const
+  {
+    std::cerr << "BigFatDispatch_ManFeelsGood" << std::endl;
+    D1()(pg, *this);
+    return dispatch<D2, Dispatcher ...>(pg);
+  }
+
+  bool
+  dispatch(pod_generic * pg) const
+  {
+    std::cerr << "InitialDispatch_JustAbitWeiry" << std::endl;
+    return dispatch<POD_Dispatcher ...>(pg);
+  }
+
+  template<typename Event>
+  void
+  operator()(const Event & e) const
+  {
+    try {
+      for (auto & item : m_dispatcher.at(Event::opcode)) {
+        item.second->dispatch(e);
+      }
+    } catch (...) {}
+  }
+
+  template<typename Event1, typename Event2, typename ... Events>
+  void
+  attach(sink<Event1, Event2, Events ...> * s)
+  {
+    attach(Event1::opcode, s);
+    attach((sink<Event2, Events ...> *)s);
+  }
+
+  template<typename Event>
+  void
+  attach(sink<Event> * s)
+  {
+    attach(Event::opcode, s);
+  }
+
+  void attach(unsigned int opcode, dispatcher * d)
+  {
+    m_dispatcher[opcode].emplace(0, d);
+  }
+
+  std::unordered_map<unsigned int,
+                     std::multimap<unsigned int, dispatcher *>> m_dispatcher;
+};
+
+template<typename I>
+void foo(int i, I j) {}
+
+int main(int argc, char ** argv)
+{
+  int i = 42;
+  std::string s = "42";
+
+  pod_int pi;
+  pod_double pd;
+  pod_string ps;
+
+  test5::a a;
+  test5::b b;
+  test5::c c;
+
+  handler_registry<pod_dispatcher<0>,
+                   pod_dispatcher<1>,
+                   pod_dispatcher<2>> registry;
+
+  registry.attach(&a);
+  registry.attach(&b);
+  registry.attach(&c);
+
+  registry.dispatch((test5::pod_generic *)&pi);
+  registry.dispatch((test5::pod_generic *)&ps);
+  registry.dispatch((test5::pod_generic *)&pd);
+
+  return 0;
+}
+
+};
+
+namespace test6 {
+  template <typename... Types>
+    struct foo {};
+
+  template < typename... Types1, template <typename...> class T
+    , typename... Types2, template <typename...> class V
+    , typename U >
+    void
+    bar(const T<Types1...>&, const V<Types2...>&, const U& u)
+    {
+      std::cout << sizeof...(Types1) << std::endl;
+      std::cout << sizeof...(Types2) << std::endl;
+      std::cout << u << std::endl;
+    }
+
+  int main(int argc, char ** argv)
+    {
+      foo<char, int, float> f1;
+      foo<char, int> f2;
+      bar(f1, f2, 9);
+      return 0;
+    }
+};
+
+namespace test7 {
+
+static constexpr std::size_t * my_ext_1 = nullptr;
+static constexpr std::size_t * my_ext_2 = nullptr;
+static constexpr std::size_t * my_ext_3 = nullptr;
+static constexpr std::size_t * my_ext_4 = nullptr;
+
+// static const std::size_t id_4_0 = reinterpret_cast<std::size_t>(&my_ext_4 + 0);
+// static const std::size_t id_4_1 = reinterpret_cast<std::size_t>(&my_ext_4 + 1);
+// static const std::size_t id_4_2 = reinterpret_cast<std::size_t>(&my_ext_4 + 2);
+
+namespace p1 {
+template<std::size_t * Id>
+struct ext {};
+
+template<>
+struct ext<my_ext_1> {
+  void call(void) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+};
+
+namespace p2 {
+template<std::size_t * Id>
+struct ext {};
+
+template<>
+struct ext<my_ext_2> {
+  void call(void) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+};
+
+namespace p3 {
+template<std::size_t * Id>
+struct ext {};
+
+template<>
+struct ext<my_ext_3> {
+  void call(void) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+};
+
+struct proto_1 {
+  typedef p1::ext<my_ext_1> ext;
+  template<typename Handler, typename Event>
+  void dispatch(const Handler & h, const Event & e)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    e.call(static_cast<const typename Event::ext &>(h));
+  }
+};
+
+struct proto_2 {
+  typedef p2::ext<my_ext_2> ext;
+  template<typename Handler, typename Event>
+  void dispatch(const Handler & h, const Event & e)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    e.call(static_cast<const typename Event::ext &>(h));
+  }
+};
+
+struct proto_3 {
+  typedef p3::ext<my_ext_3> ext;
+  template<typename Handler, typename Event>
+  void dispatch(const Handler & h, const Event & e)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    e.call(static_cast<const typename Event::ext &>(h));
+  }
+};
+
+struct event_1 {
+  typedef p1::ext<my_ext_1> ext;
+  typedef proto_1 proto;
+  // void call(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  void call(const ext & e) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; e.call(); }
+};
+
+struct event_2 {
+  typedef p2::ext<my_ext_2> ext;
+  typedef proto_2 proto;
+  // void call(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  void call(const ext & e) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; e.call(); }
+};
+
+struct event_3 {
+  typedef p3::ext<my_ext_3> ext;
+  typedef proto_3 proto;
+  // void call(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  void call(const ext & e) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; e.call(); }
+};
+
+struct pod_event_1 {
+  const int id = 1;
+};
+
+struct pod_event_2 {
+  const int id = 2;
+};
+
+struct pod_event_3 {
+  const int id = 3;
+};
+
+template<typename ... Protos>
+struct proto
+  : public Protos ...
+  , public Protos::ext ...
+{
+
+  template<typename Event>
+  void run(const Event & event)
+  {
+    static_cast<typename Event::proto *>(this)->dispatch(*this, event);
+  }
+
+};
+
+int main(int argc, char ** argv)
+{
+  std::cerr << "my_ext_1: " << my_ext_1 << std::endl;
+  std::cerr << "my_ext_2: " << my_ext_2 << std::endl;
+  std::cerr << "my_ext_3: " << my_ext_3 << std::endl;
+
+  proto<proto_1, proto_2, proto_3> p;
+
+  event_1 e_1;
+  event_2 e_2;
+  event_3 e_3;
+
+  p.run(e_1);
+  p.run(e_2);
+  p.run(e_3);
+
+  return 0;
+}
+
+}; // namespace test7
+
+namespace test8 {
+
+struct a {
+  void operator()(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct b {
+  void operator()(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct c {
+  void operator()(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct wrap_hull
+{
+  virtual void do_cool_stuff(void) = 0;
+};
+
+template<typename ... Args>
+struct wrap
+  : public wrap_hull
+  , public Args ...
+{
+  void do_cool_stuff(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+template<typename ... Args>
+struct test : public Args ...
+{
+  void trigger(void)
+  {
+    run<Args ...>();
+  }
+
+  template<typename Arg, typename Next, typename ... Rest>
+  void run(void)
+  {
+    run<Arg>();
+    run<Next, Rest ...>();
+  }
+
+  template<typename Arg>
+  void run(void)
+  {
+    Arg()();
+  }
+
+  template<typename Arg, typename Next, typename ... Rest>
+  void
+  insert(wrap<Arg, Next, Rest ...> * w)
+  {
+    insert<Arg, Next, Rest ...>(
+        reinterpret_cast<wrap<Arg> *>(w),
+        reinterpret_cast<wrap<Next, Rest> *>(w) ...);
+  }
+
+  template<typename Arg, typename Next, typename ... Rest>
+  void
+  insert(wrap<Arg> * w, wrap<Next, Rest ...> * ws ...)
+  {
+    insert<Arg>(w);
+    insert<Next, Rest ...>(
+        reinterpret_cast<wrap<Next> *>(w),
+        reinterpret_cast<wrap<Rest> *>(w) ...);
+  }
+
+  template<typename Arg>
+  void
+  insert(wrap_hull * wh)
+  {
+    m_wraps.push_back(wh);
+  }
+
+  void call_objects(void)
+  {
+    for (auto * wh : m_wraps) {
+      wh->do_cool_stuff();
+    }
+  }
+
+  std::vector<wrap_hull *> m_wraps;
+};
+
+int main(int argc, char ** argv)
+{
+  struct test<a, b, c> t;
+  t.trigger();
+
+  struct wrap<a, b, c> w;
+  t.insert(&w);
+
+  t.call_objects();
+
+  return 0;
+}
+
+}; // namespace test8
+
+int main(int argc, char ** argv)
+{
+  // return test1::main(argc, argv);
+  // return test2::main(argc, argv);
+  // return test3::main(argc, argv);
+  // return test4::main(argc, argv);
+  // return test5::main(argc, argv);
+  // return test6::main(argc, argv);
+  // return test7::main(argc, argv);
+  return test8::main(argc, argv);
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/template.cpp polybar-3.2.1/lib/xpp/src/tests/template.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/template.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/template.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,101 @@
+// compile with `g++ -std=c++11 test.cpp`
+#include <iostream>
+
+#define CALLABLE(FUNCTION) callable<decltype(FUNCTION), FUNCTION>
+
+template<typename Signature, Signature & S>
+struct callable;
+
+template<typename Return,
+         typename ... Args, Return (&Function)(Args ...)>
+struct callable<Return(Args ...), Function> {
+  Return operator()(Args ... args)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    return Function(args ...);
+  }
+};
+
+template<typename ... Arguments>
+class one_size_fits_them_all;
+
+// A generic template
+template<typename T, typename U, typename V,
+         typename F1, typename F2, typename F3>
+class one_size_fits_them_all<T, U, V, F1, F2, F3>
+{
+  public:
+    one_size_fits_them_all(void)
+    {
+      std::cerr << "generic one_size_fits_them_all" << std::endl
+                << __PRETTY_FUNCTION__ << std::endl << std::endl;
+      F1()();
+      F2()();
+      F3()();
+      std::cerr << std::endl;
+    }
+};
+
+// A specialized template
+template<typename T, typename Callable>
+class one_size_fits_them_all<T, int, int, void, void, Callable>
+{
+  public:
+    one_size_fits_them_all(void)
+    {
+      std::cerr << "specialized one_size_fits_them_all" << std::endl
+                << __PRETTY_FUNCTION__ << std::endl << std::endl;
+      Callable()();
+      std::cerr << std::endl;
+    }
+};
+
+void f1(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+void f2(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+void f3(void)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl << std::endl;
+}
+
+template<typename T>
+struct interface {
+  static std::size_t size_of(void) { return sizeof(T); }
+};
+
+template<typename T>
+struct test : public interface<T> {
+  test(void)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << " size_of(): " << this->size_of() << std::endl;
+  }
+};
+
+int main(int argc, char ** argv)
+{
+  // generic template
+  auto generic = one_size_fits_them_all<
+    int, int, int, CALLABLE(f1), CALLABLE(f2), CALLABLE(f3)>();
+
+  // specialized template
+  auto specialized_int = one_size_fits_them_all<
+    int, int, int, void, void, CALLABLE(f1)>();
+
+  // specialized template
+  auto specialized_double = one_size_fits_them_all<
+    double, int, int, void, void, CALLABLE(f3)>();
+
+  test<int> t1;
+  test<double> t2;
+  test<char> t3;
+  test<uint16_t> t4;
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/test.cpp polybar-3.2.1/lib/xpp/src/tests/test.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/test.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/test.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,1255 @@
+#include <climits>
+#include <unistd.h>
+#include <iostream>
+#include <memory>
+#include <chrono>
+
+#include <list>
+
+template<typename T>
+struct is_callable {
+private:
+    typedef char(&yes)[1];
+    typedef char(&no)[2];
+
+    struct Dummy {};
+    struct Fallback { void operator()(); };
+    // struct Derived : T, Fallback { };
+    struct Derived : std::conditional<! std::is_fundamental<T>::value,
+                                      T,
+                                      Dummy>::type,
+                     Fallback { };
+
+    template<typename U, U> struct Check;
+
+    template<typename>
+    static yes test(...);
+
+    template<typename C>
+    static no test(Check<void (Fallback::*)(), &C::operator()>*);
+
+public:
+    static const bool value = sizeof(test<Derived>(0)) == sizeof(yes);
+};
+
+
+// #include <X11/Xlib.h>
+// #include <X11/keysymdef.h>
+// #include <X11/extensions/Xrandr.h>
+// #include <X11/cursorfont.h> // XC_cross
+
+// #include <xcb/xcbext.h>
+
+// #include "../event.hpp"
+// #include "../core/value_iterator.hpp"
+// #include "../core/connection.hpp"
+
+// template<typename Iterator>
+// void
+// test(Iterator begin, Iterator end)
+// {
+//   std::cerr << "before initializer:";
+//   for (auto it = begin; it != end; ++it) {
+//     std::cerr << " " << *it;
+//   }
+//   std::cerr << std::endl;
+// 
+//   // auto vector = { begin, end };
+//   // std::vector<typename value_trait<Iterator>::value_type> vector(begin, end);
+// 
+//   std::vector<typename value_type<Iterator,
+//                                   ! std::is_pointer<Iterator>::value
+//                                  >::type>
+//                                     vector(begin, end);
+// 
+//   // std::initializer_list<Iterator> vector = { begin, end };
+// 
+//   std::cerr << "after initializer (size: " << vector.size() << "):";
+//   for (auto & v : vector) {
+//     std::cerr << " " << v;
+//   }
+//   std::cerr << std::endl;
+// }
+
+struct foo {
+  static void create(int * c, unsigned int xid)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+
+  static void destroy(int * c, unsigned int xid)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+};
+
+struct bar {
+  static void create(int * c, unsigned int xid, double d)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+  static void destroy(int * c, unsigned int xid)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  }
+};
+
+template<typename Xid, typename ... Parameters>
+struct allocator {
+
+  template<void (*Allocate)(int *, Xid, Parameters ...)>
+  struct allocate
+  {
+    void
+    operator()(int * c, Xid xid, Parameters ... parameters)
+    {
+      Allocate(c, xid, parameters ...);
+    }
+  };
+
+  template<void (*Deallocate)(int *, Xid)>
+  struct deallocate
+  {
+    void
+    operator()(int * c, Xid xid)
+    {
+      Deallocate(c, xid);
+    }
+  };
+
+};
+
+template<typename Xid, typename Allocate = void, typename Deallocate = void>
+struct xid {
+
+  template<typename ... Parameters>
+  xid(Parameters ... parameters)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    m_xid = std::shared_ptr<Xid>(new Xid(0), // xcb_generate_id(c)),
+                                 [&](Xid * xid)
+                                 {
+                                   Deallocate()(NULL, *xid);
+                                   delete xid;
+                                 });
+    Allocate()(NULL, 0, parameters ...);
+  }
+
+  std::shared_ptr<Xid> m_xid;
+};
+
+template<typename Xid>
+struct xid<Xid, void, void>
+{
+  Xid xid;
+};
+
+template<typename Signature1, Signature1 & S1, typename Signature2, Signature2 & S2>
+struct wrapper;
+
+template<typename Return1,
+         typename ... Args1,
+         Return1(&F1)(Args1 ...),
+         typename Return2,
+         typename ... Args2,
+         Return2(&F2)(Args2 ...)>
+struct wrapper<Return1(Args1 ...), F1, Return2(Args2 ...), F2> {
+  static
+  void
+  allocate(Args1 ... args)
+  {
+    F1(args ...);
+  }
+  static
+  void
+  deallocate(Args2 ... args)
+  {
+    F2(args ...);
+  }
+};
+
+struct caller {
+  template<typename Callee>
+  void operator()(const Callee & callee, int i)
+  {
+    switch (i) {
+      case 0: callee(42);
+        break;
+      case 1: callee(2.73);
+        break;
+      case 2: callee(std::string("foo"));
+        break;
+    };
+  }
+};
+
+struct callee {
+  void operator()(int i) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  template<typename Arg>
+  void operator()(const Arg &) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+namespace mylib {
+
+namespace request {
+  enum { checked, unchecked };
+};
+
+namespace extension {
+
+using mylib::request::checked;
+using mylib::request::unchecked;
+
+namespace request {
+template<int RequestType = unchecked>
+struct void_request {
+  void operator()(void) const noexcept(RequestType == unchecked)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  };
+};
+};
+
+// template<>
+// struct void_request<checked> {
+//   void operator()(void) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; };
+// };
+
+namespace request {
+template<int RequestType = checked>
+struct reply_request {
+  void operator()(void) const noexcept(RequestType == unchecked)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << std::endl;
+  };
+};
+};
+
+// template<>
+// struct reply_request<unchecked> {
+//   void operator()(void) const { std::cerr << __PRETTY_FUNCTION__ << std::endl; };
+// };
+
+struct interface {
+  template<int RequestType = unchecked>
+  void void_request(void) const { request::void_request<RequestType>()(); }
+  template<int RequestType = checked>
+  void reply_request(void) const { request::reply_request<RequestType>()(); }
+};
+
+}; // extension
+
+struct c : public extension::interface
+{};
+
+}; // mylib
+
+namespace test00 {
+
+enum { checked, unchecked };
+
+template<std::size_t check = unchecked>
+struct template_struct {
+  template<typename Connection, typename ... Parameter>
+  template_struct(Connection c, Parameter ... parameter) {}
+};
+
+template_struct<> ts(nullptr);
+
+template<std::size_t check = unchecked, typename Connection, typename ... Parameter>
+void
+template_function(Connection c, Parameter ... parameter)
+{
+  if (check == checked) {
+    std::cerr << "if (check) { // check == checked" << std::endl;
+  } else {
+    std::cerr << "} else { // check == unchecked" << std::endl;
+  }
+}
+
+struct an_interface {
+  template<typename std::size_t Check = unchecked, typename ... Parameter>
+  void
+  template_function(Parameter ... parameter)
+  {
+    test00::template_function<Check>(m_c, parameter ...);
+  }
+  double m_c;
+};
+
+void test(void)
+{
+//   two t;
+//   // t.do_it_void();
+//   // t.do_it_void().unchecked();
+//   auto reply_1 = t.do_it_reply();
+//   auto reply_2 = t.do_it_reply().unchecked();
+//   // reply.checked();
+//   // auto reply = t.do_it_reply().checked();
+
+  // template_function(t);
+  // template_function(t, reply_1, reply_2);
+  // template_function<checked>(reply_1, reply_2);
+  // template_function<checked>(reply_2);
+
+  an_interface i;
+  i.template_function(0);
+  i.template_function<checked>(0);
+}
+
+};
+
+namespace test01 {
+
+struct a {
+  a(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  a(const std::string & string) : m_string(string) {}
+  a(const a & other) : m_string(other.m_string) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  a(a && other) : m_string(std::move(other.m_string)) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  ~a(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  std::string m_string = "struct a";
+};
+
+struct b {
+  // b(const a & a) : m_a(a) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  // template<typename A>
+  // b(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  // b(a & a) : m_a(a) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  // b(a && a) : m_a(std::move(a)) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  b(a && a) : m_a(std::move(a)) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  b(const a & a) : m_a(a) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+
+  // b(const b & other) : m_a(other.m_a) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+  b(b && other) : m_a(std::move(other.m_a)) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+
+  ~b(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+
+  // const a & m_a;
+  a m_a;
+};
+
+b
+// foo(const a & a)
+foo(const a & a)
+{
+  // return b(std::move(a));
+  return b(a);
+}
+
+void test(void)
+{
+  // b bb = foo(a());
+  // b bb = foo(std::move(a()));
+  a aa("a string on the stack");
+  // b b1 = foo(aa);
+  std::cerr << "(before move) aa.m_string: " <<  aa.m_string << std::endl;
+  b b2 = foo(std::move(aa));
+  std::cerr << "(after move) aa.m_string: " <<  aa.m_string << std::endl;
+  // std::cerr << "b1.m_a.m_string: " <<  b1.m_a.m_string << std::endl;
+  std::cerr << "b2.m_a.m_string: " <<  b2.m_a.m_string << std::endl;
+}
+
+};
+
+namespace test02 {
+
+struct a {
+  static void foo(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct b : a {
+  static void foo(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct c : b {
+  static void foo(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+// struct d : a, b {
+//   static void foo(void)
+//   {
+//     std::cerr << __PRETTY_FUNCTION__ << std::endl;
+//     a::foo();
+//     b::foo();
+//   }
+// };
+
+void test(void)
+{
+  a::foo();
+  b::foo();
+  c::foo();
+  // d::foo();
+}
+
+};
+
+namespace test03 {
+
+struct connection {};
+
+struct baz {
+  int member;
+};
+
+struct fro {
+  // fro(const int & i)
+  // {
+  //   std::cerr << __PRETTY_FUNCTION__ << ": " << i << std::endl;
+  // }
+
+  fro(const int & i, connection *)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << ": " << i << std::endl;
+  }
+};
+
+struct foo {
+  foo(const int & i, double d)
+  {
+    std::cerr << __PRETTY_FUNCTION__ << ": " << i << "; d: " << d << std::endl;
+  }
+
+  // foo(int i, connection *, double d)
+  // {
+  //   std::cerr << __PRETTY_FUNCTION__ << ": " << i << "; d: " << d << std::endl;
+  // }
+};
+
+namespace reply_member {
+
+template<typename ReturnType>
+class get_with_object {
+  public:
+    template<typename Arg, typename ... Parameter>
+    ReturnType
+    operator()(Arg & a, connection *, Parameter ... parameter)
+    {
+      return ReturnType { a, parameter ... };
+    }
+};
+
+template<typename ReturnType>
+class get_with_object_and_connection {
+  public:
+    template<typename Arg, typename ... Parameter>
+    ReturnType
+    operator()(const Arg & a, connection * i, Parameter ... parameter)
+    {
+      return ReturnType { a, i, parameter ... };
+    }
+};
+
+template<typename ReturnType>
+class get_fundamental {
+  public:
+    template<typename Arg>
+    ReturnType
+    operator()(const Arg & arg, connection *)
+    {
+      return ReturnType { arg };
+    }
+};
+
+template<typename MemberType, typename ReturnType, typename ... Parameter>
+class get
+  : public std::conditional<
+               std::is_constructible<ReturnType, MemberType>::value,
+               get_fundamental<ReturnType>,
+               typename std::conditional<
+                            std::is_constructible<ReturnType,
+                                                  MemberType,
+                                                  connection *,
+                                                  Parameter ...>::value,
+                            get_with_object_and_connection<ReturnType>,
+                            get_with_object<ReturnType>
+                        >::type
+           >::type
+{};
+
+};
+
+struct c {
+  template<typename ReturnType = int, typename ... Parameter>
+  ReturnType
+  c_get(Parameter ... parameter)
+  {
+    using get = reply_member::get<decltype(b.member), ReturnType, Parameter ...>;
+    return get()(b.member, i, parameter ...);
+  }
+
+  baz b;
+  connection * i;
+};
+
+void
+test(void)
+{
+  c cc;
+  cc.b.member = 42;
+
+  auto m_int = cc.c_get();
+  std::cerr << "m: " << m_int << std::endl;
+
+  // auto m_fro_i = cc.c_get<fro>();
+  // auto m_foo_d = cc.c_get<foo>(3.14);
+}
+
+}; // test03
+
+namespace test04 {
+
+struct a {
+  a(const std::string & s) : m_s(s) {}
+  void operator()(const std::string & s) const
+  {
+    std::cerr << "a: " << s << "; m_s: " << m_s << std::endl;
+  }
+  std::string m_s;
+};
+
+struct b {
+  void operator()(const std::string & s) const
+  {
+    std::cerr << "b: " << s << std::endl;
+  }
+};
+
+struct c : a, b {
+  c(void) : a("c : a") {}
+  // void operator() (const std::string & s) { a::operator()(s); b::operator()(s); }
+};
+
+struct d {
+  void
+  operator()(const std::string & s) const
+  {
+    std::cerr << "d: " << s << std::endl;
+  }
+};
+
+template<typename Base, typename Arg>
+void
+check(const Base & base, const Arg & arg)
+{
+  base(arg);
+}
+
+template<typename Base, typename Arg, typename E>
+void
+check(const Base & base, const Arg & arg)
+{
+  static_cast<const E &>(base)(arg);
+}
+
+template<typename Base, typename Arg, typename E, typename Next, typename ... Rest>
+void
+check(const Base & base, const Arg & arg)
+{
+  check<Base, Arg, E>(base, arg);
+  check<Base, Arg, Next, Rest ...>(base, arg);
+}
+
+template<typename E, typename ... ES>
+struct foo_base {
+  foo_base(const E & e)
+    : m_e(e)
+  {}
+
+  E m_e;
+
+  void
+  check_error(const std::string & s)
+  {
+    check<E, std::string, ES ...>(m_e, s);
+  }
+};
+
+template<>
+struct foo_base<void> {
+  foo_base(void)
+  {}
+
+  void
+  check_error(const std::string & s)
+  {
+    std::cerr << "foo_base<void>" << std::endl;
+  }
+};
+
+template<typename E = void, typename ... ES>
+struct foo
+  : public foo_base<E, ES ...>
+{
+  typedef foo_base<E, ES ...> base;
+
+  using base::foo_base;
+
+  template<typename ... P2>
+  void
+  operator()(const std::string & s, P2 ... p2)
+  {
+    base::check_error(s);
+  }
+
+}; // struct foo;
+
+template<typename T>
+using decay = typename std::decay<T>::type;
+
+template<typename Condition, typename T = void>
+using enable_if =
+  typename std::enable_if<Condition::value, T>::type;
+
+template<typename Condition, typename T = void>
+using disable_if =
+  typename std::enable_if<! Condition::value, T>::type;
+
+// template<typename P, typename ... PS>
+// typename std::enable_if<is_callable<decay<P>>::value, void>::type
+// foo_function_dispatch(const std::string & s, P && p, PS ... ps)
+// {
+//   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+//   foo_function(p, s, ps ...);
+// }
+
+// template<typename P, typename ... PS>
+// typename std::enable_if<! is_callable<decay<P>>::value, void>::type
+// foo_function_dispatch(const std::string & s, P && p, PS ... ps)
+// {
+//   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+//   foo_function(s, p, ps ...);
+// }
+
+template<typename Parameter,
+         typename ... Parameters,
+         typename = disable_if<is_callable<decay<Parameter>>>>
+void
+foo_function(const std::string & s, Parameter && p, Parameters ... ps)
+{
+  foo<>()(s, ps ...);
+}
+
+template<typename ... ErrorHandlers,
+         typename ErrorHandler,
+         typename ... Parameters,
+         typename = enable_if<is_callable<decay<ErrorHandler>>>>
+void
+foo_function(const std::string & s, ErrorHandler && e, Parameters ... ps)
+{
+  (foo<ErrorHandler, ErrorHandlers ...>(e))(s, ps ...);
+}
+
+struct foo_iface {
+
+  foo_iface(void) {}
+  foo_iface(const std::string & s) : m_s(s) {}
+
+  template<typename ... ErrorHandlers, typename ... Parameters>
+  void
+  foo_method(Parameters ... ps)
+  {
+    foo_function<ErrorHandlers ...>(m_s, ps ...);
+  }
+
+  // template<typename P,
+  //          typename ... PS,
+  //          typename = disable_if<is_callable<decay<P>>>>
+  // void
+  // foo_method(P && p, PS ... ps)
+  // {
+  //   foo_function(m_s, p, ps ...);
+  // }
+
+  // template<typename ... ErrorHandlers,
+  //          typename E,
+  //          typename ... PS,
+  //          typename = enable_if<is_callable<decay<E>>>>
+  // void
+  // foo_method(E && e, PS ... ps)
+  // {
+  //   foo_function<ErrorHandlers ...>(m_s, e, ps ...);
+  // }
+
+  std::string m_s = "foo_iface";
+};
+
+// template<typename ... ES, typename E, typename ... PS, typename P>
+// void
+// foo_with_error(const std::string & s, PS ... ps, const E & e)
+// {
+//   (foo<E, ES ...>(e))(s, ps ...);
+//   // foo<std::function<void(const std::string &)>> f([](const std::string & s) { std::cerr << "lambda: " << s << std::endl; });
+//   // f(s, ps ...);
+// }
+
+struct e {
+  int i;
+};
+
+void
+test(void)
+{
+  // d dd;
+  // (foo<d>(dd))("aaa 42 aaa", 5,6,7);
+  // ((foo<c, a, b>(c())))("ccc 42 ccc", 5,6,7);
+
+  foo_function("hhh 42 hhh", a("abcde"), 5,6,7);
+  foo_function("jjj 42 jjj", 5,6,7);
+  foo_function("kkk 42 kkk", [](const std::string & s){ std::cerr << "lambda: " << s << std::endl; }, 5,6,7);
+
+  foo_iface fi;
+  fi.foo_method(5,6,7);
+  fi.foo_method(b(), 5,6,7);
+  c cc;
+  fi.foo_method<a,b>(cc, 5,6,7);
+
+  std::cerr << std::boolalpha << std::endl
+            // << "has_member_operator(): " << has_member_operator<b>::value << std::endl
+            << "is_callable: " << is_callable<b>::value << std::endl
+            << "is_trivial: " << std::is_trivial<b>::value << std::endl
+            << "is_pod: " << std::is_pod<b>::value << std::endl
+            << "is_standard_layout: " << std::is_standard_layout<b>::value << std::endl
+            << "is_fundamental: " << std::is_fundamental<b>::value << std::endl
+            << "is_class: " << std::is_class<b>::value << std::endl
+            << "is_object: " << std::is_object<b>::value << std::endl
+            << std::endl;
+
+  std::cerr << std::boolalpha << std::endl
+            << "is_callable: " << is_callable<e>::value << std::endl
+            << "is_trivial: " << std::is_trivial<e>::value << std::endl
+            << "is_pod: " << std::is_pod<e>::value << std::endl
+            << "is_standard_layout: " << std::is_standard_layout<e>::value << std::endl
+            << "is_fundamental: " << std::is_fundamental<e>::value << std::endl
+            << "is_class: " << std::is_class<e>::value << std::endl
+            << "is_object: " << std::is_object<e>::value << std::endl
+            << std::endl;
+
+  std::cerr << std::boolalpha << std::endl
+            << "is_callable: " << is_callable<int>::value << std::endl
+            << std::endl;
+
+  // foo<b>(b(1))("bbb 42 bbb", 5,6,7);
+  // (foo<b>(b()))("bbb 42 bbb", 5,6,7);
+  // foo<a, b>(c())("ccc 42 ccc", 5,6,7);
+  // foo<>()("ddd 42 ddd", 5,6,7);
+  // foo<a>()(a("a2"), "eee 42 eee", 5,6,7);
+  // (foo<a>(a("a2")))("eee 42 eee", 5,6,7);
+}
+
+}; // test04
+
+namespace test05 {
+
+template<typename T>
+struct a {
+  struct member {
+    struct get {
+      void operator()(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+    };
+  };
+};
+
+struct b : a<int> {
+  void
+  fun(void)
+  {
+    using get = member::get;
+    get()();
+  }
+};
+
+void
+test(void)
+{
+  b bb;
+  bb.fun();
+}
+
+}; // test05
+
+namespace test06 {
+
+void foo(int i)
+{
+  std::cerr << __PRETTY_FUNCTION__ << std::endl;
+}
+
+auto &bar = foo;
+
+struct a {
+  virtual void foo(void) = 0;
+};
+
+struct b : a {
+  using a::foo;
+  void bar(void) { foo(); }
+  // decltype(a::foo) & bar = a::foo;
+};
+
+void test(void)
+{
+  foo(1);
+  bar(2);
+}
+
+}; // test05
+
+namespace test07 {
+
+class a {
+  static const char * foo ;
+  static const std::string bar ;
+  static constexpr const char * baz = "baz";
+};
+const char * a::foo = "foo";
+const std::string a::bar = "bar";
+
+void
+test(void)
+{
+  // a aa;
+}
+
+}; // test05
+
+namespace test08 {
+
+template<typename T>
+struct print {
+  template<typename X>
+  std::ostream &
+  operator()(std::ostream & os, X && t)
+  {
+    return os << "forward: " << std::forward<T>(t);
+  }
+};
+
+template<typename T>
+struct print<T *> {
+  std::ostream &
+  operator()(std::ostream & os, T * t)
+  {
+    return os << "pointer: " << *t;
+  }
+};
+
+template<typename T>
+struct a {
+  explicit a(T && t)
+    : m_t(std::forward<T>(t))
+  {
+    std::ostream & os = std::cerr;
+    os << __PRETTY_FUNCTION__ << " m_t: ";
+    print<T>()(os, m_t);
+    os << std::endl;
+  }
+
+  explicit a(const T & t)
+    : m_t(t)
+  {
+    std::ostream & os = std::cerr;
+    os << __PRETTY_FUNCTION__ << " m_t: ";
+    print<T>()(os, m_t);
+    os << std::endl;
+  }
+
+  ~a(void)
+  {
+    std::ostream & os = std::cerr;
+    os << __PRETTY_FUNCTION__ << " m_t: ";
+    print<T>()(os, m_t);
+    os << std::endl;
+  }
+
+  T m_t;
+};
+
+void
+test(void)
+{
+  int i = 0;
+  double d = 0.0;
+  a<int> ai(i);
+  a<double> ad(d);
+  a<int> aim(std::move(i));
+  a<double> adm(std::move(d));
+  a<int *> aip(&i);
+  a<double *> adp(&d);
+}
+
+}; // test05
+
+namespace test09 {
+
+template<typename T, typename U>
+struct a {
+  explicit a(const T & t, const U & u)
+    : m_t(t)
+    , m_u(u)
+  {}
+  explicit a(const T & t)
+    : m_t(t)
+  {}
+  void operator=(const U & u) { m_u = u; }
+  void set(const U & u) { m_u = u; }
+  T m_t;
+  U m_u;
+};
+
+int t = 0;
+
+a<int, int>
+get_by_value(const int & u)
+{
+  return a<int, int>{ t, u };
+}
+
+a<int, int> reference_return_a(t);
+
+const a<int, int> &
+get_by_reference(const int & u)
+{
+  reference_return_a = u;
+  // reference_return_a.set(u);
+  return reference_return_a;
+}
+
+a<int, int> &&
+get_by_move(const int & u)
+{
+  return std::move(a<int, int>{t, u});
+  // return a<int, int>{t, u};
+}
+
+void
+test(void)
+{
+  int len = 1000000;
+  std::chrono::time_point<std::chrono::high_resolution_clock> start;
+  std::chrono::time_point<std::chrono::high_resolution_clock> stop;
+
+  std::cerr << "get_by_value:" << std::endl;
+  start = std::chrono::high_resolution_clock::now();
+  for (int i = 0; i < len; ++i) {
+    a<int, int> aa = get_by_value(i);
+    std::cerr << "\r" << aa.m_u;
+  }
+  stop = std::chrono::high_resolution_clock::now();
+  std::cerr << std::endl << "duration: " << (stop - start).count() << std::endl;
+
+  std::cerr << "get_by_value_rvalue:" << std::endl;
+  start = std::chrono::high_resolution_clock::now();
+  for (int i = 0; i < len; ++i) {
+    a<int, int> && aa = get_by_value(i);
+    std::cerr << "\r" << aa.m_u;
+  }
+  stop = std::chrono::high_resolution_clock::now();
+  std::cerr << std::endl << "duration: " << (stop - start).count() << std::endl;
+
+  std::cerr << "get_by_reference:" << std::endl;
+  start = std::chrono::high_resolution_clock::now();
+  for (int i = 0; i < len; ++i) {
+    const a<int, int> & aa = get_by_reference(i);
+    std::cerr << "\r" << aa.m_u;
+  }
+  stop = std::chrono::high_resolution_clock::now();
+  std::cerr << std::endl << "duration: " << (stop - start).count() << std::endl;
+
+  // invalid examples
+  /*
+  std::cerr << "get_by_move_value:" << std::endl;
+  start = std::chrono::high_resolution_clock::now();
+  for (int i = 0; i < len; ++i) {
+    a<int, int> aa = get_by_move(i);
+    std::cerr << "\r" << aa.m_u;
+  }
+  stop = std::chrono::high_resolution_clock::now();
+  std::cerr << std::endl << "duration: " << (stop - start).count() << std::endl;
+
+  std::cerr << "get_by_move_rvalue:" << std::endl;
+  start = std::chrono::high_resolution_clock::now();
+  for (int i = 0; i < len; ++i) {
+    a<int, int> && aa = get_by_move(i);
+    std::cerr << "\r" << aa.m_u;
+  }
+  stop = std::chrono::high_resolution_clock::now();
+  std::cerr << std::endl << "duration: " << (stop - start).count() << std::endl;
+  */
+}
+
+}; // test05
+
+namespace test10 {
+
+class a {
+  public:
+    a(const unsigned int & i) : m_int(std::make_shared<unsigned int>(i)) {}
+    operator unsigned int &(void)
+    {
+      return *m_int;
+    }
+    std::shared_ptr<unsigned int> m_int;
+};
+
+void
+test(void)
+{
+  a aa { 0 };
+  std::cerr << *aa.m_int << std::endl;
+  static_cast<unsigned int &>(aa) = 42;
+  std::cerr << *aa.m_int << std::endl;
+}
+
+}; // test05
+
+namespace test11 {
+
+template<typename T>
+class a {
+  public:
+    a(const T & i) {}
+    a(const T & i, const unsigned int &) {}
+};
+
+void
+test(void)
+{
+  std::cerr << std::boolalpha;
+  // std::cerr << std::is_constructible<a, const unsigned int &>::value << std::endl;
+  // std::cerr << std::is_constructible<a, unsigned int &>::value << std::endl;
+  // std::cerr << std::is_constructible<a, unsigned int>::value << std::endl;
+  std::cerr << std::is_constructible<a<unsigned int>, const unsigned int &>::value << std::endl;
+  std::cerr << std::is_constructible<a<unsigned int>, unsigned int &>::value << std::endl;
+  std::cerr << std::is_constructible<a<unsigned int>, unsigned int>::value << std::endl;
+}
+
+}; // test05
+
+namespace test12 {
+
+void
+test(void)
+{
+  char a[2*sizeof(int)];
+  uint * b = reinterpret_cast<uint *>(a);
+  b[0] = (uint)'a' + ((uint)'b' << 8) + ((uint)'c' << 16) + ((uint)'d' << 24);
+  b[1] = (uint)'e' + ((uint)'f' << 8) + ((uint)'g' << 16) + ((uint)'h' << 24);
+  std::cerr << b[0] << ": " << a[0] << " " << a[1] << " " << a[2] << " " << a[3] << std::endl;
+  std::cerr << b[1] << ": " << a[4] << " " << a[5] << " " << a[6] << " " << a[7] << std::endl;
+}
+
+}; // test05
+
+namespace test13 {
+
+template<typename ... Args>
+struct a {
+};
+
+template<typename ... Types> struct b;
+
+// template<template<typename ...> class T, typename ... Args>
+// template<template<typename ... Args> class T> // , typename ... Args>
+// template<typename ... Args>
+// template<template<typename T<typename ... Args>>>
+
+template<typename ... Args, template<typename ...> class T>
+struct b<T<Args ...>> {
+  b(const T<Args ...> & t)
+    : m_t(t)
+  {}
+  T<Args ...> m_t;
+};
+
+template<typename ... Args, template<typename ...> class T>
+struct b<T<Args ...> &>
+  : public b<T<Args ...>>
+{
+  using base = b<T<Args ...>>;
+  using base::base;
+};
+
+void
+test(void)
+{
+  a<int> aa_1;
+  b<a<int>> bb_1(aa_1);
+  b<a<int> &> bb_2(aa_1);
+}
+
+}; // test05
+
+namespace test15 {
+
+struct i {
+  virtual void fun(void) = 0;
+};
+
+struct a : i {
+  void fun(void) { std::cerr << __PRETTY_FUNCTION__ << std::endl; }
+};
+
+struct b {
+};
+
+template<typename I>
+struct with_i : I
+{
+  virtual
+  void run(void)
+  {
+    std::cerr << "with_i" << std::endl;
+    static_cast<i *>(this)->fun();
+  }
+};
+
+struct without_i
+{
+  virtual
+  void run(void) { std::cerr << "without_i" << std::endl; }
+};
+
+template<typename T>
+struct i_test
+  : std::conditional<std::is_base_of<i, T>::value, with_i<T>, without_i>::type
+{};
+
+void
+test(void)
+{
+  i_test<a> a_test;
+  a_test.run();
+  i_test<b> b_test;
+  b_test.run();
+}
+
+}; // test05
+
+int main(int argc, char ** argv)
+{
+  // if (argc != 2) {
+  //   std::cerr << "Need one string argument" << std::endl;
+  //   return 1;
+  // }
+
+  // xid<xcb_window_t> xid_1;
+
+  // xid<xcb_window_t,
+  //     allocator<xcb_window_t>::allocate<&foo::create>,
+  //     allocator<xcb_window_t>::deallocate<&foo::destroy>>
+  //       xid_2;
+
+  // xid<xcb_window_t,
+  //     allocator<xcb_window_t, double>::allocate<&bar::create>,
+  //     allocator<xcb_window_t>::deallocate<&bar::destroy>>
+  //       xid_3(0.0);
+
+  // wrapper<decltype(foo::create), foo::create,
+  //         decltype(foo::destroy), foo::destroy>::allocate(NULL, 0);
+
+  // wrapper<decltype(foo::create), foo::create,
+  //         decltype(foo::destroy), foo::destroy>::deallocate(NULL, 0);
+
+  // w_1.allocate(NULL, 0);
+  // w_1.deallocate(NULL, 0);
+
+  // // xpp::resource class!
+  // // >>>>>>>>><<<<<<<<<<<
+  // wrapper<decltype(bar::create), bar::create,
+  //         decltype(bar::destroy), bar::destroy>::allocate(NULL, 0, 0.0);
+
+  // wrapper<decltype(bar::create), bar::create,
+  //         decltype(bar::destroy), bar::destroy>::deallocate(NULL, 0);
+
+  // wrapper<decltype(bar::create), bar::create,
+  //         decltype(bar::destroy), bar::destroy> w_2;
+  // w_2.allocate(NULL, 0, 0.0);
+  // w_2.deallocate(NULL, 0);
+
+  // wrapper<decltype(bar::create), bar::create> w_2;
+
+  // xpp::connection<> connection("");
+
+  // std::map<int, char> char_map;
+  // char_map[0] = 'a';
+  // char_map[1] = 'b';
+  // char_map[2] = 'c';
+
+  // value_iterator<std::map<int, char>::iterator> begin =
+  //   value_iterator<std::map<int, char>::iterator>(char_map.begin());
+  // value_iterator<std::map<int, char>::iterator> end =
+  //   value_iterator<std::map<int, char>::iterator>(char_map.end());
+
+  // std::vector<char> chars_1 = std::vector<char>(begin, end); std::vector<char> chars_2 = { begin, end };
+  // const char * legacy_chars = "abc";
+  // std::vector<char> chars_3 = { legacy_chars, legacy_chars + 3 };
+
+  // // for (auto it = begin; it != end; ++it) {
+  // for (auto & c : chars_1) {
+  //   std::cerr << "value: " << c << std::endl;
+  // }
+
+  // value_iterator<std::vector<char>::iterator> v_begin =
+  //   value_iterator<std::vector<char>::iterator>(chars_1.begin());
+  // value_iterator<std::vector<char>::iterator> v_end =
+  //   value_iterator<std::vector<char>::iterator>(chars_1.end());
+
+  // std::vector<char> vchar_1(v_begin, v_end);
+  // std::vector<char> vchar_2 = { v_begin, v_end };
+
+  // std::string my_string(argv[1]);
+  // std::cerr << "test 1" << std::endl;
+  // test(my_string.begin(), my_string.end());
+  // std::cerr << "test 2" << std::endl;
+  // test(my_string.c_str(), my_string.c_str() + my_string.length());
+
+  // auto atom = connection.intern_atom(false, "MY_STRING");
+
+  // xpp::request::x::change_property(connection, XCB_PROP_MODE_REPLACE,
+  //     connection.root(), atom->atom, XCB_ATOM_STRING, 8, my_string.length(),
+  //     my_string.c_str());
+
+  // connection.change_property(XCB_PROP_MODE_REPLACE, connection.root(),
+  //     atom->atom, XCB_ATOM_STRING, 8,
+  //     begin, end);
+
+  // connection.change_property(XCB_PROP_MODE_REPLACE, connection.root(),
+  //     atom->atom, XCB_ATOM_STRING, 8,
+  //     v_begin, v_end);
+
+  // connection.flush();
+
+  // caller()(callee(), 0);
+  // caller()(callee(), 1);
+  // caller()(callee(), 2);
+
+  // using mylib::request::checked;
+  // using mylib::request::unchecked;
+
+  // mylib::extension::request::void_request<>()();
+  // mylib::extension::request::void_request<checked>()();
+
+  // mylib::c c;
+  // c.void_request<>();
+  // c.reply_request<>();
+
+  // test00::test();
+  // test01::test();
+  // test02::test();
+  // test03::test();
+  // test04::test();
+  // test05::test();
+  // test06::test();
+  // test07::test();
+  // test08::test();
+  // test09::test();
+  // test10::test();
+  // test11::test();
+  // test12::test();
+  // test13::test();
+  // test14::test();
+  test15::test();
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/xlib.cpp polybar-3.2.1/lib/xpp/src/tests/xlib.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/xlib.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/xlib.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,30 @@
+#include <climits>
+#include <unistd.h>
+#include <iostream>
+
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+
+int main(int argc, char ** argv)
+{
+  Display * dpy = XOpenDisplay(NULL);
+  Window root = DefaultRootWindow(dpy);
+
+  XRRScreenConfiguration * screen_cfg = XRRGetScreenInfo(dpy, root);
+  std::cerr << "rate: " << XRRConfigCurrentRate(screen_cfg) << std::endl;
+
+  int nrates = 0;
+  short * rates = XRRConfigRates(screen_cfg, 10, &nrates);
+  std::cerr << "nrates: " << nrates << std::endl;
+  for (int i = 0; i < nrates; ++i) {
+    std::cerr << "rate: " << rates[i] << std::endl;
+  }
+
+  int nhosts = 0;
+  XHostAddress * host_addresses = XListHosts(dpy, &nhosts, True);
+  for (int i = 0; i < nhosts; ++i) {
+    std::cerr << "address: " << host_addresses[i].address << std::endl;
+  }
+
+  return EXIT_SUCCESS;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/xlib-test.cpp polybar-3.2.1/lib/xpp/src/tests/xlib-test.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/xlib-test.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/xlib-test.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,33 @@
+#include <climits>
+#include <unistd.h>
+#include <iostream>
+
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+
+int main(int argc, char ** argv)
+{
+  Display * dpy = XOpenDisplay(NULL);
+  Window root = DefaultRootWindow(dpy);
+
+  XRRScreenConfiguration * screen_cfg = XRRGetScreenInfo(dpy, root);
+  std::cerr << "rate: " << XRRConfigCurrentRate(screen_cfg) << std::endl;
+
+  for (int nsizes = 0; nsizes < 16; ++nsizes) {
+    int nrates = 0;
+    short * rates = XRRConfigRates(screen_cfg, nsizes, &nrates);
+    std::cerr << "nrates: " << nrates << std::endl;
+    for (int i = 0; i < nrates; ++i) {
+      std::cerr << "rate: " << rates[i] << std::endl;
+    }
+  }
+
+  int nhosts = 0;
+  int state = 0;
+  XHostAddress * host_addresses = XListHosts(dpy, &nhosts, &state);
+  for (int i = 0; i < nhosts; ++i) {
+    std::cerr << "address: " << host_addresses[i].address << std::endl;
+  }
+
+  return 0;
+}
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/tests/xproto.cpp polybar-3.2.1/lib/xpp/src/tests/xproto.cpp
--- polybar-3.2.1.orig/lib/xpp/src/tests/xproto.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/tests/xproto.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1,870 @@
+#include <climits>
+#include <unistd.h>
+#include <iostream>
+
+#include <X11/Xlib.h>
+#include <X11/keysymdef.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/cursorfont.h> // XC_cross
+
+// #include <xcb/randr.h>
+// // #include "../gen/xproto_requests_with_accessors.hpp"
+// #include "../gen/randr_requests.hpp"
+// #include "../gen/xproto.hpp"
+// #include "../gen/randr.hpp"
+
+// #include "../xpp.hpp"
+
+#include "../event.hpp"
+#include "../core/connection.hpp"
+// #include "../gen/xproto.hpp"
+// #include "../gen/randr.hpp"
+
+bool g_quit = false;
+
+class key_printer
+  : public xpp::event::sink<xpp::x::event::key_press,
+                            xpp::x::event::key_release,
+                            xpp::x::event::button_press,
+                            xpp::randr::event::notify,
+                            xpp::damage::event::notify,
+                            xpp::xfixes::event::selection_notify,
+                            xpp::screensaver::event::notify
+                            >
+{
+  public:
+    key_printer(const xpp::x::protocol & x)
+      : m_x(x)
+    {}
+
+    void handle(const xpp::x::event::key_press & e)
+    {
+      auto kbd_mapping = m_x.get_keyboard_mapping(e->detail, 1);
+      auto keysym = *kbd_mapping.keysyms().begin();
+
+      if (keysym == XK_Escape) {
+        std::cerr << "quitting" << std::endl;
+        m_x.ungrab_keyboard();
+        g_quit = true;
+      } else {
+        std::cerr << "key pressed: " << XKeysymToString(keysym) << std::endl;
+      }
+    }
+
+    void handle(const xpp::x::event::key_release & e)
+    {
+      auto kbd_mapping = m_x.get_keyboard_mapping(e->detail, 1);
+      auto keysym = *kbd_mapping.keysyms().begin();
+      std::cerr << "key released: " << XKeysymToString(keysym) << std::endl;
+    }
+
+    void handle(const xpp::x::event::button_press & e)
+    {
+      m_x.ungrab_pointer();
+
+      std::cerr << "root: 0x"
+                << std::hex << e->root << std::dec
+                << "; event: 0x"
+                << std::hex << e->event << std::dec
+                << "; child: 0x"
+                << std::hex << e->child << std::dec
+                << std::endl;
+
+      xpp::window grab_window = e.event<xpp::window>();
+      std::cerr << "grab_window: " << grab_window << std::endl;
+
+      if (e->event == e->root) {
+        grab_window = e.child();
+        std::cerr << "new grab_window: " << grab_window << std::endl;
+        auto translate = grab_window.translate_coordinates(grab_window, 1, 1);
+        grab_window = translate->child;
+      }
+
+      std::cerr << "grabbing "
+                << std::hex << grab_window << std::dec
+                << std::endl;
+
+      *m_x.grab_keyboard(true, grab_window,
+                         XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
+    }
+
+    void handle(const xpp::randr::event::notify & e)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+
+    void handle(const xpp::damage::event::notify & e)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+
+    void handle(const xpp::xfixes::event::selection_notify & e)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+
+    void handle(const xpp::screensaver::event::notify & e)
+    {
+      std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    }
+
+    // does not work
+    // template<int OpCode, typename Event>
+    // void handle(const xpp::generic::event<OpCode, Event> &)
+    // {
+    //   std::cerr << __PRETTY_FUNCTION__ << std::endl;
+    // }
+
+  private:
+    const xpp::x::protocol & m_x;
+};
+
+class xevent : public xpp::x::event::dispatcher {
+  public:
+
+    template<typename Event>
+    void operator()(const Event &) const
+    {
+    }
+
+    // template<int OpCode, typename Event>
+    // void operator()(const xpp::generic::event<OpCode, Event> &) const
+    // {
+    // }
+
+    void doit(xcb_generic_event_t * const e) const
+    {
+#if not defined __clang__
+      dispatcher::operator()(*this, e);
+#endif
+    }
+
+  protected:
+    operator xcb_connection_t * const(void) { return nullptr; }
+};
+
+int main(int argc, char ** argv)
+{
+  xpp::connection<xpp::extension::randr,
+                  xpp::extension::render,
+                  xpp::extension::xv,
+                  xpp::extension::damage,
+                  xpp::extension::xinerama,
+                  xpp::extension::xfixes,
+                  xpp::extension::input,
+                  xpp::extension::screensaver>
+                    connection("");
+
+  // xpp::request::x::map_window(connection, 0);
+  // xpp::request::x::query_tree(connection, 0);
+
+  xpp::event::registry<xpp::extension::randr,
+                       xpp::extension::render,
+                       xpp::extension::xv,
+                       xpp::extension::damage,
+                       xpp::extension::xinerama,
+                       xpp::extension::xfixes,
+                       xpp::extension::input,
+                       xpp::extension::screensaver>
+                         registry(connection);
+
+  std::vector<key_printer *> printers(100, new key_printer(connection));
+
+  for (int i =  0; i < 100; ++i) {
+    registry.attach(0, printers[i]);
+  }
+
+  for (int i =  0; i < 99; ++i) {
+    registry.detach(0, printers[i]);
+  }
+
+  auto font_id = connection.generate_id();
+  connection.open_font(font_id, "cursor");
+  auto cursor_id = connection.generate_id();
+  connection.create_glyph_cursor(cursor_id, font_id, font_id,
+      XC_cross, XC_cross + 1, 0, 0, 0, 0xffff, 0xffff, 0xffff);
+  connection.close_font(font_id);
+
+  *connection.grab_pointer(false, connection.root(),
+                           XCB_EVENT_MASK_BUTTON_PRESS,
+                           XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
+                           XCB_NONE, cursor_id);
+
+  connection.free_cursor(cursor_id);
+
+  std::cerr << "Please click on a window" << std::endl;
+
+// clang_complete does not like this
+// causes vim to segfault
+#if not defined __clang__
+
+  while (! g_quit) {
+    connection.flush();
+    registry.dispatch(connection.wait_for_event());
+  }
+
+#endif
+
+
+  // WATCHOUT FOR THE RETURN
+  // >>>>>>>>>>>>>>>>>>>>>>>
+  return 0;
+  // <<<<<<<<<<<<<<<<<<<<<<<
+
+
+
+
+
+  *((xpp::randr::protocol &)connection).query_version(
+      XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
+
+  // auto & randr = (xpp::protocol::randr &)c;
+  // auto version = randr.query_version(
+  //     XCB_RANDR_MAJOR_VERSION, XCB_RANDR_MINOR_VERSION);
+  // std::cerr << "randr_major: " << version->major_version
+  //           << "; randr_minor: " << version->minor_version << std::endl;
+
+  // auto screens = connection.query_screens();
+
+  // for (auto & info : screens.screen_info()) {
+  //   std::cerr << "screen @ "
+  //             << info.x_org << "x" << info.x_org
+  //             << "+"
+  //             << info.width << "+" << info.height
+  //             << std::endl;
+  // }
+
+  std::cerr << "connection.root().query_tree().children<xcb_window_t>():" << std::endl;
+  for (auto & window : connection.root().query_tree().children()) {
+    std::cerr << window << ", ";
+  }
+  std::cerr << std::endl;
+
+  std::cerr << "connection.root().query_tree().children<xpp::window>():" << std::endl;
+  for (auto & window : connection.root().query_tree().children<xpp::window>()) {
+    std::cerr << window << ": ";
+    for (auto & child : window.query_tree().children<xpp::window>()) {
+      std::cerr << child << ", ";
+    }
+    std::cerr << std::endl;
+  }
+  std::cerr << std::endl;
+
+  auto atom = xpp::request::x::intern_atom(
+      connection, false, "_NET_CLIENT_LIST_STACKING");
+  auto property = xpp::request::x::get_property(
+      connection, false, connection.root(), atom->atom, XCB_ATOM_WINDOW, 0, UINT_MAX);
+
+  std::cerr << "windows (xcb_window_t):" << std::hex << std::endl;
+  for (auto & w : property.value<xcb_window_t>()) {
+    std::cerr << "0x" << w << ", ";
+  }
+  std::cerr << std::dec << std::endl;
+
+  std::cerr << "windows (xpp::window)" << std::hex << std::endl;
+  for (auto & w : property.value<xpp::window>()) {
+    std::cerr << w << ": ";
+    for (auto & child : w.query_tree().children<xpp::window>()) {
+      std::cerr << child << ", ";
+    }
+    std::cerr << std::endl;
+  }
+  std::cerr << std::dec << std::endl;
+
+  std::cerr << "hosts:" << std::endl;
+  auto hosts = xpp::request::x::list_hosts(connection);
+  for (auto & host : hosts.hosts()) {
+    std::cerr << "host: " << xcb_host_address(&host) << std::endl;
+  }
+
+  std::cerr << "fonts:" << std::endl;
+  auto fonts = xpp::request::x::list_fonts(connection, 8, 1, "*");
+  for (auto & name : fonts.names()) {
+    std::cerr << "font (" << name.length() << "): " << name << std::endl;
+  }
+
+  auto font_paths = xpp::request::x::get_font_path(connection);
+  for (auto & path : font_paths.path()) {
+    std::cerr << "path (" << path.length() << "): " << path << std::endl;
+  }
+
+  auto screen_info = xpp::request::randr::get_screen_info(connection, connection.root());
+  std::cerr << "nsizes: " << (int)screen_info->nSizes << std::endl;
+  std::cerr << "SizeID: " << (int)screen_info->sizeID << std::endl;
+  int i = 0;
+  for (auto & rate : screen_info.rates()) {
+    if (++i > screen_info->nSizes) break;
+
+    uint16_t * rates = xcb_randr_refresh_rates_rates(&rate);
+    std::cerr << "rates (length: "
+      << xcb_randr_refresh_rates_rates_length(&rate)
+      << "): ";
+
+    for (int j = 0; j < xcb_randr_refresh_rates_rates_length(&rate); ++j) {
+      std::cerr << rates[j];
+      if (j < xcb_randr_refresh_rates_rates_length(&rate) - 1) {
+        std::cerr << ", ";
+      }
+    }
+    std::cerr << std::endl;
+
+  }
+
+/*
+  xcb_list_hosts_cookie_t hosts_cookie = xcb_list_hosts(c);
+  xcb_list_hosts_reply_t * hosts_reply = xcb_list_hosts_reply(connection, hosts_cookie, NULL);
+
+  std::cerr << "list hosts" << std::endl;
+  xcb_host_iterator_t host_iter = xcb_list_hosts_hosts_iterator(hosts_reply);
+  for ( ; host_iter.rem > 0; xcb_host_next(&host_iter) ) {
+    xcb_host_t * host = (xcb_host_t *)host_iter.data;
+    std::cerr << "host adress: " << xcb_host_address(host) << std::endl;
+    std::cerr << "host family: " << (int)host->family << std::endl;
+    std::cerr << "host address_len: " << (int)host->address_len << std::endl;
+  }
+
+  std::cerr << "Randr refresh rates: " << std::endl;
+  xcb_randr_get_screen_info_cookie_t screen_info_cookie =
+    xcb_randr_get_screen_info(connection, connection.root());
+  xcb_randr_get_screen_info_reply_t * screen_info_reply =
+    xcb_randr_get_screen_info_reply(connection, screen_info_cookie, NULL);
+  std::cerr << "Randr refresh rates length: "
+            << xcb_randr_get_screen_info_rates_length(screen_info_reply)
+            << std::endl;
+
+  xcb_randr_refresh_rates_iterator_t refresh_rates_iter =
+    xcb_randr_get_screen_info_rates_iterator(screen_info_reply);
+
+  for (int i = 0; i < screen_info->nSizes; ++i) {
+    xcb_randr_refresh_rates_next(&refresh_rates_iter);
+
+    xcb_randr_refresh_rates_t * rate =
+      (xcb_randr_refresh_rates_t *)refresh_rates_iter.data;
+    uint16_t * rates = xcb_randr_refresh_rates_rates(rate);
+    std::cerr << "rates (length: "
+      << xcb_randr_refresh_rates_rates_length(rate)
+      << "): ";
+    for (int j = 0; j < xcb_randr_refresh_rates_rates_length(rate); ++j) {
+      std::cerr << rates[j];
+      if (j < xcb_randr_refresh_rates_rates_length(rate) - 1) {
+        std::cerr << ", ";
+      }
+    }
+    std::cerr << std::endl;
+  }
+
+  auto pict_formats = xpp::request::render::query_pict_formats(c);
+  for (auto & format : pict_formats.formats()) {
+    std::cerr << "format.depth: " << (int)format.depth << std::endl;;
+  }
+  */
+
+    /*
+  {
+  Display * dpy = XOpenDisplay(NULL);
+  Window root = DefaultRootWindow(dpy);
+  XRRScreenConfiguration * screen_cfg = XRRGetScreenInfo(dpy, root);
+  std::cerr << "rate: " << XRRConfigCurrentRate(screen_cfg) << std::endl;
+  int nrates = 0;
+  short * rates = XRRConfigRates(screen_cfg, 10, &nrates);
+  std::cerr << "nrates: " << nrates << std::endl;
+  for (int i = 0; i < nrates; ++i) {
+    std::cerr << "rate: " << rates[i] << std::endl;
+  }
+  }
+  */
+
+// auto iter = xpp::iterator<xcb_str_t, xcb_str_t, xcb_list_fonts_reply_t,
+//      xcb_str_iterator_t,
+//                xpp::callable<decltype(xcb_str_next), xcb_str_next>,
+//                xpp::callable<decltype(xcb_str_sizeof), xcb_str_sizeof>,
+//                xpp::callable<decltype(xpp::callable_test), xpp::callable_test>>();
+
+// auto iter2 = xpp::iterator<int, int, int, int,
+//                xpp::callable<decltype(xpp::next), xpp::next>,
+//                xpp::callable<decltype(xpp::size_of), xpp::size_of>,
+//                xpp::callable<decltype(xpp::get_iterator), xpp::get_iterator>>();
+
+  // xcb_window_t root = 0;
+  // auto x = connection.x();
+  // auto windows = connection.x().query_tree(root);
+  // auto primary_output = connection.randr().get_output_primary(root);
+
+  // auto window = *windows.children().begin();
+  // auto geometry = window.get_geometry();
+
+
+
+  // primary_output->output;
+
+  /*
+  xpp::connection c("");
+  // xpp::xproto::connection cc(*c);
+  std::cerr << "c: " << *c << std::endl;
+  std::cerr << "connection.root() " << connection.root() << std::endl;
+
+  uint32_t mask = XCB_CW_BACK_PIXEL
+                | XCB_CW_BORDER_PIXEL
+                | XCB_CW_OVERRIDE_REDIRECT;
+  uint32_t values[] = { 0xff123456, 0xff654321, true };
+  // uint32_t values[] = { 0, 0, true };
+
+  xpp::window window_1(
+      connection, 24, *connection.root(), 25, 25, 50, 50, 2,
+      XCB_WINDOW_CLASS_INPUT_OUTPUT, XCB_WINDOW_CLASS_COPY_FROM_PARENT,
+      mask, values);
+
+  std::cerr << window_1 << std::endl;
+  */
+
+  // {
+  //   auto window_2 = window_1;
+  //   std::cerr << window_2 << std::endl;
+  //   {
+  //     auto window_3 = window_2;
+  //     std::cerr << window_3 << std::endl;
+  //     window_3.map();
+  //     connection.flush();
+  //   }
+  //   sleep(3);
+  // }
+
+  // window_1.map();
+  // connection.flush();
+  // sleep(1);
+
+  // connection.root().query_tree().children();
+
+
+  // intern_atom
+  /*
+  auto atom =
+    xpp::xproto::request::intern_atom(*connection, false, "_NET_CLIENT_LIST_STACKING");
+  auto atom_name = xpp::xproto::request::get_atom_name(*connection, atom->atom);
+  std::cerr << atom_name.name() << std::endl;
+
+  auto property = xpp::xproto::request::get_property(
+      *connection, false, *connection.root(), atom->atom, XCB_ATOM_WINDOW, 0, UINT_MAX);
+
+  std::cerr << "windows" << std::hex << std::endl;
+  for (auto & p : property.value<xcb_window_t>()) {
+    std::cerr << "0x" << p << ", ";
+  }
+  std::cerr << std::dec << std::endl;
+  */
+
+  /*
+  typedef xpp::generic::fixed_size::iterator<void,
+                                             xcb_window_t,
+                                             xcb_get_property_reply_t,
+                                             xcb_get_property_value,
+                                             xcb_get_property_value_length>
+                                               window_iterator;
+
+  window_iterator window_begin = property.value<xcb_window_t>().begin();
+  window_iterator window_end = property.value<xcb_window_t>().end();
+  */
+
+  // list_fonts_with_info && list_fonts
+  /*
+  auto fonts_with_info =
+    xpp::xproto::request::list_fonts_with_info(*connection, 8, "*");
+
+  for (int i = 0; i < 8; ++i) {
+    std::cerr << fonts_with_info.name() << std::endl;
+    fonts_with_info.reset();
+  }
+
+  auto fonts = xpp::xproto::request::list_fonts(*connection, 8, "*");
+  for (auto & font : fonts.names()) {
+    std::cerr << "(" << font.length() << "): " << font << std::endl;
+  }
+  */
+
+  // auto grab = xpp::xproto::request::grab_keyboard(
+  //     *connection, false, connection.root(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
+
+  // query_tree iterator
+  /*
+  typedef xpp::generic::fixed_size::iterator<xcb_window_t,
+                                             xcb_window_t,
+                                             xcb_query_tree_reply_t,
+                                             xcb_query_tree_children,
+                                             xcb_query_tree_children_length>
+                                               children_iterator;
+
+  children_iterator children_begin, children_end;
+  */
+
+  // {
+  //   auto tree = xpp::xproto::request::query_tree(*connection, connection.root());
+  //   children_begin = tree.children().begin();
+  //   children_end = tree.children().end();
+  // }
+
+  // std::cerr << "windows" << std::endl;
+  // for (auto it = children_begin; it != children_end; ++it) {
+  //   std::cerr << std::hex << "0x" << *it << ", ";
+  // }
+  // std::cerr << std::endl;
+
+  // std::cerr << "crtcs" << std::endl;
+  // auto primary = xpp::request::randr::get_output_primary(*connection, connection.root());
+  // for (auto & crtc : xpp::request::randr::get_output_info(
+  //       *connection, primary->output, XCB_TIME_CURRENT_TIME).crtcs()) {
+  //   std::cerr << "crtc: " << crtc << std::endl;
+  // }
+
+  // list_hosts
+  /*
+  std::cerr << "hosts" << std::endl;
+  for (auto & host : xpp::xproto::request::list_hosts(*c).hosts()) {
+    std::cerr << std::string((char *)xcb_host_address(&host),
+                             xcb_host_address_length(&host))
+              << std::endl;
+  }
+  */
+
+  // std::cerr << "extensions" << std::endl;
+  // for (auto & name : xpp::xproto::request::list_extensions(*c).names()) {
+  //   std::cerr << std::string((char *)xcb_str_name(&name), xcb_str_name_length(&name)) << std::endl;
+  // }
+
+  // get_font_path
+  /*
+  for (auto & path : xpp::xproto::request::get_font_path(*c).path()) {
+    std::cerr << "(" << path.length() << ") path: " << path << std::endl;
+  }
+  */
+
+  // list_fonts
+  /*
+  const size_t n_fonts = 16;
+
+  std::cerr << "fonts (xpp 2)" << std::endl;
+
+  typedef xpp::generic::variable_size::iterator<xcb_str_t,
+                                                xcb_str_t,
+                                                xcb_list_fonts_reply_t,
+                                                xcb_str_iterator_t,
+                                                xcb_str_next,
+                                                xcb_str_sizeof,
+                                                xcb_list_fonts_names_iterator>
+                                                  names_iterator;
+
+  names_iterator names_begin, names_end;
+
+  {
+    auto names = xpp::xproto::request::list_fonts(*connection, n_fonts, 1, "*");
+
+    names_begin = names_iterator::begin(names.get());
+    names_end = names_iterator::end(names.get());
+  }
+
+  for (auto it = names_begin; it != names_end; ++it) {
+    std::cerr << it->length() << ": " << *it << std::endl;
+  }
+  */
+
+  return EXIT_SUCCESS;
+}
+
+
+  // auto it = names_begin;
+  // std::cerr << "it  : " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // ++it;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // ++it;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it++;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it++;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it++;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it++;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // ++it;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it++;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // ++it;
+  // std::cerr << "it++: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // it--;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // --it;
+  // std::cerr << "it--: " << xcb_str_name_length(&*it) << ": "
+  //           << std::string((char *)xcb_str_name(&*it), xcb_str_name_length(&*it))
+  //           << std::endl;
+
+  // {
+  //   std::cerr << "fonts (native)" << std::endl;
+  //   xcb_list_fonts_cookie_t cookie = xcb_list_fonts(*connection, n_fonts, 1, "*");
+  //   xcb_list_fonts_reply_t * reply = xcb_list_fonts_reply(*connection, cookie, NULL);
+  //   xcb_str_iterator_t iter = xcb_list_fonts_names_iterator(reply);
+  //   xcb_str_t * name, * R, * prev;
+  //   int len1, len2, len3, len4;
+
+  //   // for ( ; iter.rem; xcb_str_next(&iter)) {
+  //   //   xcb_str_t * name = iter.data;
+  //   //   std::cerr << xcb_str_name_length(name) << ": " << std::string((char *)xcb_str_name(name), xcb_str_name_length(name)) << std::endl;
+  //   // }
+
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   len1 = xcb_str_sizeof(iter.data);
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   len2 = xcb_str_sizeof(iter.data);
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   len3 = xcb_str_sizeof(iter.data);
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   len4 = xcb_str_sizeof(iter.data);
+  //   xcb_str_next(&iter);
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+
+
+
+  //   ++iter.rem;
+  //   R = iter.data;
+  //   // xcb_str_t * prev = R - xcb_str_sizeof(R);
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_sizeof(R));
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R)) - sizeof(xcb_str_t) - 1;
+  //   prev = (xcb_str_t *)((char *)R) - len4;
+  //   iter.index = (char *) iter.data - (char *) prev;
+  //   iter.data = prev;
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   ++iter.rem;
+  //   R = iter.data;
+  //   // xcb_str_t * prev = R - xcb_str_sizeof(R);
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R));
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R)) - sizeof(xcb_str_t) - 2;
+  //   prev = (xcb_str_t *)((char *)R) - len3;
+  //   iter.index = (char *) iter.data - (char *) prev;
+  //   iter.data = prev;
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   ++iter.rem;
+  //   R = iter.data;
+  //   // xcb_str_t * prev = R - xcb_str_sizeof(R);
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R));
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R)) - sizeof(xcb_str_t);
+  //   prev = (xcb_str_t *)((char *)R) - len2;
+  //   iter.index = (char *) iter.data - (char *) prev;
+  //   iter.data = prev;
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   ++iter.rem;
+  //   R = iter.data;
+  //   // xcb_str_t * prev = R - xcb_str_sizeof(R);
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R));
+  //   // prev = (xcb_str_t *)(((char *)R) - xcb_str_name_length(R)) - sizeof(xcb_str_t);
+  //   prev = (xcb_str_t *)((char *)R) - len1;
+  //   iter.index = (char *) iter.data - (char *) prev;
+  //   iter.data = prev;
+  //   name = iter.data;
+  //   std::cerr << std::endl;
+  //   std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   std::cerr << "index: 0x" << std::hex << iter.index <<  " (" << std::dec << iter.index << ")" << std::endl;
+  //   std::cerr << "rem: " << iter.rem << std::dec << std::endl;
+  //   std::cerr << xcb_str_name_length(name) << ": "
+  //             << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //             << std::endl;
+
+  //   // xcb_str_next(&iter);
+  //   // name = iter.data;
+  //   // std::cerr << "data: 0x" << std::hex << iter.data << " (" << std::dec << (unsigned long)iter.data << ")" << std::endl;
+  //   // std::cerr << "index: 0x" << std::hex << iter.index << std::dec << std::endl;
+  //   // std::cerr << xcb_str_name_length(name) << ": "
+  //   //           << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //   //           << std::endl;
+
+  //   // ++iter.rem;
+  //   // R = iter.data;
+  //   // prev = R - xcb_str_sizeof(R);
+  //   // iter.index = (char *) iter.data - (char *) prev;
+  //   // iter.data = prev;
+  //   // name = iter.data;
+  //   // std::cerr << "data: 0x" << std::hex << iter.data << "(" << std::dec << iter.data << ")" << std::endl;
+  //   // std::cerr << "index: 0x" << std::hex << iter.index << std::endl;
+  //   // std::cerr << xcb_str_name_length(name) << ": "
+  //   //           << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //   //           << std::endl;
+
+  //   // xcb_str_next(&iter);
+  //   // name = iter.data;
+  //   // std::cerr << "data: 0x" << std::hex << iter.data << "(" << std::dec << iter.data << ")" << std::endl;
+  //   // std::cerr << "index: 0x" << std::hex << iter.index << std::endl;
+  //   // std::cerr << xcb_str_name_length(name) << ": "
+  //   //           << std::string((char *)xcb_str_name(name), xcb_str_name_length(name))
+  //   //           << std::endl;
+
+  //   std::cerr << "length: " << xcb_list_fonts_names_length(reply) << std::endl;
+  // }
+
diff -Nuar polybar-3.2.1.orig/lib/xpp/src/xpp.cpp polybar-3.2.1/lib/xpp/src/xpp.cpp
--- polybar-3.2.1.orig/lib/xpp/src/xpp.cpp	1970-01-01 02:00:00.000000000 +0200
+++ polybar-3.2.1/lib/xpp/src/xpp.cpp	2017-08-30 16:02:01.000000000 +0300
@@ -0,0 +1 @@
+#include "xpp.hpp"
